<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fleschier 渐寒๑</title>
  
  <subtitle>Welcome~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fleschier.github.io/"/>
  <updated>2019-03-05T14:30:18.898Z</updated>
  <id>https://fleschier.github.io/</id>
  
  <author>
    <name>Fleschier</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VScode python编译错误问题记录</title>
    <link href="https://fleschier.github.io/2019/03/05/vscode-python/"/>
    <id>https://fleschier.github.io/2019/03/05/vscode-python/</id>
    <published>2019-03-05T13:43:00.000Z</published>
    <updated>2019-03-05T14:30:18.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><hr><ul><li><p>在Vscode上装完python环境后,在按F5运行后却报错了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ImportError: No module named &apos;_tkinter&apos;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>python版本为3.6, pip版本为18</p></li><li><p>查阅了网上相关资料后发现是缺少包的原因,在终端中手动下载一下即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-tk</span><br></pre></td></tr></table></figure></li><li><p>然后再运行python程序即可.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在Vscode上装完python环境后,在按F5运行后却报错了:&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑Python" scheme="https://fleschier.github.io/tags/%E0%B9%91Python/"/>
    
      <category term="๑VsCode" scheme="https://fleschier.github.io/tags/%E0%B9%91VsCode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo插件live2d删除以及遇到的一些问题</title>
    <link href="https://fleschier.github.io/2019/02/17/hexo-live2d-delete/"/>
    <id>https://fleschier.github.io/2019/02/17/hexo-live2d-delete/</id>
    <published>2019-02-17T12:47:00.000Z</published>
    <updated>2019-02-17T11:12:08.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除live2d插件"><a href="#删除live2d插件" class="headerlink" title="删除live2d插件"></a>删除live2d插件</h2><hr><ul><li><p>之前由于兴趣以及探索欲安装了live2d插件,但是在使用过程中不知道如何替换模型,也不是很懂怎么自己DIY模型,于是便放弃了这一插件.</p></li><li><p>首先删除<code>\themes\next\layout</code>下<code>_layout.swig</code>文件内的与live2d有关的代码</p></li><li><p>然后使用<code>npm uninstall hexo-helper-live2d</code>来删除这一momdule.</p></li></ul><h2 id="然而事情并没有结束"><a href="#然而事情并没有结束" class="headerlink" title="然而事情并没有结束"></a>然而事情并没有结束</h2><hr><ul><li><p>本以为这个事情就这样搞定了,直到最近我又<code>npm install</code>了一个插件,然后<code>npm audit fix</code>了一下,结果这个module就像幽灵一样又出现了!WTF?!</p></li><li><p>本着研究学习的想法捣鼓了半天也没用,只能按照原先删除的步骤再删除一遍</p></li><li><p>不过或许是<code>npm audit fix</code>这条命令的问题,查了一下:</p><blockquote><p>npm audit ： <a href="mailto:npm@5.10.0" target="_blank" rel="noopener">npm@5.10.0</a> &amp; npm@6，允许开发人员分析复杂的代码，并查明特定的漏洞和缺陷。<br>npm audit fix ：<a href="mailto:npm@6.1.0" target="_blank" rel="noopener">npm@6.1.0</a>,  检测项目依赖中的漏洞并自动安装需要更新的有漏洞的依赖，而不必再自己进行跟踪和修复。</p></blockquote></li><li><p>官方还提供了其他的一些命令,比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)运行audit fix，但是只更新pkglock， 不更新node_modules：</span><br><span class="line">$ npm audit fix --package-lock-only</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(2)只更新dependencies中安装的包，跳过devDependencies中的包：</span><br><span class="line">$ npm audit fix --only=prod</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行命令，得到audit fix将会更新的内容，并且输出json格式的安装信息，但是并不真的安装更新：</span><br><span class="line">$ npm audit fix --dry-run --json</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">得到json格式的详细检测报告</span><br><span class="line">$ npm audit --json</span><br></pre></td></tr></table></figure><ul><li>特此记录.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;删除live2d插件&quot;&gt;&lt;a href=&quot;#删除live2d插件&quot; class=&quot;headerlink&quot; title=&quot;删除live2d插件&quot;&gt;&lt;/a&gt;删除live2d插件&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;之前由于兴趣以及探索欲安装了live2d插件,但
      
    
    </summary>
    
      <category term="Personal Blog" scheme="https://fleschier.github.io/categories/Personal-Blog/"/>
    
    
      <category term="๑Blog" scheme="https://fleschier.github.io/tags/%E0%B9%91Blog/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 对象部分 </title>
    <link href="https://fleschier.github.io/2019/01/15/JS-learning-03/"/>
    <id>https://fleschier.github.io/2019/01/15/JS-learning-03/</id>
    <published>2019-01-15T03:46:00.000Z</published>
    <updated>2019-01-16T15:42:15.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><hr><ul><li><p><img src="/images/JavaScript/model.png" alt></p></li><li><p>window对象处于对象链的顶端,因为它是Web浏览器中查看所有内容的主要容器. <strong>只要打开浏览器,即使窗口没有加载文档,window对象也在内存的当前模型中定义好了</strong></p></li><li><p>除了文档所在的窗口内容外,窗口的影响范围还包括窗口的尺寸和包围内容区域的所有”元素”.滚动条,工具栏和菜单栏所在的区域叫做窗口的窗框.不是每个浏览器都可以完全控制浏览器主窗口的窗框,但可以便捷地创建其他窗口,随意地设置其大小,指定要显示的窗框元素.</p></li><li><p>每个框架都可以看做一个window对象,因为每个框架都可以存放不同的文档.脚本在其中一个文档上运行时,它把拥有这个文档的框架作为对象层次结构图中的window对象.</p></li></ul><h3 id="访问窗口的属性和方法"><a href="#访问窗口的属性和方法" class="headerlink" title="访问窗口的属性和方法"></a>访问窗口的属性和方法</h3><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.propertyName</span><br><span class="line">window.methodName([Parameters])</span><br></pre></td></tr></table></figure></li></ul><p>在脚本引用指向包含文档的窗口时,window对象有一个同义词self,以上的引用也等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.propertyName</span><br><span class="line">self.methodName([Parameters])</span><br></pre></td></tr></table></figure></p><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><ul><li><p>脚本并不创建主浏览器窗口,用户在创建主窗口的时候需要启动浏览器.但是在主窗口打开后,脚本就可以生成大量子窗口.</p></li><li><p>生成新窗口的方法是:<code>window.open()</code>.这个方法最多包含三个参数,来定义窗口属性.</p></li><li><p>例子:<code>var subWindow = window.open(&quot;define.html&quot;,&quot;def&quot;,&quot;height=200,width=300&quot;);</code><br>这个语句将新建的窗口赋值给了变量subWindow.(<strong>这个语句打开了一个具有指定大小的新窗口,这个窗口包含的html文档为define.html,并且与当前页面处于同一个服务器目录下</strong>)</p></li><li><p>如果要关闭此子窗口,则调用<code>subWindow.close()</code>即可.而调用<code>window.close()/self.close()或者close()</code>就会关闭主窗口.</p></li></ul><h3 id="window对象的属性和方法"><a href="#window对象的属性和方法" class="headerlink" title="window对象的属性和方法"></a>window对象的属性和方法</h3><h4 id="window-alert-方法"><a href="#window-alert-方法" class="headerlink" title="window.alert()方法"></a>window.alert()方法</h4><ul><li>可以直接使用<code>alert()</code>来调用这个方法(省略前面的window).这个window方法会生产一个对话框,显示作为参数传送的文本.OK按钮允许用户关闭这个对话框.</li></ul><h4 id="window-confirm-方法"><a href="#window-confirm-方法" class="headerlink" title="window.confirm()方法"></a>window.confirm()方法</h4><ul><li><p>这个方法也是弹出一个对话框,但是有两个按钮(大多数平台上为Ok和Cancel),称为确认对话框.<strong>更重要的是,这个方法有返回值:单击OK返回值为true,单击Cancel返回值为false</strong>. 可以将这个方法的计算值作为if或if..else结构中的条件语句.</p></li><li><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (confirm(&quot;Are you sure to start over?&quot;))&#123;</span><br><span class="line">  location.href = &quot;index.html&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="window-prompt-方法"><a href="#window-prompt-方法" class="headerlink" title="window.prompt()方法"></a>window.prompt()方法</h4><ul><li><p>window对象的最后一种对话框是提示对话框,它显示了预置的信息,并提供一个文本域供用户输入响应.这个对话框有两个按钮:OK和Cancel.</p></li><li><p>window.prompt()方法有两个参数,第一个参数是呈现给用户的提示信息;第二个参数是一个字符串,它在文本域中显示为默认的答案.如果不希望显示默认答案就传入一个空字符串(空双引号).</p></li><li><p>用户单击按钮时,这个方法就会返回一个值.不管用户在文本域中输入什么,单击Cancel按钮都会返回null值,单击OK则返回输入的字符串值.这个信息也可以用在判断中,<code>null值等同于false,空字符串也看做false</code>.</p></li></ul><h4 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h4><ul><li><p>window对象会响应几个系统和用户事件,最常见的是页面加载完毕时触发的事件.<strong>这个事件等待图像, Java applet和插件程序的数据文件完全下载到浏览器中</strong>.使用load事件调用函数的优点在于,它确保所有document对象都存在于浏览器的DOM中.</p></li><li><p>可以通过如下方式调用onload方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;load&apos;, functionName, false);</span><br><span class="line">window.attachEvent(&apos;onload&apos;, functionName);</span><br><span class="line">//其中functionName是页面下载完成后要运行的函数的名称.可以多次调用addEventListener和attachEvent,把多个函数添加到页面加载完毕要执行的列表中.</span><br></pre></td></tr></table></figure></li><li><p>还可以把该事件直接应用于元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window[&apos;onload&apos;] = functionName;</span><br><span class="line">window.onload = functionName;</span><br></pre></td></tr></table></figure></li></ul><p>但是这种用法表示,页面加载完毕后,只执行一个函数,并替代已赋予window对象的其他事件处理程序.</p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><hr><ul><li><p>这个对象表示载入窗口的URL.它和document对象不同:文档是页面的内容,而位置是页面的URL.</p></li><li><p>脚本大多数只使用该对象的一个属性:<code>href</code>,它定义了完整的URL.</p></li><li><p>如果要加载的页面在另一个窗口或框架中,就必须在语句中包含窗口的引用.例如:用脚本打开一个新窗口,并将它的引用赋值给变量newWindow,将页面载入子窗口,如下:<br><code>newWindow.loaction.href = &quot;http://www.example.com&quot;</code></p></li></ul><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><hr><ul><li>navigator.userAgent属性返回一个包含浏览器和操作系统的诸多细节的字符串.</li></ul><h2 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h2><hr><h3 id="document-getElementById-方法"><a href="#document-getElementById-方法" class="headerlink" title="document.getElementById()方法"></a>document.getElementById()方法</h3><ul><li><p>此方法的唯一参数是带引号的字符串,该字符串包含要引用的元素的ID.</p></li><li><p>例子:<code>var oneTable = document.getElementById(&#39;salesResults&#39;);</code>.在赋值语句后,变量就表示对象,可用于获取和设置该对象的属性,或者调用此类对象的方法.</p></li></ul><h3 id="document-getElementByTagName-方法"><a href="#document-getElementByTagName-方法" class="headerlink" title="document.getElementByTagName()方法"></a>document.getElementByTagName()方法</h3><ul><li><p>可以使用getElementByTagName()方法方便地收集一组共享同一个标记名称的页面元素.例如,要获得页面上所有的图像:<code>var aImages = document.getElementByTagName(&#39;img&#39;);</code></p></li><li><p>然后可以通过数组的方法来获取数组的长度:<code>aImages.length</code>,然后每个对象就可以使用数组的偏移量来访问.</p></li></ul><h3 id="document-forms-属性"><a href="#document-forms-属性" class="headerlink" title="document.forms[]属性"></a>document.forms[]属性</h3><ul><li>比较下面两个表达式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var aForms = document.forms;</span><br><span class="line">var aForms = document.getElementByTagName(&apos;form&apos;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>一个重要的区别是,document.forms集合允许按名称直接引用某个表单,而不仅仅是按照数组的偏移量来访问.</strong></p><ul><li><p>因为有些时候按照下标号引用表单未必可行.动态网页可能根据上下文包含数量可变的表单,所以表单在页面上的位置可能随上下文而变化.</p></li><li><p>支持脚本编程的浏览器允许通过表单名或ID(即分配给<code>&lt;form&gt;标记的name或者id属性</code>)更直接地引用表单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&apos;formId&apos; name=&apos;fromName&apos; ...&gt;</span><br><span class="line"></span><br><span class="line">//第一种方法是使用getElementById方法:</span><br><span class="line">document.getElementById(&quot;formId&quot;)</span><br><span class="line"></span><br><span class="line">//第二种方法是使用数组语法,将表单名称或者ID作为数组的字符串下标:</span><br><span class="line">document.forms[&quot;formId&quot;]</span><br><span class="line">document.forms[&quot;formName&quot;]</span><br><span class="line"></span><br><span class="line">//第三种按名称引用form对象的简短方式是把表单的名称附加为document对象的属性:</span><br><span class="line">document.fornName</span><br></pre></td></tr></table></figure></li></ul><h3 id="document-images-属性"><a href="#document-images-属性" class="headerlink" title="document.images[]属性"></a>document.images[]属性</h3><ul><li>文档利用特殊的数组属性来跟踪表单,同样,document对象也通过<code>&lt;img&gt;</code>标记保存插入文档的图像集合(数组).通过document.images数组引用的图像可以用img元素名称中的数字或字符串下标来得到.</li></ul><h3 id="document-createElement-和document-createTextNode-方法"><a href="#document-createElement-和document-createTextNode-方法" class="headerlink" title="document.createElement()和document.createTextNode()方法"></a>document.createElement()和document.createTextNode()方法</h3><ul><li>在HTML文档中添加新元素至少需要两个步骤:</li></ul><ol><li>为文档创建新元素.</li><li>在页面的树形结构中,将其插入到需要的位置.</li></ol><ul><li><p>document.createElement()方法可以在浏览器的内存中创建一个全新的元素对象.指定要创建的元素时,应将元素的标记名作为该方法的字符串参数:<br><code>var newEle, = document.createElement(&quot;p&quot;);</code></p></li><li><p>还可以给元素添加一些属性值,为此应在元素成为文档的一部分之前,向新建对象赋值:<code>newElem.setAttribute(&quot;class&quot;,&quot;intro&quot;);</code></p></li><li><p>可将这个元素插入文档中的任何位置,例如末尾:<br><code>document.body.appendChild(newElem);</code></p></li></ul><h3 id="document-write-方法"><a href="#document-write-方法" class="headerlink" title="document.write()方法"></a>document.write()方法</h3><ul><li>document.write()方法是给文档写入内容的另一种方式.他的优点是可以临时应急,缺点如下:</li></ul><ol><li>只有页面第一次加载到浏览器中时,document.write()才能给一个网页添加内容.以后调用该方法都会替代整个页面.</li><li>document.write()会将旧文本块插入文档,编写出草率的程序和错误的标记,将标记与脚本内容混合在一起,不利于开发的分层.</li><li>document.write()不能用于XHTML,XHTML这种文档类型不允许第一次解析期间修改其内容.</li></ol><blockquote><p>注:XHTML—可扩展超文本标记语言（英语：eXtensible HyperText Markup Language，XHTML），是一种标记语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。从继承关系上讲，HTML是一种基于标准通用标记语言（SGML）的应用，是一种非常灵活的置标语言，而XHTML则基于可扩展标记语言（XML），XML是SGML的一个子集。XHTML 1.0在2000年1月26日成为W3C的推荐标准。</p></blockquote><h2 id="表单和表单元素"><a href="#表单和表单元素" class="headerlink" title="表单和表单元素"></a>表单和表单元素</h2><hr><h3 id="form对象"><a href="#form对象" class="headerlink" title="form对象"></a>form对象</h3><ul><li>表单以及其中的输入控件是DOM对象,其独特的属性是文档中其他对象所没有的.例如,表单对象的action属性告诉浏览器,在提价表单时,将输入的值发送到什么地方.select控件(下拉列表)的selectedIndex属性指出用户选择了哪个选项.</li></ul><h4 id="访问表单属性"><a href="#访问表单属性" class="headerlink" title="访问表单属性"></a>访问表单属性</h4><ul><li><p>在创建表单时,可以使用HTML页面中的标准标记,也可以使用JavaScript中的DOM方法.无论采用哪种方法,都可以设置name,target,action,method和enctype特性.这些都是form对象的属性.</p></li><li><p>用法的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var sURL = document.getElementById(&apos;formName&apos;).action;</span><br><span class="line">document.forms[0].action = &quot;http://www.example.com/cgi/login.pl&quot;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="from-elements-属性"><a href="#from-elements-属性" class="headerlink" title="from.elements[]属性"></a>from.elements[]属性</h4><ul><li><p>elements[]属性是表单中所有输入控件的集合.这个数组中各项的顺序根据HTML标记在源代码中的顺序而定.使用ID直接引用单个元素通常更有效,但有时候需要遍历所有元素时会需要这样访问.</p></li><li><p>下面的代码段查看表单中所有的控件元素,并将文本域的内容设置为空字符串.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var oForm = document.getElementById(&apos;registration-form&apos;);</span><br><span class="line">  if(!oForm) return false;</span><br><span class="line">for(var i = 0; i &lt; oForm.elements.length; i++)&#123;</span><br><span class="line">  if(oForm.elements[i].type == &quot;text&quot;)&#123;</span><br><span class="line">    oForm.elements[i].values = &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="将表单控件作为对象"><a href="#将表单控件作为对象" class="headerlink" title="将表单控件作为对象"></a>将表单控件作为对象</h3><ul><li><p>在所有浏览器的DOM中,嵌套在<code>&lt;form&gt;</code>标记中的HTML元素有三种是脚本对象.多数对象都在页面源代码的<code>&lt;input&gt;</code>标记中,只有赋给<code>&lt;input&gt;</code>标记的type特性的值能确定元素是文本框,密码输入域,隐藏域,按钮,复选框还是单选框.其他两种表单控件textarea和select有各自的标记.</p></li><li><p>要将某个表单控件作为对象进行引用,可以使用其id或tagName直接引用,或者使用DOM level 0语法,将引用构造为一个以document开头,后跟form和控件的层次结构.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(controlName)</span><br><span class="line">或者</span><br><span class="line">document.formName.controlName</span><br></pre></td></tr></table></figure></li><li><p>例如有个简单的表单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;searchForm&quot; action=&quot;cgi-bin/search.pl&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;entry&quot; name=&quot;entry&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; id=&quot;sender&quot; name=&quot;sender&quot; value=&quot;Search&quot;&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">```CPU</span><br><span class="line">对于文本输入控件,以下引用实例都是有效的:</span><br></pre></td></tr></table></figure></li></ul><p>document.getElementById(“entry”)<br>document.searchForm.entry<br>document.searchForm.elements[0]qitak<br>document.forms[“searchForm”].elements[“entry”]<br>document.forms[“searchForm”].entry<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;window对象&quot;&gt;&lt;a href=&quot;#window对象&quot; class=&quot;headerlink&quot; title=&quot;window对象&quot;&gt;&lt;/a&gt;window对象&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;img src=&quot;/images/JavaScript/mod
      
    
    </summary>
    
      <category term="Computer Software" scheme="https://fleschier.github.io/categories/Computer-Software/"/>
    
    
      <category term="๑FrontEnd" scheme="https://fleschier.github.io/tags/%E0%B9%91FrontEnd/"/>
    
      <category term="๑JS" scheme="https://fleschier.github.io/tags/%E0%B9%91JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础 </title>
    <link href="https://fleschier.github.io/2019/01/13/JS-learning-02/"/>
    <id>https://fleschier.github.io/2019/01/13/JS-learning-02/</id>
    <published>2019-01-13T08:46:00.000Z</published>
    <updated>2019-01-15T03:29:06.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器窗口中的DOM"><a href="#浏览器窗口中的DOM" class="headerlink" title="浏览器窗口中的DOM"></a>浏览器窗口中的DOM</h2><hr><ul><li>所有现代浏览器的基本对象模型:<br><img src="/images/JavaScript/model.png" alt></li></ul><ol><li><p>window对象: 在层次结构顶部的是window对象.这个对象代表显示HTML文档的浏览器窗口的内容区域.在多框架环境下,每个框架也是一个窗口.所有的文档动作都是在窗口内发生的,所以窗口是对象层次结构中最外部的元素,它包含文档.</p></li><li><p>navigator对象: 脚本从这个对象开始访问浏览器程序,主要是读取浏览器的品牌和版本.此对象为只读,以禁止流氓脚本对浏览器的不当操作.但如后面所述,不能依赖navigator对象获得当前浏览器的实际品牌,型号和版本.</p></li><li><p>screen对象: 这是另一个只读对象,它给脚本提供了运行浏览器的物理环境信息.例如,此对象显示了监视器的高度和宽度(像素值).</p></li><li><p>history对象: 尽管浏览器保留了最近浏览历史的内部细节(如单击后退显示的内容列表),但是脚本却无权访问这些细节.这一对象可以帮助脚本模拟后退或前进按钮的单击.</p></li><li><p>document对象: 每个载入窗口的HTML文档都会变成一个document对象.document对象包含脚本中的内容.除了每个HTML文档中都有的html,head和body元素对象外,文档中元素对象层次的具体标记和结构取决于文档的内容.</p></li></ol><h2 id="文档的载入"><a href="#文档的载入" class="headerlink" title="文档的载入"></a>文档的载入</h2><hr><h3 id="简单文档"><a href="#简单文档" class="headerlink" title="简单文档"></a>简单文档</h3><ul><li>空文档的对象映射:<br><img src="/images/JavaScript/document.png" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta ...&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  ...</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="添加段落"><a href="#添加段落" class="headerlink" title="添加段落"></a>添加段落</h3><ul><li>添加段落标签, 在段落元素的开始和结束标记之间插入段落文本.在标记间插入的连续文本是DOM中的一种特殊的对象,称为文本结点.文本节点总是有一个容器元素,也就是说,文本结点是其父元素p的子元素.</li></ul><p><img src="/images/JavaScript/document1.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta ...&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;p&gt;This is the one and only Paragraph&lt;/p&gt;         //添加了段落标签和段落内容</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="生成新元素"><a href="#生成新元素" class="headerlink" title="生成新元素"></a>生成新元素</h3><ul><li>将部分段落文本包含在一个<em>标签中,表示要强调这些文本.这个插入操作对p元素对象的层次结构有很大的影响.<strong>p元素从只有一个(文本结点)子元素变成有三个子元素:两个文本节点,和一个它们之间的元素</strong>. 在W3C DOM中, <strong>文本结点不能有任何子元素</strong>,因此不能包含元素对象.em元素中的文本结点不再是p元素的子元素,而是em元素的子元素.</em></li></ul><p><img src="/images/JavaScript/document2.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta ...&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;p&gt;This is the one and only Paragraph&lt;/p&gt;         //添加了段落标签和段落内容</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><hr><h3 id="获取对象的属性"><a href="#获取对象的属性" class="headerlink" title="获取对象的属性"></a>获取对象的属性</h3><ul><li>例如,下面的HTML标记定义了一个input元素对象,它指定了四个属性和属性值:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; id=&quot;clicker&quot; name=&quot;clicker&quot; value=&quot;...&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><p>不必为每个对象设置每个属性,多数属性都有默认值.假如HTML或脚本没有特殊要求,他们就自动设置为默认值.</p><ul><li><p>为了访问对象的属性,需要使用和前面对象相同的圆点定位方式.属性是从属于对象的资源,所以属性的引用就是对象引用后加属性名.</p></li><li><p>对于刚才的例子,属性的引用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;clicker&quot;).name</span><br><span class="line">document.getElementById(&quot;clicker&quot;).value</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果JavaScript尝试引用不存在的元素的属性,就会失败或终止.因此引用之前最好先测试一下.</p></blockquote><ul><li><p>测试引用是否安全:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val oClicker = document.getElementById(&quot;clikcker&quot;);</span><br><span class="line">  if(!oClicker) return;</span><br><span class="line">var sName = oClicker.name;</span><br></pre></td></tr></table></figure></li><li><p>在引用的过程中我们省略<code>window</code>部分(<em>完整为window.document.XXX</em>).因为一个窗口只能包含一个文档,所以文档中对象的引用可以省略window部分,但是不能省略document对象.</p></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><hr><ul><li><p>方法的调用与大多数语言一样,需要在方法名后加一对圆括号.</p></li><li><p>参数之间以逗号间隔</p></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><hr><ul><li><p>事件是文档执行中的动作,通常是用户活动的结果.</p></li><li><p>文档中的每个DOM对象几乎都接收某种类型的事件.我们只需要编写代码,告诉元素对象,只要接收到某种事件,就执行一个动作.这个动作就是执行其他的一些JavaScript代码.</p></li><li><p>具有事件处理能力的简单按钮:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//HTML: 1.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;</span><br><span class="line">    &lt;title&gt;A Simple Button with an Event Handler&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;jab.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button id=&quot;clicker&quot;&gt;Click here&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//JAVASCRIPT:jsb.js</span><br><span class="line">//tell the browser to run this script when the page has finished loading</span><br><span class="line">window.onload = applyBehavior;</span><br><span class="line"></span><br><span class="line">//apply behavior to the button</span><br><span class="line">function applyBehavior()&#123;</span><br><span class="line">  //ensure a DOM-aware user agent</span><br><span class="line">  if(document.getElementById)&#123;</span><br><span class="line">    //point to the button</span><br><span class="line">    var oButton = document.getElementById(&apos;clicker&apos;);</span><br><span class="line"></span><br><span class="line">    //if it exists, apply behavior</span><br><span class="line">    if(oButton)&#123;</span><br><span class="line">      oButton.onclick = behave;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//what to do when the button is clicked</span><br><span class="line">function behave(evt)&#123;</span><br><span class="line">  alert(&apos;Ouch! &apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>事件的名称一般为事件的类型(例如click)以及前缀on构成,表示一接收到XXX事件就XXX.</li></ul><h2 id="把脚本链接到文档上"><a href="#把脚本链接到文档上" class="headerlink" title="把脚本链接到文档上"></a>把脚本链接到文档上</h2><hr><ol><li><p>放在外部文件中:<code>&lt;script type=&quot;text/javascript&quot; src=&quot;[/..../]example.js&quot;&gt;&lt;/script&gt;</code></p></li><li><p>内嵌在html中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  JavaScript code here</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="script标记的位置"><a href="#script标记的位置" class="headerlink" title="script标记的位置"></a>script标记的位置</h3><ul><li><p>大多数情况下script标记放在<code>&lt;head&gt;</code>标签中,有时候会放在<code>&lt;body&gt;</code>标签.</p></li><li><p>放在<code>&lt;head&gt;</code>中的标记一般会影响页面中的非内容设置—所谓的html指令元素,例如<code>&lt;meta&gt;</code>标记和文档题目,这里也适合放置响应页面载入或用户动作的脚本.</p></li><li><p>如果需要在页面载入时运行脚本,以便生成页面内容,则脚本应放在文档的<code>&lt;body&gt;</code>部分</p></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释用<code>//</code>,多行注释用<code>/**/</code></li></ul><h2 id="脚本语句的执行时间"><a href="#脚本语句的执行时间" class="headerlink" title="脚本语句的执行时间"></a>脚本语句的执行时间</h2><hr><ul><li>根据脚本要完成的功能,脚本运行的时间有四种选择:</li></ul><ol><li>文档载入时</li><li>文档载入后</li><li>响应用户动作时</li><li>其他脚本语句调用时</li></ol><ul><li><p>决定性因素是脚本语句在文档中的位置.</p></li><li><p>除了第一个,其他三种统称为延时脚本</p></li></ul><h3 id="页面载入后执行"><a href="#页面载入后执行" class="headerlink" title="页面载入后执行"></a>页面载入后执行</h3><ul><li>假设定义了函数<code>function done(){alert(&quot;....&quot;)}</code>,则如果想要在页面加载完成是调用它,可以用<code>window.onload = done;</code>来实现在页面加载完成时调用<code>done</code>函数. <strong>注意此语句右侧只有函数名,没有圆括号.</strong></li></ul><h2 id="JavaScript值-数据-类型"><a href="#JavaScript值-数据-类型" class="headerlink" title="JavaScript值(数据)类型"></a>JavaScript值(数据)类型</h2><hr><table><thead><tr><th>类型</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>String</td><td>“Test”</td><td>引号内的一系列字符</td></tr><tr><td>Number</td><td>4.5</td><td>不在引号内的数字</td></tr><tr><td>Boolean</td><td>false</td><td>逻辑真或假</td></tr><tr><td>Null</td><td>null</td><td>不包含任何内容,但仍然是一个值</td></tr><tr><td>Object</td><td></td><td>通过属性和方法定义的软件对象(数组也是对象)</td></tr><tr><td>Function</td><td></td><td>函数定义</td></tr></tbody></table><ul><li>假如用户在表单的文本的输入域中输入数字,浏览器就把该数字存储为字符串类型.假如脚本要对这个数字执行算数操作,就需要将字符串转化为数字再进行操作.</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr><ul><li><p>创建变量:<code>var valueName;</code>  <code>var</code>关键字用于声明和初始化变量,文档中任何变量都只需要使用一次var关键字.</p></li><li><p>变量赋值:<code>valueName = 45;</code></p></li><li><p><strong>JavaScript变量可以存储任何类型的值</strong>.在声明变量的时候,不必定义变量包含的值的类型.</p></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>两个数值相加:<code>3 + 3</code>,结果为6没有问题.</p></li><li><p>但如果其中一个数字是字符串,JavaScript就会将另一个值转换为字符串,<strong>将这个加号操作从算数加变成字符串连接</strong>:<code>3 + &quot;3&quot;</code>,结果为<code>&quot;33&quot;</code>. <code>3 + 3 + &quot;3&quot;</code>,结果为<code>&quot;63&quot;</code>.</p></li></ul><h4 id="将字符串转化为数值"><a href="#将字符串转化为数值" class="headerlink" title="将字符串转化为数值"></a>将字符串转化为数值</h4><ul><li><p>JavaScript提供了两个内置函数:<code>parseInt()</code>和<code>parseFloat()</code></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;43&quot;)    //结果为42  </span><br><span class="line">parseInt(&quot;43.33&quot;) //结果为43,这里做截断处理</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&quot;43&quot;)  //结果为43</span><br><span class="line">parseFloat(&quot;43.33&quot;)  //结果为43.33</span><br></pre></td></tr></table></figure></li></ul><h4 id="将数字转化为字符串"><a href="#将数字转化为字符串" class="headerlink" title="将数字转化为字符串"></a>将数字转化为字符串</h4><ul><li>利用JavaScript的特性:<code>&quot;&quot;+2500</code>,结果即为<code>&quot;2500&quot;</code></li></ul><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><hr><ul><li><p>if else与C++等用法一致</p></li><li><p>for循环(i用var声明,其余与C++一致):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = startValue; i &lt;= MaxValue; i++)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><hr><ul><li>函数的正式语法结构:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">functoin functionName([Parameter1]...[,ParameterN])&#123;</span><br><span class="line">  statement[s]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><ul><li><p>在函数外声明的变量为全局变量,在函数体中定义的变量称为局部变量.</p></li><li><p>局部变量的作用域只局限于函数内部.</p></li><li><p>全局变量的作用域是 <strong>当前载入浏览器窗口或框架的文档</strong>.因此初始全局变量后,页面中所有的脚本语句可通过全局变量名直接访问其值.但是,一旦卸载页面,在页面中定义的所有全局变量都会从内存中清除.假如某个值需要在页面卸载后继续使用,则需要使用其他技术来保存它,比如将它存储为框架集文档中的全局变量,或将它存储在cookie中.</p></li><li><p>如果用<code>var</code>关键字在函数体中初始化了一个与全局变量同名的局部变量,则在函数体中该局部变量比全局变量优先级要高.</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><hr><ul><li><p>创建:<code>var Arr = new Array(100);</code></p></li><li><p>访问:<code>Array[0];</code></p></li></ul><h3 id="数组中的document对象"><a href="#数组中的document对象" class="headerlink" title="数组中的document对象"></a>数组中的document对象</h3><ul><li><p>例如,如果页面包含两个<code>&lt;form&gt;</code>标记对时,在文档中就会出现两组<code>&lt;form&gt;</code>标记.浏览器为文档使用一个from对象数组,对这些表单的引用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.forms[0]</span><br><span class="line">document.forms[1]</span><br></pre></td></tr></table></figure></li><li><p>也可以使用DOM方法<code>getElementByTagName()</code>访问这个数组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var aForms = document.getElementByTagName(&apos;form&apos;);</span><br><span class="line">aForms[0]</span><br><span class="line">aForms[1]</span><br></pre></td></tr></table></figure></li><li><p>document对象的下标是由对象的载入顺序决定的,form对象的顺序由文档中<code>&lt;form&gt;</code>标记出现的顺序确定.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浏览器窗口中的DOM&quot;&gt;&lt;a href=&quot;#浏览器窗口中的DOM&quot; class=&quot;headerlink&quot; title=&quot;浏览器窗口中的DOM&quot;&gt;&lt;/a&gt;浏览器窗口中的DOM&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;所有现代浏览器的基本对象模型:&lt;br&gt;&lt;img src
      
    
    </summary>
    
      <category term="Computer Software" scheme="https://fleschier.github.io/categories/Computer-Software/"/>
    
    
      <category term="๑FrontEnd" scheme="https://fleschier.github.io/tags/%E0%B9%91FrontEnd/"/>
    
      <category term="๑JS" scheme="https://fleschier.github.io/tags/%E0%B9%91JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 入门</title>
    <link href="https://fleschier.github.io/2019/01/12/JS-learning-01/"/>
    <id>https://fleschier.github.io/2019/01/12/JS-learning-01/</id>
    <published>2019-01-12T09:46:00.000Z</published>
    <updated>2019-01-15T03:29:18.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//tell the browser to run this script when the page has finished loading</span><br><span class="line">window.onload = insertDateTime;</span><br><span class="line"></span><br><span class="line">//insert the data &amp; time</span><br><span class="line">function insertDateTime()&#123;</span><br><span class="line">  //ensure a DOM-aware user agent</span><br><span class="line">  if(!document.getElementById) return;</span><br><span class="line">  if(!document.createTextNode) return;</span><br><span class="line"></span><br><span class="line">  //create a date-time object</span><br><span class="line">  var oNow = new Data();</span><br><span class="line"></span><br><span class="line">  //get the current date &amp; time as a string</span><br><span class="line">  var sDateTime = oNow.toLocaleString();</span><br><span class="line"></span><br><span class="line">  //point to the target element where we want to insert the date &amp; time</span><br><span class="line">  var oTarget = document.getElementById(&apos;output&apos;);</span><br><span class="line">  //make sure the target is found</span><br><span class="line">  if(!oTarget) return;</span><br><span class="line"></span><br><span class="line">  //delete everything inside the target</span><br><span class="line">  while(oTarget.firstChild)&#123;</span><br><span class="line">    oTarget.removeChild(oTarget.firstChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //use the date-time string to create a new text node for the page</span><br><span class="line">  var oNewText = document.createTextNode(sDateTime);</span><br><span class="line"></span><br><span class="line">  //insert the mew text into the span</span><br><span class="line">  oTarget.appendChild(oNewText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h4 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h4><ul><li><p>脚本要把日期和事件插入到页面的段落中,但浏览器在读取和运行JavaScript代码之前,并没有读取HTML体.在JavaScript开始运行时,要插入新内容的段落甚至在浏览器的内存中不存在.</p></li><li><p>解决办法就是告诉JavaScript,在文档完全读入内存之前,不要执行插入操作.为此使用了<code>onload</code>事件.页面的元素(<em>在DOM中称为对象</em>)可以感知很多事件,例如 <em>鼠标单击或按下一个键.</em> 文档加载到浏览器中后,就会触发window对象的<code>onload</code>事件.</p></li><li><p><code>window.onload = insertDateTime;</code>告诉JavaScript,文档加载完毕后调用<code>insertDateTime()</code>函数.</p></li></ul><h4 id="确保一个安全的环境"><a href="#确保一个安全的环境" class="headerlink" title="确保一个安全的环境"></a>确保一个安全的环境</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//ensure a DOM-aware user agent</span><br><span class="line">if(!document.getElementById) return;</span><br><span class="line">if(!document.createTextNode) return;</span><br></pre></td></tr></table></figure></li></ul><p>这里调用的<code>getElementById()</code>和<code>createTextNode()</code>是两个某些旧的JavaScript解释器不能理解的DOM方法.感叹号<code>!</code>表示”not”,<code>return</code>告诉JavaScript停止运行当前的函数. 如果不包含这些保护措施,某些老式的浏览器或其JavaScript解释器就会在运行其后代码的时候崩溃.</p><h4 id="生成日期和时间"><a href="#生成日期和时间" class="headerlink" title="生成日期和时间"></a>生成日期和时间</h4><ul><li>要插入这个文档中的文本是当前的日期和时间.JavaScript很容易完成这个插入操作:创建一个Date对象,并使用它的一个方法生成字符串:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//create a date-time object</span><br><span class="line">var oNow = new Date()</span><br><span class="line">//get the current date &amp; time as a string</span><br><span class="line">var sDateTime = oNow.toLocaleString();</span><br></pre></td></tr></table></figure></li></ul><p>这些代码把oNow变量设置为一个新的Date对象.之后使用其toLocaleString()方法输出一个文本字符串,它包含:<code>Thrusday, August 20, 2009 4:16:05 PM</code></p><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><ul><li>下一步就是把日期和事件插入文档中需要的位置.执行了以下操作:</li></ul><ol><li>指向目标<code>span</code>元素</li><li>删除该文本中已有的文本</li><li>在元素中插入新的文本</li></ol><ul><li><p>为了指向<code>output span</code>,使用ID的方式来定位:<br><code>var oTarget = document.getElementById(&#39;output&#39;);</code><br>该语句通过ID(ouput)lai定位目标元素,并把该对象的<code>引用</code>存储在oTarget变量中.</p></li><li><p>HTML规范指出,每个元素的ID在当前页面必须是唯一的,即使不小心在页面上使用了相同的ID,<code>getElementById()</code>方法也仅返回第一个ID实例.所以,这个方法仅定位一个元素.(本例中就是span元素)</p></li><li><p>如果<code>getElementById()</code>没有找到对应的ID,则将返回空值.为了避免由于疏忽导致的这类错误,采用<code>if(!oTarget) return;</code>这个测试语句.</p></li><li><p>也可以将这个错误变成警告提示:<code>if(!oTarget) return alert(&quot;Warning: output element not found!&quot;);</code></p></li></ul><h4 id="删除原来的内容"><a href="#删除原来的内容" class="headerlink" title="删除原来的内容"></a>删除原来的内容</h4><ul><li><p>我们要删除span的文本,再插入新内容.在表示页面内容的DOM中,span是其所有子元素的父元素.span现在只有一个子元素:单词”now”.</p></li><li><p>为了删除span的内容,执行一个简单的循环.只要还有要删除的元素,该循环就一次删除一个子元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//delete everything inside the target</span><br><span class="line">while(oTarget.firstChild)&#123;</span><br><span class="line">  oTarget.removeChild(oTarget.firstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在本例中这个循环只会执行一次.</p><h4 id="插入日期和时间"><a href="#插入日期和时间" class="headerlink" title="插入日期和时间"></a>插入日期和时间</h4><ul><li>最后在DOM中创建一个包含所有所需文本的新节点,并插入span:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//use the date-time string to create a new text node for the page</span><br><span class="line">var oNewText = document.createTextNode(sDateTime);</span><br><span class="line"></span><br><span class="line">//insert the new text into the span</span><br><span class="line">oTarget.appendChild(oNewText);</span><br></pre></td></tr></table></figure></li></ul><p>sDateTime是从Date对象中生成的字符串.</p><ul><li>这里调用document对象关联的一个方法,该方法会创建一个新的文本节点,并把日期和事件字符串作为其值.此时该文本结点还不是可见文档内容的一部分,使用目标元素的appendChild()方法就可以插入它.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引例&quot;&gt;&lt;a href=&quot;#引例&quot; class=&quot;headerlink&quot; title=&quot;引例&quot;&gt;&lt;/a&gt;引例&lt;/h2&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="Computer Software" scheme="https://fleschier.github.io/categories/Computer-Software/"/>
    
    
      <category term="๑FrontEnd" scheme="https://fleschier.github.io/tags/%E0%B9%91FrontEnd/"/>
    
      <category term="๑JS" scheme="https://fleschier.github.io/tags/%E0%B9%91JS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-自底向上</title>
    <link href="https://fleschier.github.io/2018/12/24/Internet_protocol/"/>
    <id>https://fleschier.github.io/2018/12/24/Internet_protocol/</id>
    <published>2018-12-24T09:25:00.000Z</published>
    <updated>2019-01-12T09:03:47.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些概念性的名词用 <em>斜体</em> 标出了</p></blockquote><h2 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h2><ul><li><p>计算机网络由若干的结点(node)和连接这些结点的链路(link)组成.结点可以是计算机,集线器,交换机或路由器.</p></li><li><p>网络之间可以通过路由器互连起来,因此互联网是 <em>网络的网络</em>.</p></li><li><p>网络把许多计算机连接在一起,而互联网把很多网络通过路由器连接在一起.与网络相连的计算机通常称为 <em>主机</em>.</p></li><li><p>以小写字母<code>i</code>开始的<code>internet(互连网)</code>是一个通用名词,泛指由多个计算机网络互连而成的计算机网络.</p></li><li><p>以大写字母<code>I</code>开始到<code>Internet(互联网)</code>是一个专有名词,特指采用TCP/IP协议族作为通信规则的互联网.</p></li><li><p>RFC(Request For Comments)就是 “请求评论”</p></li><li><p>主机A和主机B进行通信,更为全面的说法是 <strong>主机A的某个进程和主机B的某个进程进行通信</strong></p></li></ul><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul><li>互联网的拓扑结构非常复杂,从其工作方式上来看分为以下两大块:</li></ul><ol><li>边缘部分: 这部分是<code>用户直接使用的</code>,由所有连接在互联网上的主机构成</li><li>核心部分: 这部分是<code>为边缘部分提供服务的</code>,由大量网络和链接这些网络的路由器组成</li></ol><ul><li>在客户机和服务器之间通信的过程中,服务请求方和服务提供方 <strong>都要使用网络核心部分所提供的服务</strong></li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ul><li>路由器是一种专用计算机,实现 <em>分组交换</em> 的关键部件.其任务就是转发收到的分组.</li></ul><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><ul><li>必须经过<code>建立连接(占用通信资源) -&gt; 通话(一直占用通信资源) -&gt; 释放连接(归还通信资源)</code><br>这三个步骤的交换方式就叫 <em>电路交换</em>.</li></ul><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><ul><li><p>分组交换采用 <em>存储转发</em> 技术.</p></li><li><p>通常把要发送的一整块数据叫做 <em>报文</em>.</p></li><li><p>把较长的报文划分成一个个更小等长的数据段,在每一个数据段的前面,加上一些必要的控制信息组成 <em>首部</em> 后,就构成了一个 <em>分组</em>.(分组又称为<code>包</code>)</p></li><li><p>路由器收到一个分组,先暂时存储一下,检查其首部,查找转发表,按照首部中的目的地址找到合适的端口发送出去,把分组交给下一个路由器.</p></li></ul><h4 id="三种交换方式的比较"><a href="#三种交换方式的比较" class="headerlink" title="三种交换方式的比较"></a>三种交换方式的比较</h4><ol><li><p>电路交换: 整个报文的比特流连续地从源点直达终点,好像在一个管道中传送.</p></li><li><p>报文交换: 整个报文先传送到相邻结点,<strong>全部存储下来后查找转发表</strong>,转发到下一个结点.</p></li><li><p>分组交换: 单个分组(<strong>整个报文的一部分</strong>)传送到相邻的结点,存储下来后查找转发表,转发到下一个结点.</p></li></ol><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><ul><li><p>计算机网络的定义: 计算机网络是有一些通用的,可编程的硬件互联而成的,而这些硬件并非专门用来实现某一特定的目的.</p></li><li><p><code>WAN</code>(Wide Area Network):广域网 <code>MAN</code>(Metropolitan Area Network):城域网 <code>LAN</code>(Local Area Network):局域网  <code>PAN</code>(Personal Area Network):个人局域网</p></li></ul><h3 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a>计算机网络性能</h3><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><ul><li><p>带宽本来是指某个信号具有的<code>频带宽度</code>.信号的带宽是指该信号所包含的各种不同的频率成分所占据的频率 <strong>范围</strong>.例如,传统通信线路上的电话信号的标准带宽是3.1kHz(从300Hz到3.4kHz,这个值代表的是一个 <strong>范围的大小</strong>),这时带宽的单位是<code>Hz</code></p></li><li><p>带宽的另一个表示是网络中某通道传送数据的能力,即传输数据的速度,此时单位是<code>bit/s</code></p></li></ul><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><ul><li>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</li></ul><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><ul><li><p>信道利用率是指某信道有百分之几的时间是被利用的(有数据通过)</p></li><li><p>令<code>D0</code>表示网络空闲时的时延(也就是网络所能达到的最低时延),<code>D</code>表示网络当前的时延,<code>U</code>为网络的利用率,则有:<code>D = D0/(1-U)</code></p></li><li><p>可以看出如果<code>U</code>(利用率)太高则时延会成指数级增长,一般尽量保证网络的利用率不超过50%.</p></li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="OSI的七层协议"><a href="#OSI的七层协议" class="headerlink" title="OSI的七层协议"></a>OSI的七层协议</h4><ul><li>物理层 - 数据链路层 - 网络层- 运输层 - 会话层 - 表示层 - 应用层</li></ul><h4 id="TCP-IP的四层协议"><a href="#TCP-IP的四层协议" class="headerlink" title="TCP/IP的四层协议"></a>TCP/IP的四层协议</h4><ul><li>网络接口层 - 网际层IP - 运输层(TCP或UDP) - 应用层(各种应用层协议如TELNET,FTP,SMTP等)</li></ul><h4 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h4><ul><li>物理层 - 数据链路层 - 网络层 - 运输层 - 应用层</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><hr><h3 id="波特率和比特率"><a href="#波特率和比特率" class="headerlink" title="波特率和比特率"></a>波特率和比特率</h3><ul><li><p>比特率(bit rate)又称传信率、信息传输速率(简称信息速率，information rate)。<code>其定义是：通信线路(或系统)单位时间(每秒)内传输的信息量，即每秒能传输的二进制位数，通常用Rb表示，其单位是比特/秒(bit/s或b/s，英文缩略语为bps)。</code></p></li><li><p>在二进制系统中，信息速率(比特率)与信号速率(波特率)相等，例如，当系统以每秒50个二进制符号传输时，信息速率为50bit/s，信号速率也为50Bd(波特)。在无调制的情况下，比特率等于波特率；采用调相技术时，比特率不等于波特率。通信系统的发送设备和接收设备必须在相同的波特率下工作，否则会出现帧同步错误。</p></li><li><p>波特率(Baud rate)又称传码率、码元传输速率(简称码元速率)、信号传输速率(简称信号速率，signaling rate)或调制速率。<code>其定义是：通信线路(或系统)单位时间(每秒)内传输的码元(脉冲)个数；或者表示信号调制过程中，单位时间内调制信号波形的变换次数，通常用RB表示，单位是波特(Bd或Baud，前者规范)。</code>如果每秒传输1个码元就称为1Bd；如果1码元的时间长短为200ms，则每秒可传输5个码元，那么码元速率(波特率)就是5Bd。</p></li><li><p>波特率(码元速率)并没有限定是何种进制的码元，所以给出波特率时必须说明这个码元的进制。对于M进制码元，比特率(信息速率)Rb与波特率(码元速率)RB的关系式为:<code>Rb=RB·lbM</code>.式中：lbM=log2M，表示M的以2为底的对数。显然，对于二进制码元，由于lb2=1，所以Rb=RB，即波特率与比特率在数值上相等，但单位不同，也即二者代表的意义不同。</p></li><li><p>例如，波特率为600Bd，则在二进制时，比特率也为600bit/s；<strong>在四进制时，由于lb4=2，所以比特率为1200bit/s。可见，在一个码元中可以传送多个比特。</strong></p></li><li><p><strong>可以理解为,比特率在数值上等于二进制编码的波特率</strong>.</p></li></ul><h3 id="信道极限容量-amp-香农公式"><a href="#信道极限容量-amp-香农公式" class="headerlink" title="信道极限容量&amp;香农公式"></a>信道极限容量&amp;香农公式</h3><ul><li><p>码元的传输速率越高,或者信号传输距离越远,或噪声干扰越大,或传输媒体质量越差,在接收端的波形失真越严重.</p></li><li><p>限制码元在信道上传输速率的因素有两个:</p></li></ul><ol><li>信道能通过的频率范围:在任何信道中,码元传输的速率是有上限的,传输速率超过此上限,就会产生严重的码间串扰(码元之间的界限变得不再明确,前后都拖了”尾巴”).</li><li>信噪比: (突然的噪声会导致误判,0变成1,1变成0).信噪比就是信号的平均功率和噪声的平均功率之比.</li></ol><ul><li>码元:时间轴上的一个信号的编码单位</li></ul><h4 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h4><ul><li>信道的极限传输速率C是: <code>C = W log2(1+S/N) (bit/s)</code></li></ul><h3 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h3><h4 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h4><ul><li>不归零制,归零制,曼彻斯特编码,差分曼彻斯特编码</li></ul><h4 id="基本的带通调制方法-将数字信号转化为模拟信号"><a href="#基本的带通调制方法-将数字信号转化为模拟信号" class="headerlink" title="基本的带通调制方法(将数字信号转化为模拟信号)"></a>基本的带通调制方法(将数字信号转化为模拟信号)</h4><ul><li><p>调幅(AM):载波振幅随基带数字信号而变化.例如0或1对应于无载波输出和有载波输出</p></li><li><p>调频(FM):载波频率随基带数字信号而变化.0或10或1对应频率f1和f2</p></li><li><p>调相(PM):载波的初始相位随基带数字信号而变化.例0或1分别对应相位0度或180度</p></li></ul><h3 id="常用的通信介质"><a href="#常用的通信介质" class="headerlink" title="常用的通信介质"></a>常用的通信介质</h3><h4 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><ul><li><p>双绞线:绞合可减少对相邻导线的电磁干扰.绞合度越高最大传输速率就越高,但是价格也越高.</p></li><li><p>同轴电缆:主要用在有线电视网的居民小区.</p></li><li><p>光缆:多模光纤(只适合近距离传输),单模光纤.</p></li></ul><h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><ul><li><p>短波通信</p></li><li><p>微波接力</p></li><li><p>微信通信</p></li></ul><h3 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h3><ul><li><p>频分复用(FDM):同一时间不同用户使用不同的频带宽度(就是信号的频率)进行通信.</p></li><li><p>时分复用(TDM):不同用户在不同的时间点占用过同样的频带宽度(表现为周期性出现用户的时隙)</p></li><li><p>波分复用(WDM) =&gt; 就是光的频分复用</p></li><li><p>码分复用(CDM, Code Division Multiplexing):更常用的是码分多址CDMA.码分复用即将0和1对应到一串特殊的二进制,每个用户不重复(更准确地说,要求是正交的).比如将1表示为001100这一串二进制,则对应的0就是将其每一位都取反,即110011.</p></li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><hr><ul><li>数据链路层的基本传输单元叫做 <em>帧</em></li></ul><h3 id="帧同步问题"><a href="#帧同步问题" class="headerlink" title="帧同步问题"></a>帧同步问题</h3><blockquote><p>帧的开始和结束的确认</p></blockquote><ul><li>数据链路层的三个功能: 透明传输, 流量控制, 差错检测(只检错不纠错)</li></ul><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul><li><p>所有在互联网上传送的数据都以分组(IP数据报)为传送单位,网络层的IP数据报送到数据链路层就成为帧的<code>数据部分</code>.对帧的数据部分加上首部和尾部就构成了一个完整的帧.</p></li><li><p>首部和尾部的一个重要作用就是帧定界(确认帧的开始和结束)</p></li><li><p>最大传输单元<code>MTU(Maximum Transfer Unit)</code>: MTU是的是帧的<code>数据部分</code>的最大长度.</p></li></ul><h5 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a>帧定界</h5><ul><li><p><code>SOH(Start Of Header)</code>:帧开始符(由一串不与数据部分重合的二进制位组成)</p></li><li><p><code>EOT(End Of Transmission)</code>:帧结束符</p></li><li><p>帧定界符可以检测数据是否有差错,例如一个帧是否完整</p></li></ul><h5 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h5><ul><li><p>即用作帧定界的控制字符的比特编码不能出现在数据部分中</p></li><li><p>透明: 某一个实际存在的事物看起来却好像不存在一样</p></li><li><p>在数据链路层透明传输数据表示:<strong>无论什么样的比特组合的数据,都能够按照原样没有差错地通过这个数据链路层</strong></p></li><li><p>为了解决透明传输的问题,对于数据中出现的控制字符’EOT’和’SOH’的前面插入一个转义字符’ESC’,接收端的数据链路层会在将数据交付网络层之前删除这个转义字符.这种方法称为<code>字节填充</code>或者<code>字符填充</code>.(如出现转义字符则再加转义字符)</p></li></ul><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><ul><li>目前在数据链路层广泛地使用了CRC(Cyclic Redundant Check)的检错技术.</li></ul><h3 id="点对点协议ppp"><a href="#点对点协议ppp" class="headerlink" title="点对点协议ppp"></a>点对点协议ppp</h3><blockquote><p>point to point protocol</p></blockquote><ul><li><p>互联网用户必须连接到某个ISP才能接入互联网,ppp协议就是用户计算机和ISP进行通信时使用的 <strong>数据链路层协议</strong></p></li><li><p>ppp协议支持多种网络层协议(如IP和IPX)和多种类型链路(例如串行(一次发送一个比特)和并行(一次并行地发送多个比特))</p></li><li><p>差错检测: ppp协议对接收端收到的帧进行检测,并 <strong>立即丢弃有差错的帧</strong></p></li><li><p>最大传送单元: ppp协议对每一种类型的点对点链路设置最大传送单元MTU的标准默认值,如果高层协议发送的分组过长并超过MTU的数组,则 <strong>丢弃这样的帧</strong></p></li></ul><h4 id="ppp协议的帧格式"><a href="#ppp协议的帧格式" class="headerlink" title="ppp协议的帧格式"></a>ppp协议的帧格式</h4><ul><li><p>首部为四个字段, 尾部为两个字段.</p></li><li><p>首部的第一个字段和尾部的第二个字段(最后一个字段)都是 <strong>标志字段</strong>,规定为<code>0x7E</code>.标志字段表示一个帧的开始或结束.因此标志字段就是ppp帧的定界符. <strong>连续两个帧之间只需要一个标志字段,连续两个标志字段表示这是一个空帧</strong></p></li><li><p>首部中的第二个字段(地址字段A)和第三个字段(控制字段C)没有实际的含义</p></li><li><p>首部的第四个字段是协议字段,占2字节.</p></li><li><p>数据部分(信息字段)长度是可变的,最长不超过1500字节</p></li><li><p>尾部的第一个字段(2字节)是使用CRC的检验序列FCS</p></li><li><p>字节填充: ppp使用异步传输时,转义符定义为<code>0x7D</code>,填充方法:将信息字段中每一个0x7E字符转化为(0x7D, 0x5E),将出现的0x7D转化为(0x7D, 0x5D),如果出现ASCII码的控制符(即数值小于0x20),则在该字符前增加一个0x7D,例如0x03转化为(0x7D, 0x03)</p></li></ul><h3 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h3><ul><li><p>局域网的主要特点:网络为一个单位所拥有,且地理范围和站点数目均有限.</p></li><li><p>局域网使用的是数据链路层的协议</p></li><li><p>局域网的优点:</p></li></ul><ol><li>具有广播功能,从一个站点可以很方便地访问全网.</li><li>便于系统的扩展和逐渐演变,各设备的位置可以灵活调整和改变.</li><li>提高了系统的可靠性,可用性和生存性.</li></ol><ul><li><p>局域网的拓扑结构: 星型网,环形网和总线网.</p></li><li><p>局域网工作的层次跨越了数据链路层和物理层.</p></li><li><p>数据链路层在局域网中分为两个子层:</p></li></ul><ol><li>逻辑链路控制层(LLC) (现在使用的局域网协议–<em>以太2型</em> 取消了LLC层,只留下MAC层)</li><li>介质访问控制层(MAC) (MAC层与物理层使用的介质密切相关)</li></ol><h4 id="共享信道"><a href="#共享信道" class="headerlink" title="共享信道"></a>共享信道</h4><ul><li>由于局域网的广播信道是一人发送,所有人都可以接收,所以要制定发送规则.</li></ul><h5 id="静态信道划分"><a href="#静态信道划分" class="headerlink" title="静态信道划分"></a>静态信道划分</h5><ul><li>使用诸如频分复用,时分复用等技术,用户只要分配到了信道就不会和其他用户发生冲突,但代价太高,不适合局域网使用.</li></ul><h5 id="动态媒体接入控制"><a href="#动态媒体接入控制" class="headerlink" title="动态媒体接入控制"></a>动态媒体接入控制</h5><ul><li><p>又称为 <em>多点接入(multiple access)</em></p></li><li><p>又分为两类:</p></li></ul><ol><li>随机接入: 所有用户都可以随机地发送信息,但可能发生碰撞,需要解决碰撞的网络协议.</li><li>受控接入: 用户发送信息要服从一定的控制,例如集中控制的多点线路 <em>探寻(polling)</em><blockquote><p>受控接入在目前的局域网中使用的较少</p></blockquote></li></ol><h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><ul><li><p>计算机与外界局域网的连接是通过适配器(adapter)进行的.</p></li><li><p>适配器实现的功能包括了数据链路层和物理层.</p></li><li><p>适配器在接收和发送各种帧的时候,不使用计算机的CPU.当适配器收到有差错的帧的时候,就直接丢弃而不通知计算机.<strong>当接收到正确的帧的时候,就使用中断来通知计算机,并交付协议栈中的网络层.当计算机要发送IP数据报时,就由协议栈把IP数据报向下交给适配器,组装成帧后发送到局域网</strong></p></li><li><p><strong>注意: 计算机的硬件地址(MAC地址)就在适配器的ROM中</strong></p></li></ul><h3 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h3><ul><li>为了通信简便,以太网使用以下两个措施:</li></ul><ol><li><p>采用 <strong>无连接</strong> 的工作方式,即尽最大努力交付(不可靠的交付).接收站对收到的差错帧直接丢弃(采用CRC检错),至于是否需要重传由高层协议决定(例如TCP协议)</p></li><li><p>以太网发送的数据都是使用曼彻斯特编码的信号</p></li></ol><h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><ul><li><p>CSMA/CD: Carrier Sense Multiple Access Protocl with Collision Detection.意思是载波监听多点接入/碰撞检测</p></li><li><p>要点:</p></li></ul><ol><li>“多点接入”: 许多计算机是以多点接入的方式连接在一根总线上.</li><li>“载波监听”: 就是用电子技术检测总线上有没有其他计算机也在发送.<strong>不管在发送前,发送中,每个站都必须不停地检测信道</strong>.在发送中检测信道,是为了及时发现有没有其它站的发送和本站发送的碰撞,这称为 <em>碰撞检测</em>.</li><li>“碰撞检测”: 也就是边发送边监听,也称为 “冲突检测”.一旦发生冲突,总线上传输的信号产生了严重的失真,无法恢复出有用的信息来,因此任何一个正在发送的站一旦检测到冲突其适配器立即停止发送.</li></ol><ul><li><p>检测时信道空闲不代表没有站在通信,因为存在传播时延.</p></li><li><p><strong>电磁波在1km电缆的传播时延约为5us</strong></p></li><li><p>若总线上单程端到端的传播时延记为<code>t</code>,则最多经过<code>2t</code>就能确定有没有发生冲突.(发送数据后监听<code>2t</code>时间,没有冲突即发送成功)</p></li><li><p>使用CSMA/CD协议时,一个站不能边发送边接收,因此使用CSMA/CD的以太网只能进行 <em>半双工通信</em></p></li><li><p>以太网规定最短帧长度为64字节(512bit).因为 <strong>对于10Mbit/s的以太网,争用期为51.2us,而发送512bit需要恰好51.2us,如果数据短于64字节,则可能无法检测出发生冲突的帧</strong>. 因此规定<code>凡是长度小于64字节的帧都是由于冲突而异常终止的无效帧</code>.</p></li><li><p>名词概念: <code>10BASE-T</code>这里<code>10</code>表示10Mbit/s的数据率, <code>BASE</code>表示连接线上的信号是基带信号, <code>T</code>代表双绞线.</p></li><li><p>星型网使用 <em>集线器(hub)</em> 作为中心.使用集线器的以太网在逻辑上仍然是一个总线网,各站共享逻辑上的总线,使用的还是CSMA/CD协议.</p></li><li><p>集线器工作在物理层,它的每个接口仅仅简单地转发比特,<strong>不进行碰撞检测</strong>(碰撞检测由各站的适配器完成)</p></li></ul><h3 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h3><h4 id="以太网V2的MAC帧"><a href="#以太网V2的MAC帧" class="headerlink" title="以太网V2的MAC帧"></a>以太网V2的MAC帧</h4><ul><li>以太网V2的MAC帧由五个字段组成.</li></ul><ol><li>第一个字段为6个字节的目的地址</li><li>第二个字段为6个字节的源地址</li><li>第三个字段为2个字节的类型字段(用来标志上一层使用了什么协议,以便把收到的MAC帧交给上一层的这个协议)</li><li>第四个字段数据字段,<strong>长度在46-1500字节之间</strong>(由于之前提到帧的最小长度是64字节,所以46字节就是用64减去首部尾部得到的).数据字段就是网络层传下来的IP数据报.</li><li>最后一个字段是4字节的帧检验序列FCS(使用CRC检验)</li></ol><ul><li><p>从MAC子层向下传到物理层还要添加8个字节(包括7字节的前同步码(1和0的交替码)和1字节的帧开始定界符(定义为10101011)),它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率,使它和发送端同步.</p></li><li><p><strong>设置MAC帧长度的限制的原因</strong>:最短64字节的原因在之前以太网帧长度处规定了.最长不能超过1518字节是因为如果数据帧太长,则单一站点占用信道的时间太长影响其他站点分享带宽,同时太长的帧在传输时容易出错.</p></li></ul><h3 id="网桥-bridge"><a href="#网桥-bridge" class="headerlink" title="网桥(bridge)"></a>网桥(bridge)</h3><ul><li><p>中继器只能识别出位(bit),网桥能够识别数据帧.</p></li><li><p>网桥的升级版为交换机,两者都是工作在数据链路层.</p></li></ul><h4 id="交换机-switch"><a href="#交换机-switch" class="headerlink" title="交换机(switch)"></a>交换机(switch)</h4><ul><li><p>1990年问世的 <em>交换式集线器(switching hub)</em> 很快就淘汰了网桥.交换式集线器称为 <code>以太网交换机</code>或<code>第二层交换机</code></p></li><li><p>以太网交换机实际上就是一个 <strong>多接口的网桥</strong>, 和工作在物理层的转发器,集线器有很大的区别,以太网交换机的每个接口都直接与一个单台主机或另一个以太网交换机相连,并且一般都工作在 <strong>全双工方式</strong>.其内部的交换表(又称为地址表)是通过 <em>自学习</em> 算法自动建立起来的.</p></li></ul><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><ul><li>使用了特殊的交换机,第三层交换机,即搭载了路由表的交换机,可以提供网络间通讯的功能.</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><hr><ul><li><p>网络层向上只提供简单灵活的,无连接的,尽最大努力交付的数据报服务.</p></li><li><p>传输单元为分组(即IP数据报)</p></li></ul><h3 id="虚电路和数据报的比较"><a href="#虚电路和数据报的比较" class="headerlink" title="虚电路和数据报的比较"></a>虚电路和数据报的比较</h3><table><thead><tr><th style="text-align:center">对比方面</th><th style="text-align:center">虚电路服务</th><th style="text-align:center">数据报服务</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">可靠通信应当由网络来保证</td><td style="text-align:center">可靠通信应当由用户主机来保证</td></tr><tr><td style="text-align:center">连接的建立</td><td style="text-align:center">必须有</td><td style="text-align:center">不需要</td></tr><tr><td style="text-align:center">终点地址</td><td style="text-align:center">尽在连接建立阶段使用,每个分组使用短的虚电路号</td><td style="text-align:center">每个分组都有完整地址</td></tr><tr><td style="text-align:center">分组的转发</td><td style="text-align:center">属于同一条虚电路的分组均按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">当结点出现故障时</td><td style="text-align:center">所有通过出故障结点的虚电路均不能工作</td><td style="text-align:center">出故障的结点可能会丢失分组,一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按发送顺序到达终点</td><td style="text-align:center">到达终点的时间不一定按发送顺序</td></tr><tr><td style="text-align:center">端到端的差错处理和流量控制</td><td style="text-align:center">可由网络负责,也可以由用户主机负责</td><td style="text-align:center">由用户主机负责</td></tr></tbody></table><h3 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h3><h4 id="网络互联"><a href="#网络互联" class="headerlink" title="网络互联"></a>网络互联</h4><ul><li>将互联网连接起来需要使用一些中间设备,不同的层次使用的中间设备有不同的名称:</li></ul><ol><li>物理层: 转发器(repeater)</li><li>数据链路层: 网桥或者桥接器(bridge)</li><li>网络层: 路由器(router)</li><li>网络层以上各层: 网关(gateway)</li></ol><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><ul><li><p>A类,B类,C类地址都是由两个固定长度的字段组成: 第一个字段是网络号(net-id), 一个网络号在整个互联网范围内必须是唯一的. 第二个字段是主机号(host-id), 一台主机号在它前面的网络号所指明的网络范围内必须是唯一的.</p></li><li><p>IPV4地址长度是32位,A类,B类和C类的网络号分别是1个字节(8位),2个字节(16位)和3个字节(24位)长,在网络号最前面有1-3位类别位,A,B,C类网络分别为0,10和110.</p></li></ul><h5 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h5><ul><li><p>A类地址网络号占一个字节,只有7位可以使用(第一位固定为0),但可指派的网络号是126个(2^7 - 2),<strong>减2的原因是:</strong> (1)网络号全为0的IP地址是个保留地址,意思是”本网络”.(2) 网络号为127的网络地址保留作为本地软件 <em>环回测试(loopback test)</em> 本机的进程之间的通信之用.</p></li><li><p>A类地址主机号占3字节,可以指派的主机数为2^24-2, 这里 <strong>减2的原因是:</strong> (1)全0的主机号字段表示该IP地址是”本主机”所连接到的 <em>单个网络地址</em> (例如: 一台主机的IP地址是<code>5.6.7.8</code>,则<code>5.0.0.0</code>表示这个主机所在的 <em>网络地址</em>) (2)全1的主机号表示 <strong>所有的(all)</strong>, 因此全1的主机号表示该网络上的所有主机.</p></li></ul><blockquote><p>例如: B类地址128.7.255.255表示”在网络128.7.0.0上的所有主机”,A类地址0.0.0.35表示”在这个网络上主机号为35的主机”</p></blockquote><ul><li><strong>A类地址第一个可指派的网络号为1.0.0.0,最后一个可指派的网络号为126.0.0.0</strong></li></ul><h5 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h5><ul><li><p>B类地址网络号有2个字节,最前面两位已经固定(为10),值剩下14位.<strong>由于B类地址128.0.0.0是不指派的</strong>,所以可以指派的 <strong>B类最小网络地址是128.1.0.0</strong>.因此B类可指派的网络数为2^14-1.</p></li><li><p>B类地址主机号占2字节, 由于全0和全1的主机号不能指派(理由同A类地址),所以可以指派的主机数为2^16-2</p></li><li><p><strong>B类地址第一个可指派的网络号为128.1.0.0,最后一个可指派的网络号为191.255.0.0</strong></p></li></ul><h5 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h5><ul><li><p>C类地址有3个字节的网络号,前3个字节固定(为110),C类地址192.0.0.0也是不指派的,指派的 <strong>最小的C类网络地址是192.0.1.0</strong>,因此C类地址可指派的网络总数是2^21-1.</p></li><li><p>每个C类地址的最大主机数为2^8-2</p></li><li><p><strong>C类地址第一个可指派的网络号为192.0.1.0, 最后一个可指派的网络号为223.255.255.0</strong></p></li><li><p>一般不使用的特殊IP地址</p></li></ul><table><thead><tr><th>网路号</th><th>主机号</th><th>源地址使用</th><th>目的地址使用</th><th>代表意思</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可以</td><td>在本网络上的本主机</td></tr><tr><td>0</td><td>host-id</td><td>可以</td><td>不可以</td><td>在本网络上的某台主机(host-id)</td></tr><tr><td>全1</td><td>全1</td><td>不可以</td><td>可以</td><td>在本网络上进行广播</td></tr><tr><td>net-id</td><td>全1</td><td>不可以</td><td>可以</td><td>对net-id上的所有主机进行广播</td></tr><tr><td>127</td><td>非全0或全1的 任何数</td><td>可以</td><td>可以</td><td>用于本地软件环回测试</td></tr></tbody></table><h5 id="IP地址特点"><a href="#IP地址特点" class="headerlink" title="IP地址特点"></a>IP地址特点</h5><ul><li><p>实际上,IP地址标志一台主机(或路由器)和一条链路的 <em>接口</em>.当一台主机同时连接到两个网络上时,该主机就必须同时具有两个相应的IP地址,其网络号必须是不同的.</p></li><li><p>按照互联网的观点, 一个网络就是具有相同网路号net-id的主机的集合.</p></li></ul><h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><ul><li><p>ARP协议根据IP地址获取物理地址.</p></li><li><p>由于网络层使用的是IP地址,但是在实际网络的链路上传送数据帧时,最终还是必须使用该网络的硬件地址.但IP地址和下面的网络的硬件地址之间由于格式的不同而不存在简单的映射关系(IP地址32位而局域网的硬件地址是48位).此外,在一个网络上可能经常会有新的主机加进来或者撤走旧的主机.更换网络适配器也会使主机的硬件地址改变.</p></li><li><p>地址解析协议ARP解决这个问题的方法是,在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表,并且这个映射表还经常动态更新.</p></li></ul><h3 id="即IP数据报"><a href="#即IP数据报" class="headerlink" title="即IP数据报"></a>即IP数据报</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul><li><p>一个IP数据报由 <em>首部</em> 和 <em>数据</em> 两部分组成.</p></li><li><p>首部的前一部分是固定长度,共20字节,是所有IP数据报必须具有的.在首部固定部分后面是一些可选字段,其长度是可变的.</p></li></ul><h5 id="首部固定部分中的各字段"><a href="#首部固定部分中的各字段" class="headerlink" title="首部固定部分中的各字段"></a>首部固定部分中的各字段</h5><blockquote><p>一共12个字段</p></blockquote><ul><li><p>版本: 占4位,指IP协议的版本,通信双方使用的IP协议的版本必须一致.</p></li><li><p>首部长度: 占4位,可表示的最大十进制数值是15.<strong>注意,这个长度的单位是32位字(1个32位字是4字节),即当值为1111(15)时,表示首部长度为60字节</strong>.当IP分组的首部长度不是4字节的整数倍时,必须利用最后的填充字段加以填充.</p></li><li><p>区分服务: 占8位, 用来获得更好的服务.(一般情况下都不使用这个字段)</p></li><li><p>总长度: 占16为,因此最大值为2^16-1=65535.总长度指首部和数据之和的长度,单位为字节.一般下面的数据链路层都规定了MTU(Maximum Transfer Unit),即最大传送单元.一个IP数据包封装成帧之后长度一定不能超过这个值,否则就要进行分片.</p></li><li><p>标识(identification): 占16位.IP软件在存储器中维持一个计数器,每产生一个数据报,计数器就加1,并将此值赋给标识字段.但这个不是序号,因为数据报不存在顺序接收.</p></li><li><p>标志(flag): 占3位,目前只有前两位有意义.</p></li></ul><ol><li>标志字段中的最低位记为<code>MF(More Fragment)</code>. MF=1表示后面”还有分片”的数据报.MF=0表示这已是若干数据报片的最后一个.</li><li>标志字段中间一位记为<code>DF(Don&#39;t Fragment)</code>,意思是”不能分片”.只有当DF=0时才允许分片.</li></ol><ul><li><p>片偏移: 占13位.片偏移指出:较长的分组在分片后,某片在原分组中的相对位置.也就是说,相对于用户数据字段的起点,该片从何处开始.<strong>片偏移的单位是8字节</strong>,<em>所以说每个分片的长一定是8字节(64位)的整数倍.</em></p></li><li><p>生存时间: 占8位.英文缩写是TTL(Time To Live),表明这是数据包在网络中的寿命.其目的是防止无法交付的数据包无限在网络中兜圈子.路由器每转发一次就将数据报的TTL的值减1,如果某个数据报的TTL=0,则路由器接收之后直接丢弃而不转发.</p></li><li><p>协议: 占8位.协议字段指出此数据包携带的数据使用的是何种协议, 以便使目的主机的IP层知道将数据部分上交给哪个协议进行处理.</p></li><li><p>首部校验和: 占16位.<strong>这个字段只检验数据报的首部,但不包括数据部分</strong>.每经过一个路由器,都要重新计算一遍校验和(因为生存时间,标志,片偏移等可能会变化).</p></li><li><p>源地址:占32位</p></li><li><p>目的地址: 占32位</p></li></ul><h4 id="IP转发分组的流程"><a href="#IP转发分组的流程" class="headerlink" title="IP转发分组的流程"></a>IP转发分组的流程</h4><ul><li><p>在路由表中,对每一条路由最主要的是以下两个信息(还会包括其他的一些信息):(目的网络地址, 下一跳地址)</p></li><li><p>只有到达最后一个路由器时,才试图向目的主机进行交付.</p></li></ul><h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><ul><li><p>在IP地址中增加了一个”子网号字段”,使得两级IP地址变为三级IP地址.这种做法叫做 <em>划分子网(subnetting)</em>.</p></li><li><p><code>IP地址 ::= {&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</code></p></li><li><p>子网号字段占用了主机号字段的长度,因此划分子网会使主机数目减少,<strong>但是不改变原来的网络号</strong>,因此对外这个网络还是原来的网络.</p></li></ul><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><ul><li><p>从IP数据报的首部无法看出源主机或者目的主机所连接的网络是否进行了子网划分,就必须使用 <em>子网掩码</em></p></li><li><p>例如将IP地址145.13.3.10与子网掩码255.255.255.0做与操作,得到的网络地址是145.13.3.0.</p></li><li><p>使用子网划分后,路由表必须包含一下三项内容:目的网络地址,子网掩码和下一跳地址.</p></li></ul><h4 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h4><h5 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h5><ul><li><p>使用 <em>变长子网掩码VLSM(Variable Length Subnet Mask)</em> 可以进一步提高IP地址资源的利用率.在VLSM的基础上又进一步研究出无分类编址方法,正式名称是 <em>无分类域间路由选择CIDR(Classless Inter-Domain Routing)</em></p></li><li><p>CIDR的主要特点有两个:</p></li></ul><ol><li>CIDR消除了传统的A类, B类和C类的地址以及划分子网的概念.CIDR把32位的IP地址分成前后两个部分,前面部分是<code>网络前缀(network-prefix)</code>,用来指明网络,后面部分用来指明主机.因而CIDR是无分类的两级编址,记法为:<br><code>IP地址:={&lt;网络前缀&gt;,&lt;主机号&gt;}</code>.CIDR还使用”斜线记法”,即在IP地址后面加上斜线<code>/</code>,然后写上网络前缀所占的位数.</li><li>CIDR把网络前缀都相同的连续的IP地址组成一个”CIDR地址块”,我们只要知道CIDR地址块中的任何一个地址,就可以知道这个地址块的起始地址和最大地址,以及地址块中的地址数.例如:<br>128.14.35.78/20 = <strong>10000000 00001110 0010</strong> 0011 00000111 (20位网络前缀已加粗)<br>所以最小地址可以很方便地写出: 128.14.32.0(<strong>10000000 00001110 0010</strong>0000 00000000),最大地址也可以很方便写出:128.14.47.255(<strong>10000000 00001110 0010</strong> 1111 11111111)</li></ol><ul><li><p>为了更方便进行路由选择,CIDR使用32位 <em>地址掩码</em>(address mask), 地址掩码由一串1和一串0组成,1的个数就是网络前缀的长度.(原理与子网掩码一致,都是通过与操作获取网络地址)</p></li><li><p>CIDR仍然可以划分子网,但子网的网络前缀比整个单位的网络前缀长一些.</p></li><li><p>CIDR记法有很多种,例如地址块<code>10.0.0.0/10</code>可以简写为<code>10/10</code>,也就是把点分十进制中低位连续的0省略.</p></li><li><p>另一种简化表示法是在网络前缀后加一个<code>*</code>,如<code>00001010 00*</code>,表示<code>*</code>之前是网络前缀,而<code>*</code>表示IP地址中的主机号,可以是任意值.</p></li><li><p>使用CIDR时, 由于采用了网络前缀这种记法,IP地址由网络前缀和主机号这两个部分组成,因此路由表中的项目也要相应地改变.这时每个项目由”网络前缀”和”下一跳地址”组成.</p></li><li><p>但是查找路由表 <strong>可能会得到不止一个匹配结果</strong>, 因此 <strong>应当从匹配结果中选择具有最长网络前缀的路由</strong>,这叫做 <em>最长前缀匹配(longest-prefix matching)</em>. 这因为网络前缀越长,其地址块就越小,因而路由也就越具体.因此在转发的时候是选择匹配到的地址中更具体的.</p></li><li><p>最长前缀匹配又称为 <em>最长匹配</em> 或 <em>最佳匹配</em></p></li></ul><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><ul><li><p>从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分, 则只有两大类: <em>静态路由选择策略</em> 和 <em>动态路由选择策略</em></p></li><li><p>静态路由选择也叫 <em>非自适应路由选择</em>, 适用于简单的小网络.</p></li><li><p>动态路由选择也叫 <em>自适应路由选择</em>, 适用于复杂的大网络.(因为实现较复杂,开销也比较大)</p></li></ul><h4 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h4><ul><li><p>内部网关协议IGP(Interior Gateway Protocol): 在一个自治系统内部使用的路由选择协议.(如RIP和OSPF协议)</p></li><li><p>外部网关协议EGP(External Gateway Protocol): 若源主机和目的主机处在不同的自治系统中(这两个自治系统可能使用不同的内部网关协议),当数据包传到自治系统的边界时,就要使用外部网关协议.</p></li></ul><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><ul><li>多播和单播的区别: 例如要向100台主机发送同一份数据, 单播则要发送90份相同的副本给每个主机,而多播只要发送一个副本就可以了(不需要复制分组).</li></ul><h3 id="虚拟专用网VPN和网络地址转换NAT"><a href="#虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="虚拟专用网VPN和网络地址转换NAT"></a>虚拟专用网VPN和网络地址转换NAT</h3><ul><li><p>RFC1918指明了一些 <em>专用地址</em>(private address),这些地址只能用于一个机构内部通信,即只能用作本地地址不能用作全球地址.</p></li><li><p>例如:</p></li></ul><ol><li><code>10.0.0.0</code>到<code>10.255.255.255</code></li><li><code>172.16.0.0</code>到<code>172.31.255.255</code></li><li><code>192.168.0.0</code>到<code>192.168.255.255</code><br>这三个地址相当于一个A类网络,16个连续的B类网络和256个连续的C类网络.</li></ol><h4 id="VPN-Virtual-Private-Network"><a href="#VPN-Virtual-Private-Network" class="headerlink" title="VPN(Virtual Private Network)"></a>VPN(Virtual Private Network)</h4><ul><li><p>使用IP隧道技术实现虚拟专用网.</p></li><li><p>例子: 某个机构两个场所建立了专用网A和B,其网络地址分别为专用地址10.1.0.0和10.2.0.0.现在这两个场所需要 <strong>通过公用的互联网构成一个VPN</strong>.显然 <strong>每个场所至少有一个路由器具有合法的全球IP地址</strong>,这个具有全球IP地址的路由器在专用网内部的接口地址则是专用网的本地地址.即两个场所内主机的相互通信借由连到公网的路由器来转发和接收实现.</p></li></ul><h4 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT(Network Address Translation)"></a>NAT(Network Address Translation)</h4><ul><li><p>需要在专用网连接到互联网的路由器上安装NAT软件.装有NAT软件的路由器叫做 <em>NAT路由器</em>, 它至少有一个有效的全球IP地址.<strong>所有使用本地地址的主机和外界通信的时候,都要在NAT路由器上将其本地地址转换成全球IP地址</strong></p></li><li><p>当NAT路由器具有N个全球IP地址的时候,专用网内部最多 <strong>同时</strong> 有N台主机可以接入互联网.</p></li><li><p>现在常用的NAT转换表把运输层的 <em>端口号</em> 也用上, 这样就可以使多个拥有本地地址的主机公用一个NAT路由器上的全球IP地址.</p></li></ul><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><hr><ul><li>网络层只是将分组从一台主机传输到另一台主机,而运输层则再将这一通信过程精确到主机中的进程.</li></ul><blockquote><p>IP协议虽然能把分组送到目的主机, 但是这个分组还停留在主机的网络层而没有交付主机在的应用程序.从运输层角度来看,通信真正的端点并不是主机而是主机中的进程.也就是说, 端到端的通信是应用进程之间的通信.</p></blockquote><ul><li><p>TCP/IP运输层的两个主要协议: <strong>用户数据报协议UDP(User Datagram Protocol)</strong> 和 <strong>传输控制协议TCP(Transmission Control Protocol)</strong></p></li><li><p>传送的数据单元根据协议的不同,分别称为 <strong>TCP报文段</strong> 和 <strong>UDP用户数据报</strong></p></li><li><p>使用UDP和TCP协议的各种应用和应用层协议</p></li></ul><table><thead><tr><th>应用</th><th>应用层协议</th><th>运输层协议</th></tr></thead><tbody><tr><td>名字转换</td><td>DNS(域名系统)</td><td>UDP</td></tr><tr><td>文件传送</td><td>TFTP(简单文件传送协议)</td><td>UDP</td></tr><tr><td>路由选择协议</td><td>RIP(路由信息协议)</td><td>UDP</td></tr><tr><td>IP地址配置</td><td>DHCP(动态主机配置)</td><td>UDP</td></tr><tr><td>网络管理</td><td>SNMP(简单网络管理协议)</td><td>UDP</td></tr><tr><td>远程文件服务器</td><td>NFS(简单网络管理协议)</td><td>UDP</td></tr><tr><td>IP电话</td><td>专用协议</td><td>UDP</td></tr><tr><td>流式多媒体通信</td><td>专用协议</td><td>UDP</td></tr><tr><td>多播</td><td>IGMP(网际组管理协议)</td><td>UDP</td></tr><tr><td>电子邮件</td><td>SMTP(简单邮件传送协议)</td><td>TCP</td></tr><tr><td>远程终端接入</td><td>TELNET(远程终端协议)</td><td>TCP</td></tr><tr><td>万维网</td><td>HTTP(超文本传送协议)</td><td>TCP</td></tr><tr><td>文件传送</td><td>FTP(文件传送协议)</td><td>TCP</td></tr></tbody></table><h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><ul><li><p>由于进程的创建和撤销是动态的,所以通信的一方几乎无法识别对方机器上的进程.解决这个问题的方法就是在运输层使用 <em>端口协议号(protocol port number)</em>,通常简称为 <em>端口</em>.</p></li><li><p>不同的端口用来标志不同的应用进程.虽然通信的终点是应用进程,但是只要把所传送的报文交到目的主机的某个合适的目的端口,剩下的工作(交付目的进程)就由TCP和UDP来完成.</p></li><li><p>这种在协议栈层间的抽象的协议端口是 <strong>软件端口</strong>,和路由器或交换机的硬件端口是完全不同的概念.硬件端口是不同硬件设备进行交互的接口, 而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址.</p></li><li><p>TCP/IP的运输层用一个16位的端口号来标志一个端口. <strong>注意,端口号只有本地意义,只是为了标记本计算机应用层中各个进程在和运输层交互时的层间接口</strong></p></li><li><p>互联网上的计算机通信采用客户-服务器方式(C/S方式).客户在发起通信请求的时候,必须知道对方服务器的IP地址和端口号.</p></li><li><p>运输层端口号分为两大类:</p><h4 id="一-服务器端使用的端口号"><a href="#一-服务器端使用的端口号" class="headerlink" title="一. 服务器端使用的端口号"></a>一. 服务器端使用的端口号</h4></li><li><p>这里又可以分为两类: <strong>熟知端口号</strong> 和 <strong>登记端口号</strong>.</p></li><li><p>熟知端口号是最重要的一类, 又叫做 <em>系统端口号</em> ,数值为0-1023.</p></li><li><p><strong>需要记住的常用端口号</strong>:</p></li></ul><table><thead><tr><th>应用程序</th><th>熟知端口号</th><th>协议类型</th></tr></thead><tbody><tr><td>FTP</td><td>21</td><td>TCP</td></tr><tr><td>TELNET</td><td>23</td><td>TCP</td></tr><tr><td>SMTP</td><td>25</td><td>TCP</td></tr><tr><td>DNS</td><td>53</td><td>UDP</td></tr><tr><td>TFTP</td><td>69</td><td>UDP</td></tr><tr><td>HTTP</td><td>80</td><td>TCP</td></tr><tr><td>HTTPS</td><td>443</td><td>TCP</td></tr><tr><td>SNMP</td><td>161</td><td>UDP</td></tr><tr><td>SNMP(trap)</td><td>162</td><td>UDP</td></tr></tbody></table><h4 id="二-客户端使用的端口号"><a href="#二-客户端使用的端口号" class="headerlink" title="二. 客户端使用的端口号"></a>二. 客户端使用的端口号</h4><ul><li><p>数值为49152-65535</p></li><li><p>由于这类端口号仅在客户进程运行时才动态选择,因此又叫做 <em>短暂端口号</em></p></li><li><p>当服务器进程收到客户进程的报文时,就知道了客户进程现在所使用的端口号,因而可以把数据发送给客户进程.当通信结束后,刚才使用的客户端口号就不复存在了,这个端口号就可供其他客户进程使用.</p></li></ul><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><ul><li><p>将流量控制和差错控制结合了起来.</p></li><li><p>ARQ协议规定,发送方每收到一个确认,就把发送窗口向前滑动一个分组的位置.于是就可以接着发送下一个分组进入窗口的分组.</p></li><li><p>接收方一般采用累积却认的方式,也就是说接收方不必对收到的分组逐个发送确认,<strong>只要对按序到达的最后一个分组发送确认</strong>,这表示:到这个分组为止的所有分组都已经正确收到了.</p></li><li><p>累积确认的优点是:容易实现,即使确认丢失也不必重传.缺点是:不能向发送方反映出接收方已经正确收到的所有分组的信息.(因为可能存在可能没有按序到达的分组,比如收到了1,2,3,5四个分组,只能对前三个进行确认,而5号分组到达的消息发送方没有办法知道,而且很有可能会重传5号分组)</p></li></ul><h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><h4 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h4><ul><li><p>发送窗口表示: 在没有收到B的确认的情况下,A可以连续地把窗口内的数据都发送出去.<strong>凡是已经发送过的数据,在未收到确认之前都必须暂时保留以便在超时重传时使用.</strong></p></li><li><p>接收方会把自己的接收窗口的数值放在窗口字段中发送给对方,这相当于告诉发送方,自己的剩余缓冲区域的大小.<strong>因此A的发送窗口一定不能超过B的接收窗口的值.</strong></p></li><li><p>发送窗口的位置由窗口的前后沿共同决定.发送窗口的后沿不动有两种可能:<strong>(1)没有收到新的确认. (2)收到了新的确认但是对方通知窗口缩小了,使得前沿刚好不动.</strong></p></li><li><p>发送缓存用来暂时存放:</p></li></ul><ol><li>发送应用程序发送给发送方TCP准备发送的数据</li><li>TCP已发送出但尚未收到确认的数据</li></ol><ul><li>接收缓存用来暂时存放:</li></ul><ol><li>按序到达的,但尚未被接收应用程序读取的数据</li><li>未按序到达的数据</li></ol><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul><li><p>拥塞控制与流量控制的区别: 流量控制管理的是两个点,而拥塞控制管理的是整个网络.</p></li><li><p>计算机网络中的链路容量(即带宽),交换结点中的缓存和处理机等,都是网络的资源.在某段时间,对网络中某一资源的需求超过了该资源所能提供的可用部分,网络性能就要变坏,这种情况就叫 <em>拥塞(congestion)</em></p></li><li><p>问题的实质是,整个系统的各个部分不匹配,只有所有部分平衡了,问题才会得到解决.</p></li><li><p><em>拥塞控制</em> : 防止过多的数据注入到网络中,这样可以使网络中的路由器或链路不致过载.拥塞控制是一个全局性的过程,涉及到所有的主机,所有的路由器,以及降低网络传输性能的所有因素.</p></li><li><p>拥塞控制可以分为 <em>开环控制</em> 和 <em>闭环控制</em>.</p></li><li><p>开环控制就是事先考虑所有的因素,一旦开始运作就不再更改.</p></li><li><p>闭环控制是基于反馈回路的概念.</p></li></ul><h4 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h4><h5 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h5><ul><li><p>发送方维护一个叫做 <em>拥塞窗口cwnd(congestion window)</em> 的状态变量. <strong>发送方让自己的发送窗口等于拥塞窗口</strong>.</p></li><li><p>判断网络拥塞的依据是 <strong>出现了超时</strong>.</p></li><li><p>慢开始: 由小到大逐渐增加拥塞窗口(发送窗口).</p></li><li><p>从慢开始开始指数增长,直到一个阈值(慢开始门限ssthresh),开始加法增长,最后出现超时,再从慢开始从头再来.</p></li><li><p>当cwnd小于ssthresh时,使用慢开始算法(指数增长).当cwnd&gt;ssthresh时,停止使用慢开始算法 <strong>改用拥塞避免算法</strong>.(cwnd = ssthresh时两个算法任意选取)</p></li><li><p><em>拥塞避免算法</em> 的思路是让拥塞窗口cwnd缓慢地增大,即每过一个RTT就把发送方的拥塞窗口加1.注意拥塞避免并不是完全避免了拥塞,而是是吧拥塞窗口控制为按线性增长,使网络比较不容易出现拥塞.</p></li></ul><h4 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h4><ul><li><em>随机早期检测RED(Random Early Detection)</em></li></ul><h3 id="TCP连接的建立和断开-重点"><a href="#TCP连接的建立和断开-重点" class="headerlink" title="TCP连接的建立和断开(重点)"></a>TCP连接的建立和断开(重点)</h3><blockquote><p>三次握手, 四次挥手</p></blockquote><ul><li><p><img src="/images/computer_network/connection.png" alt></p></li><li><p>ACK=1 表示这是一个确认报文, 对之前收到的报文进行确认.</p></li><li><p>SYN=1 表示这是一个同步报文段,用于请求同步.</p></li><li><p>SYN报文段 <strong>不能携带数据, 并且要消耗一个序号</strong></p></li><li><p>ACK报文段可以携带数据,如果不携带数据 <strong>则不消耗序列号</strong></p></li><li><p>FIN报文段可以携带数据, <strong>但是不管携带与否,都要消耗一个序列号</strong></p></li></ul><h4 id="三报文握手-TCP连接建立"><a href="#三报文握手-TCP连接建立" class="headerlink" title="三报文握手(TCP连接建立)"></a>三报文握手(TCP连接建立)</h4><ul><li><p>一开始,B的TCP服务器进程先创建一个 <em>传输控制块TCB(Transmission Control Block)</em>, 准备接收客户进程的连接请求. <em>然后服务器就处于LISTEN(收听)状态</em></p></li><li><p>A的TCP客户进程也是首先创建传输控制模块TCB,然后在打算建立TCP连接时,向B发出连接请求报文段,<strong>这时首部中的同步位SYN=1</strong>,同时 <strong>选择一个初始序号seq=x</strong>.(SYN报文不能携带数据,但要消耗掉一个序号).<em>TCP客户进程进入SYN-SENT(同步已发送)状态</em></p></li><li><p>B收到连接请求报文段后,如同意连接,则向A发送确认.这个确认报文段中SYN位和ACK位都置为1.<strong>确认号ack=x+1(由A发送的确认号为x的请求报文而得到的)</strong>,同时也为自己选择一个初始序号seq=y(<strong>注意B的确认报文的seq字段与A的同步报文的seq无关</strong>),同时,<strong>这个报文也不能携带数据,而且同样要消耗掉一个序列号.</strong> <em>这时TCP服务器进程进入SYN-RCVD(同步收到)状态</em></p></li></ul><blockquote><p>确认报文的确认号ack总是等于被确认的报文的序号seq的值加1</p></blockquote><ul><li><p>TCP客户进程收到B的确认后,还要向B给出确认.(<strong>防止A发出的连接请求报文在网络中长时间逗留而没有丢失,在A重新发送请求并且完成连接,结束通信后,B又收到了A之前误以为被丢失而实际只是滞留了的连接请求报文,这时B会以为这是A的一个新的连接请求,从而发送确认给A.而A没有请求,因此会忽略B的这个确认.设想如果没有A的第三次确认,则B以为连接已经建立而无限地等待A发送数据,从而造成资源的浪费.</strong>) 确认报文的ACK置为1,确认号为ack=y+1(确认号为y+1是因为这是对B发送过来的报文的确认报文),自己的序号seq=x+1.(<em>如果这个报文没有携带数据,则下一个报文的序号仍然是x+1</em>)这时,TCP连接已经建立,A进入ESTABLISHED(已建立连接)状态.</p></li><li><p>当B收到A的确认后,也进入ESTABLISHED状态.</p></li></ul><h4 id="四报文挥手-TCP连接释放"><a href="#四报文挥手-TCP连接释放" class="headerlink" title="四报文挥手(TCP连接释放)"></a>四报文挥手(TCP连接释放)</h4><ul><li><p>数据传输结束后,通信双方都可以释放连接(释放连接是单向的,可以一方停止向另一方发送数据,但另一方还可以向这一方发送数据).(<strong>同时也说明,两个方向都要释放一遍连接</strong>)</p></li><li><p>A的应用进程先向其TCP发出连接释放报文段,并停止再发送数据,主动关闭TCP连接.A把连接释放报文段首部的终止控制位FIN置1,其序号seq=u(<strong>u等于前面A已经传送过的数据的最后一个字节的序号加1</strong>).<em>这时A进入FIN-WAIT-1(终止等待1)状态,等待B的确认.</em></p></li><li><p>B收到连接释放报文段后立即发出确认,确认号ack=u+1.这个报文段自己的序号为v(v等于B前面已经传送过的数据的最后一个字节的序号加1).<em>然后B就进入CLOSE-WAIT(关闭等待)状态.</em> <strong>这时TCP服务器进程会通知高层应用进程,因而从A到B这个方向上的连接就释放了,这时TCP处于半关闭(half-close)状态,即A已经没有数据要向B发送了,但是如果B要发送数据,A仍然要接收.也就是说从B到A这个方向的连接还未关闭,这个状态可能会持续一段时间.</strong></p></li><li><p>A收到来自B的确认后,<em>就进入FIN-WAIT2(终止等待2)状态</em>,等待B发出的连接释放报文段.</p></li><li><p>若B也没有要向A发送的数据,其应用进程就通知TCP释放连接.这时B发出的连接释放报文段FIN=1.假定B的序号为w(因为在半关闭状态B可能又发送了一些数据),此时B还必须重复上次发送过的确认号ack=u+1.<em>这时B就进入了LAST-ACK(最后确认)状态</em>,等待A的确认.</p></li><li><p>A在收到B的连接释放报文段后,在确认报文段中把ACK置1,确认号ack=w+1,序号seq=u+1.<em>进入TIME-WAIT(时间等待)状态</em>. <strong>注意!此时TCP连接没有释放掉,必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后,A才进入CKISED状态</strong>.时间 <em>MSL</em> 叫做 <em>最长报文段寿命(Maximum Segment Lifetime)</em>.</p></li><li><p>这里A需要等待2MSL(<strong>B在收到确认后就立即进入CLOSED状态无需等待</strong>)有两个理由:</p></li></ul><ol><li>为了保证A发送的最后一个ACK报文段能够到达B(A发送的ACK确认报文段可能丢失,B会超时重传这个FIN+ACK报文段,而A就能在2MSL时间段内收到重传的FIN+ACK报文段,并重新发送一次确认,重启2MSL计时器).</li><li>防止”已失效的连接请求报文段”出现在本连接中.再经过2MSL,就可以使本连接持续时间内所产生的所有报文段从网络中消失,确保下一个连接不会收到旧的无效报文段而引发错误.</li></ol><ul><li>最后,TCP还设置 <em>保活计时器(keepalive timer)</em>,在服务器长时间(一般为2小时)没有收到客服的数据(服务器每收到一次客户数据就重置这个等待时间),服务器就发送一个探测请求报文,之后每隔75秒发送一次,若连续10次没有收到客户响应,则关闭这个连接.(为了防止客户机出现故障)</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><hr><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><ul><li><p>域名系统DNS(Domain Name System)能够把互联网上的主机名字转换为IP地址.</p></li><li><p>每一个域名都由 <em>标号(label)</em> 序列组成,各标号之间用点隔开.例如<code>mail.cctv.com</code>,其中<code>mail</code>为三级域名,<code>cctv</code>为二级域名,<code>com</code>为一级域名.(级别最低的域名写在最左边)</p></li><li><p>每一个标号不超过63字符,也不区分大小写.</p></li></ul><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><ul><li>过程如下:当某一个应用进程需要把主机名解析为IP地址时,该应用进程就调用 <em>解析程序(resolver)</em>, 并称为DNS的一个客户,把待解析的域名放在DNS请求报文中,以UDP用户数据报方式发给本地域名服务器.(使用UDP是为了减小开销) 如果本地域名服务器不能回答该请求,则此域名服务器就暂时成为DNS中的另一个客户,向其他域名服务器发出查询请求.</li></ul><h3 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><ul><li>FTP的工作流程:</li></ul><ol><li>打开熟知端口(21),使客户进程能够连接上.</li><li>等待客户进程发出连接请求</li><li>启动从属进程处理客户进程发来的请求.</li><li>回到等待状态</li></ol><h3 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h3><ul><li><p><em>万维网WWW(Worl Wide Web)</em> 是一个大规模的,联机式的信息储藏所.</p></li><li><p><strong>超文本</strong>: 所谓超文本是指 包含指向其他文档的链接的文本(text).也就是说,一个超文本由多个信息源链组成, 而这些信息源可以分布在世界各地,并且数目不受限制.</p></li><li><p><strong>超媒体</strong>: 超媒体与超文本的区别是文档内容不同.超文本文档仅包含文本信息, 而超媒体文档还包含其他表示方式的信息,如图形,图像,声音,动画以及视频图像等.</p></li><li><p>万维网以客户服务器方式工作,浏览器就是在用户主机上的万维网客户程序. <strong>客户程序向服务器程序发出请求,服务器程序就向客户程序送回客户所要的万维网文档</strong>.在一个客户程序主窗口上显示出的万维网文档称为 <em>页面(page)</em>.</p></li></ul><h3 id="三要素URL-HTML和HTTP"><a href="#三要素URL-HTML和HTTP" class="headerlink" title="三要素URL,HTML和HTTP"></a>三要素URL,HTML和HTTP</h3><ul><li><p>万维网使用 <em>统一资源定位符URL(Uniform Resource Locator)</em> 来标志万维网上的各种文档,并使每一个文档在整个互联网的范围内具有唯一的标识符URL.(解决怎样标志分布在整个互联网上的万维网文档)</p></li><li><p><em>超文本传送协议HTTP(HyperText  Transfer Protocol)</em>: HTTP是一个应用层协议,使用TCP连接进行可靠的传送.HTTP协议使得万维网客户程序与万维网服务器程序之间的交互严格遵守这一标准.(解决用什么样的协议来实现万维网上的各种链接)</p></li><li><p>万维网使用 <em>超文本标记语言HTML(HyperText Markup Language)</em>,使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到互联网上的任何一个万维网页面.(解决各种不同风格的文档都能在各种不同的主机上显示出来的问题)</p></li></ul><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><ul><li><p>TCP/IP协议规定的电子邮件地址的格式如下:<code>用户名@邮件服务器域名</code></p></li><li><p>电子邮件最重要的两个标准就是: <em>简单邮件传送协议SMTP(Simple Mail Transfer Protocol)</em><code>[RFC 5321]</code> 和 <em>互联网文本报文格式</em><code>[RFC 5322]</code></p></li><li><p>邮件读取协议POP3和IMAP(Internet Message Access Protocol).</p></li><li><p>不要把POP3或IMAP与SMTP弄混,发件人的用户代理向发送方邮件服务器发送邮件,以及发送方邮件服务器向接收方邮件服务器发送邮件,都使用SMTP协议. 而POP3或IMAP是用户代理从接收方邮件服务器上读取邮件时所使用的协议.</p></li></ul><h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><ul><li>DHCP提供了一种机制,即 <em>即插即用网(plug-and-play networking)</em>.这种机制允许一台计算机接入新的网络和获取IP地址而不用手工参与.</li></ul><h3 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h3><ul><li>SNMP(Simple Network Management Protocol)的网络管理由三个部分组成: 即SNMP本身,<em>管理信息结构SMI(Structure of Management Information)</em> 和 <em>管理信息库MIB(Management Information Base)</em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一些概念性的名词用 &lt;em&gt;斜体&lt;/em&gt; 标出了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;互联网概述&quot;&gt;&lt;a href=&quot;#互联网概述&quot; class=&quot;headerlink&quot; title=&quot;互联网概述&quot;&gt;&lt;/a&gt;互联网概述&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="Computer" scheme="https://fleschier.github.io/categories/Computer/"/>
    
    
      <category term="๑Blog" scheme="https://fleschier.github.io/tags/%E0%B9%91Blog/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记——指针</title>
    <link href="https://fleschier.github.io/2018/12/19/C++_ptr/"/>
    <id>https://fleschier.github.io/2018/12/19/C++_ptr/</id>
    <published>2018-12-19T06:10:00.000Z</published>
    <updated>2018-12-19T14:32:04.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="典型错误"><a href="#典型错误" class="headerlink" title="典型错误"></a>典型错误</h2><hr><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long * fellow;</span><br><span class="line">*fellow = 23333;</span><br></pre></td></tr></table></figure></li><li><p>fellow的确是一个指针,但是它指向的地址还没确定,那么23333会被存放到哪里呢?我们也不知道,这就会引发一个编译错误.</p></li><li><p><strong>指针使用的金科玉律: 一定要在对指针解除引用运算符(*)之前,将指针初始化为一个确定的,适当的地址.</strong></p></li></ul><blockquote><p>——–from C++ Primer Plus</p></blockquote><h2 id="指针和数字"><a href="#指针和数字" class="headerlink" title="指针和数字"></a>指针和数字</h2><hr><ul><li>例子:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int * pt;</span><br><span class="line">pt = 0xB8000000;</span><br></pre></td></tr></table></figure></li></ul><p>在这里左边是一个int类型的指针,而右边是一个 <strong>整数</strong>, 0xB8000000是老式计算机系统中组合段的偏移地址,但是在这条语句中编译器并不知道这是个地址,因此C++编译器会报错.</p><ul><li>正确的写法应该是:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int * pt;</span><br><span class="line">pt = (int *) 0xB8000000;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h2><hr><ul><li><p>在C语言中,只能用库函数malloc()来分配内存,C++也支持这样做,但是有更好的选择—new运算符.</p></li><li><p>new运算符同时要配合delete来使用</p></li><li><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * pt = new int;</span><br><span class="line">...</span><br><span class="line">delete pt;</span><br></pre></td></tr></table></figure></li></ul><p>这将释放pt指向的内存块,但不会删除指针pt本身,它的值也没有改变.</p><ul><li><p>一点要配对地使用new 和 delete,否则会发生内存泄漏(memory leak).</p></li><li><p>不要尝试释放已经释放的内存块,这会导致很严重的不确定性.</p></li><li><p>不能使用delete来释放声明变量所获得的内存:(<strong>也就是delete只能用来删除new分配的内存</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int * ps = new int;   //ok</span><br><span class="line">delete ps;      //ok</span><br><span class="line">delte ps;     //not ok now</span><br><span class="line">int jugs = 5;       //ok</span><br><span class="line">int * pi = &amp;jugs;   //ok</span><br><span class="line">delete pi;      //not allowed now, memory not allocated by &apos;new&apos;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h2><hr><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num = 100;</span><br><span class="line">int * psome = new int[num];</span><br><span class="line">//可以使用psome[0]这样的形式来访问数组元素,与普通的数组无异</span><br><span class="line">...</span><br><span class="line">delete []psome;</span><br></pre></td></tr></table></figure></li></ul><p><strong>delete的方括号告诉程序,应该释放整个数组,而不是仅仅是指针指向的元素</strong></p><ul><li><p>C++将数组名解释为地址(一般情况)</p></li><li><p>数组名被解释为其第一个元素的地址,而对数组名应用取地址符时,得到的是整个数组的地址.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short tell[10];</span><br><span class="line">cout &lt;&lt; tell &lt;&lt; endl;   //display &amp;tell[0]</span><br><span class="line">cout &lt;&lt; &amp;tell &lt;&lt; endl;  //display address of whole array</span><br></pre></td></tr></table></figure></li></ul><p>上面这个例子中,从数值上来说,这两个地址相同;但从概念上来说,<code>&amp;tell[0]</code>(即tell)是一个2字节内存块地址,<strong>而&amp;tell是一个20字节内存块的地址</strong>.因此,表达式tell+1将地址的值加2,而表达式&amp;tell+1将地址的值加20.</p><ul><li>换句话说:<strong>tell是一个short指针(<em>short),而&amp;tell是一个这样的指针,即指向包含20个元素的short数组(short(</em>)[20]).</strong> 这种指针可以这样初始化:<code>short (*pas)[20] = &amp;tell</code>.这里pas的类型为<code>short (*)[20]</code></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><ul><li><p>应将内存地址赋值给指针.</p></li><li><p>可以是对已经赋值的变量名使用<code>&amp;</code>来获得 <em>被命名的内存的地址</em>, 或者使用new运算符返回未命名的内存的地址,只有这两种情况可以赋值给指针.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;典型错误&quot;&gt;&lt;a href=&quot;#典型错误&quot; class=&quot;headerlink&quot; title=&quot;典型错误&quot;&gt;&lt;/a&gt;典型错误&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑C++" scheme="https://fleschier.github.io/tags/%E0%B9%91C/"/>
    
  </entry>
  
  <entry>
    <title>Python 面向对象编程</title>
    <link href="https://fleschier.github.io/2018/11/25/python-class/"/>
    <id>https://fleschier.github.io/2018/11/25/python-class/</id>
    <published>2018-11-25T04:47:00.000Z</published>
    <updated>2018-11-25T05:23:13.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><hr><ul><li><p>简单举例就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mypackage</span><br><span class="line">├─ __init__.py</span><br><span class="line">├─ abcd.py</span><br><span class="line">└─ efgh.py</span><br></pre></td></tr></table></figure></li><li><p>注意每个包下需要一个<code>__init__.py</code>文件</p></li><li><p>如果另一个py文件需要引用abcd.py,则写为<code>mypackage.abcd</code></p></li></ul><h2 id="python类"><a href="#python类" class="headerlink" title="python类"></a>python类</h2><hr><ul><li><p>类不需要显式地申明类成员变量(与C++和Java不同)</p></li><li><p>类中所有的方法的第一个参数都是<code>self</code>, self代表类的实例而非类,并且在调用类方法时,self参数不必传入.</p></li><li><p><code>__init__()</code>方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法</p></li></ul><h3 id="python类内置属性"><a href="#python类内置属性" class="headerlink" title="python类内置属性"></a>python类内置属性</h3><ul><li><p><code>__dict__</code> : 类的属性（包含一个字典，由类的数据属性组成）</p></li><li><p><code>__doc__</code> :类的文档字符串</p></li><li><p><code>__name__</code>: 类名</p></li><li><p><code>__module__</code>: 类定义所在的模块（类的全名是’<strong>main</strong>.className’，如果类位于一个导入模块mymod中，那么className.<strong>module</strong> 等于 mymod）</p></li><li><p><code>__bases__</code> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</p></li></ul><h4 id="判断一个对象是否是一个类的实例"><a href="#判断一个对象是否是一个类的实例" class="headerlink" title="判断一个对象是否是一个类的实例"></a>判断一个对象是否是一个类的实例</h4><ul><li>目前我所知的只有两个方法可行(python3):<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = myclass()</span><br><span class="line">b = myclass()</span><br><span class="line">type(a) == type(b) #a和b都是类实例</span><br><span class="line">isinstance(a, myclass.__bases__)    #虽然__bases__返回的是父类元组,但是却能成功判断</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块与包&quot;&gt;&lt;a href=&quot;#模块与包&quot; class=&quot;headerlink&quot; title=&quot;模块与包&quot;&gt;&lt;/a&gt;模块与包&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单举例就是:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑Python" scheme="https://fleschier.github.io/tags/%E0%B9%91Python/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18 VsCode搭建C++编译环境(已测试)</title>
    <link href="https://fleschier.github.io/2018/11/21/vscode-cpp/"/>
    <id>https://fleschier.github.io/2018/11/21/vscode-cpp/</id>
    <published>2018-11-21T06:43:00.000Z</published>
    <updated>2018-11-21T06:55:57.114Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>坑了一早上,终于摸索出两个编译运行C++的方法,特此记录.</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><hr><ul><li>安装VsCode和g++环境这里就不赀述了</li></ul><h2 id="安装C-插件"><a href="#安装C-插件" class="headerlink" title="安装C++插件"></a>安装C++插件</h2><hr><ul><li>安装一系列C++的插件,我安装的有:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C/C++</span><br><span class="line">C/C++ Intellisense</span><br></pre></td></tr></table></figure></li></ul><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><hr><h3 id="两种方法编译C-文件"><a href="#两种方法编译C-文件" class="headerlink" title="两种方法编译C++文件"></a>两种方法编译C++文件</h3><h4 id="第一种-安装C-C-Compile-Run插件-简单-推荐"><a href="#第一种-安装C-C-Compile-Run插件-简单-推荐" class="headerlink" title="第一种:安装C/C++ Compile Run插件(简单,推荐)"></a>第一种:安装C/C++ Compile Run插件(简单,推荐)</h4><ul><li><p>人生苦短,何必浪费时间在环境搭建上~</p></li><li><p>虽然只支持单文件(single file)的编译和运行,但是日常使用足够了啊</p></li><li><p>打开C++文件F6即可运行</p></li><li><p>官方使用手册:</p><blockquote><p>Requirements<br>If you are on linux you must install gcc<br>If you are on window you must install mingw<br>How to use<br>Make sure you have .c or .cpp file open and press “F6”, this will compile the file. If you want to register gcc/g++ path manually you can set it under settings. You can also set to save file before compiling.</p></blockquote></li></ul><h4 id="第二种-手动添加task-json和launch-json"><a href="#第二种-手动添加task-json和launch-json" class="headerlink" title="第二种:手动添加task.json和launch.json"></a>第二种:手动添加task.json和launch.json</h4><ul><li><p>打开C++文件,切换到Debug下,运行一次,他会创建一个默认文件,改成如下即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(gdb) Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;build&quot;,  </span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后切回C++文件,<code>Ctrl + Shift + B</code> build &gt;&gt; 选择other新建一个 &gt;&gt; 修改tasks.json如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    &quot;version&quot;: &quot;0.1.0&quot;,  </span><br><span class="line">    &quot;showOutput&quot;: &quot;always&quot;,  </span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;taskName&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;g++&quot;,</span><br><span class="line">            &quot;isShellCommand&quot;: true,</span><br><span class="line">            &quot;showOutput&quot;: &quot;always&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$g++&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul><li><p><code>Ctrl + Shift + B</code> build</p></li><li><p>点击debug下的绿色箭头即可运行</p></li></ul><blockquote><p>愿天下再没有配环境的坑~</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;坑了一早上,终于摸索出两个编译运行C++的方法,特此记录.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑C++" scheme="https://fleschier.github.io/tags/%E0%B9%91C/"/>
    
      <category term="๑Ubuntu" scheme="https://fleschier.github.io/tags/%E0%B9%91Ubuntu/"/>
    
      <category term="๑VsCode" scheme="https://fleschier.github.io/tags/%E0%B9%91VsCode/"/>
    
  </entry>
  
  <entry>
    <title>Windows10蓝屏巨坑--已填</title>
    <link href="https://fleschier.github.io/2018/11/14/win10-problem-01/"/>
    <id>https://fleschier.github.io/2018/11/14/win10-problem-01/</id>
    <published>2018-11-14T09:40:00.000Z</published>
    <updated>2018-11-14T09:44:37.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="win10蓝屏问题"><a href="#win10蓝屏问题" class="headerlink" title="win10蓝屏问题"></a>win10蓝屏问题</h2><hr><ul><li>最近一个月也不知道干了啥,Windows有时候就是莫名其妙地蓝掉…内心无比崩溃</li></ul><blockquote><p>而且是我在玩Fortinite的时候无限崩…</p></blockquote><h2 id="问题规律"><a href="#问题规律" class="headerlink" title="问题规律"></a>问题规律</h2><hr><ul><li><p>最近在使用Android Studio开发, 但是莫名其妙就模拟器打不开, intel虚拟线程插件安装也报错,就很炸裂.</p></li><li><p>偶然间又打开了我的木木模拟器,结果马上蓝屏!!!</p></li><li><p>至此我发现了蓝屏的一点规律性—跟模拟器(虚拟化技术)有关!!</p></li></ul><h2 id="有了线索-问题便得以解决"><a href="#有了线索-问题便得以解决" class="headerlink" title="有了线索,问题便得以解决"></a>有了线索,问题便得以解决</h2><hr><ul><li><p>经过几番搜索和尝试, 最终锁定了问题的源泉—Windows服务–<strong>Hyper-V</strong></p></li><li><p>原来是Windows自己的虚拟化技术与别的虚拟化技术有冲突, 导致了蓝屏的问题.</p></li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><hr><ul><li>Ctrl+R -&gt; control.exe(控制面板) -&gt; 启动或关闭Windows功能 -&gt; 取消Hyper-V服务 -&gt;重启电脑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;win10蓝屏问题&quot;&gt;&lt;a href=&quot;#win10蓝屏问题&quot; class=&quot;headerlink&quot; title=&quot;win10蓝屏问题&quot;&gt;&lt;/a&gt;win10蓝屏问题&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;最近一个月也不知道干了啥,Windows有时候就是莫名其妙地蓝
      
    
    </summary>
    
      <category term="Computer System" scheme="https://fleschier.github.io/categories/Computer-System/"/>
    
    
      <category term="๑Windows" scheme="https://fleschier.github.io/tags/%E0%B9%91Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows10使用navicat链接mySQL错误</title>
    <link href="https://fleschier.github.io/2018/11/09/mySQL-download-windows/"/>
    <id>https://fleschier.github.io/2018/11/09/mySQL-download-windows/</id>
    <published>2018-11-09T01:40:00.000Z</published>
    <updated>2018-11-09T01:56:01.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><hr><ul><li><p>安装mysql8.0服务器端，连接Navicat会提示报错：<br><code>1251 Client does not support authentication protocol requested by server; consider upgrading MySQL client</code></p></li><li><p>网上一堆方法,但是很麻烦</p></li></ul><h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><hr><ul><li><p>最后终于发现了发生这种情况的根本原因,就是加密方式的更新.</p></li><li><p>由于最新版的MySQL安装的时候,推荐使用了一种最新的加密方式,就是在安装过程中,Authentication Method这一配置过程，给了两个基于不同的加密方式. 第一个是推荐的,当时我也没多想就选了第一个,所以才导致了后面的状况.</p></li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><hr><ul><li>再次打开mysql的安装程序,<em>这里不需要卸载重装</em>,选择更改设置, 将Authentication Method的加密方式改为第二个兼容加密方式就可以在navicat正确链接了.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;错误代码&quot;&gt;&lt;a href=&quot;#错误代码&quot; class=&quot;headerlink&quot; title=&quot;错误代码&quot;&gt;&lt;/a&gt;错误代码&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装mysql8.0服务器端，连接Navicat会提示报错：&lt;br&gt;&lt;code&gt;1251 Cli
      
    
    </summary>
    
      <category term="Docker" scheme="https://fleschier.github.io/categories/Docker/"/>
    
    
      <category term="๑Windows" scheme="https://fleschier.github.io/tags/%E0%B9%91Windows/"/>
    
      <category term="๑mySQL" scheme="https://fleschier.github.io/tags/%E0%B9%91mySQL/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="https://fleschier.github.io/2018/11/08/docker-learning-02/"/>
    <id>https://fleschier.github.io/2018/11/08/docker-learning-02/</id>
    <published>2018-11-08T12:40:00.000Z</published>
    <updated>2018-11-08T13:22:34.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>需要的docker image可以从Docker Hub获取</p></blockquote><h2 id="Docker-images"><a href="#Docker-images" class="headerlink" title="Docker images"></a>Docker images</h2><hr><ul><li><p>Docker images文件: Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p></li><li><p>查看本机的image文件:<code>docker image ls</code></p></li><li><p>删除某个image:<code>docker image rm [imageName]</code></p></li></ul><h3 id="获取image"><a href="#获取image" class="headerlink" title="获取image"></a>获取image</h3><ul><li><code>docker image pull 仓库路径/文件名</code></li></ul><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul><li><p><code>docker container run containID</code></p></li><li><p>可以先用<code>docker image ls</code>查看所有的镜像文件. 同时<code>docker container run</code>当本地仓库不存在相对应的image时,会自动从远程仓库获取,所以上面pull的一步不是必须的.</p></li></ul><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><ul><li>有些容器需要手动终止,使用命令:<code>docker container kill containID</code></li></ul><h2 id="Docker-container"><a href="#Docker-container" class="headerlink" title="Docker container"></a>Docker container</h2><hr><ul><li><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行。</p></li><li><p>列出正在运行的容器:<code>docker container ls</code></p></li><li><p>列出所有的容器: <code>docker container ls --all</code></p></li></ul><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><ul><li><p><code>docker container rm containerID</code></p></li><li><p>删除之后的容器不会再出现在容器列表里</p></li></ul><h2 id="创建自己的docker容器"><a href="#创建自己的docker容器" class="headerlink" title="创建自己的docker容器"></a>创建自己的docker容器</h2><hr><ul><li>待更新</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><hr><ul><li><p><strong>注意</strong>,<code>docker container run</code>命令是创建一个container,每运行一次就会多一个容器,如果要重复使用一个容器需要用:<code>docker container start</code></p></li><li><p>查看容器的输出,即容器里面shell的标准输出:<code>docker container logs containerID</code>. 如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p></li><li><p>进入一个正在运行的容器:<code>docker container exec -it containerID /bin/bash</code>.如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的Shell执行命令了。</p></li><li><p>从容器中拷贝文件到本地:<code>$ docker container cp containID:[/path/to/file] [/dest/path/]</code>. 如果要拷贝到当前目录,则可以写为:<code>$ docker container cp [containID]:[/path/to/file] .</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;需要的docker image可以从Docker Hub获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Docker-images&quot;&gt;&lt;a href=&quot;#Docker-images&quot; class=&quot;headerlink&quot; title=&quot;D
      
    
    </summary>
    
      <category term="Docker" scheme="https://fleschier.github.io/categories/Docker/"/>
    
    
      <category term="๑Ubuntu" scheme="https://fleschier.github.io/tags/%E0%B9%91Ubuntu/"/>
    
      <category term="๑Docker" scheme="https://fleschier.github.io/tags/%E0%B9%91Docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18 安装Docker</title>
    <link href="https://fleschier.github.io/2018/11/08/docker-learning-01/"/>
    <id>https://fleschier.github.io/2018/11/08/docker-learning-01/</id>
    <published>2018-11-08T10:40:00.000Z</published>
    <updated>2018-11-08T12:59:37.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么用Docker"><a href="#为什么用Docker" class="headerlink" title="为什么用Docker"></a>为什么用Docker</h2><hr><ul><li><p>环境搭建一直是运维一件非常头疼的事情, 如果系统崩溃而重新安装系统,则所有的环境都需要重新搭建一遍,非常耗时而且恼人.</p></li><li><p>我使用的Ubuntu18下配置好了大量的环境,如果这时候要我重新安装一遍的话,就算我做了详细的记录,也至少是一下午的工作量.</p></li><li><p>而Docker相当于一个容器,与虚拟机不同,虚拟机模拟了一个完整的操作系统,非常消耗系统资源,而且就算不做任何操作,内存也必须被占用.而Docker是容器,基于Linux容器的概念,封装而成.</p></li><li><p>Docker将运行在其中的软件隔离开来, 不占用额外的系统资源.</p></li><li><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p></li></ul><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><hr><ul><li>Docker Hub是一个平台,注册之后我们可以下载使用别人搭建好的image,非常方便.</li></ul><h2 id="Ubuntu18安装Docker"><a href="#Ubuntu18安装Docker" class="headerlink" title="Ubuntu18安装Docker"></a>Ubuntu18安装Docker</h2><hr><ul><li><p>由于Docker被墙得厉害,导致经常性地连官网也进不去.</p></li><li><p>我们为了安装过程的顺利,首先切换到中国科技大的源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i &apos;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&apos; /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li><li><p>安装需要的包:<code>sudo apt install apt-transport-https ca-certificates software-properties-common curl</code></p></li><li><p>添加 GPG 密钥，并添加 Docker-ce 软件源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line">$(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure></li><li><p>更新缓存:<code>sudo apt update</code></p></li><li><p>安装Docker-ce:<code>sudo apt install docker-ce</code></p></li><li><p>测试Helloworld:<code>sudo docker run hello-world</code></p></li><li><p>结果:<br><img src="/images/Docker/docker-01.png" alt></p></li><li><p>添加当前用户到 docker 用户组，可以不用 sudo 运行 docker:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure></li></ul><h2 id="docker-pull之后文件的存放目录"><a href="#docker-pull之后文件的存放目录" class="headerlink" title="docker pull之后文件的存放目录"></a>docker pull之后文件的存放目录</h2><hr><ul><li><p>使用<code>docker pull XXX</code>下载的文件存放在<code>/var/lib/docker/</code>中</p></li><li><p>其中目录结构如下:<br><img src="/images/Docker/docker-02.png" alt></p></li><li><p><code>containers</code>中每个序列号都是一个镜像</p></li><li><p>Docker是使用repositories JSON文件来记述镜像信息的，此JSON文件包含了仓库名、标签、以及标签对应的镜像ID。</p></li></ul><h2 id="Uninstall-Docker-ce"><a href="#Uninstall-Docker-ce" class="headerlink" title="Uninstall Docker-ce"></a>Uninstall Docker-ce</h2><hr><blockquote><p>摘自官方文档</p></blockquote><ul><li><p>Uninstall the Docker CE package:<code>sudo apt-get purge docker-ce</code></p></li><li><p>Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:<code>sudo rm -rf /var/lib/docker</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么用Docker&quot;&gt;&lt;a href=&quot;#为什么用Docker&quot; class=&quot;headerlink&quot; title=&quot;为什么用Docker&quot;&gt;&lt;/a&gt;为什么用Docker&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;环境搭建一直是运维一件非常头疼的事情, 如果系统
      
    
    </summary>
    
      <category term="Docker" scheme="https://fleschier.github.io/categories/Docker/"/>
    
    
      <category term="๑Ubuntu" scheme="https://fleschier.github.io/tags/%E0%B9%91Ubuntu/"/>
    
      <category term="๑Docker" scheme="https://fleschier.github.io/tags/%E0%B9%91Docker/"/>
    
  </entry>
  
  <entry>
    <title>网页状态码记录</title>
    <link href="https://fleschier.github.io/2018/11/07/web-learning-01/"/>
    <id>https://fleschier.github.io/2018/11/07/web-learning-01/</id>
    <published>2018-11-07T14:30:00.000Z</published>
    <updated>2018-11-07T14:29:00.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><hr><ul><li>五个不同的类别:<br>　　1. <code>1XX</code>临时/信息响应<br>　　2. <code>2XX</code>成功<br>　　3. <code>3XX</code>重定向<br>　　4. <code>4XX</code>客户端/请求错误<br>　　5. <code>5XX</code>服务器错误<blockquote><p>五个类别的响应状态代码的第一个数字是唯一代表。</p></blockquote></li></ul><h3 id="4XX-服务器外部错误"><a href="#4XX-服务器外部错误" class="headerlink" title="4XX 服务器外部错误"></a>4XX 服务器外部错误</h3><h4 id="400"><a href="#400" class="headerlink" title="400"></a>400</h4><ul><li>400 无法解析此请求。说明正在搜索的网页可能已经删除、更名或暂时不可用。</li></ul><h4 id="401-X"><a href="#401-X" class="headerlink" title="401.X"></a>401.X</h4><ul><li>401.1 未经授权：访问由于凭据无效被拒绝。说明没有权限查看该目录或网页。</li><li><p>401.2 未经授权: 访问由于服务器配置倾向使用替代身份验证方法而被拒绝。<br><code>由于服务器配置问题而导致登陆失败，由于服务器端脚本未能正确发送 WWW 身份验证头文件字段。如果要通过 Active Server Pages 脚本完成此项任务，可以使用&quot;Response&quot;对象的&quot;AddHeader&quot;方法来要求客户端用特定身份验证方法访问资源。</code></p></li><li><p>401.3 未经授权：访问由于 ACL 对所请求资源的设置被拒绝。</p></li><li><p>401.4 未经授权：Web 服务器上安装的筛选器授权失败。<br><code>如果Web 服务器安装了筛选器程序以检查连接到服务器的用户。该筛选器程序能够禁止通过连接到服务器的身份验证来访问资源。</code></p></li><li><p>401.5 未经授权：ISAPI/CGI 应用程序授权失败。<br><code>由于 ISAPI/CGI 应用程序导致授权失败。如果所要访问的 Web 服务器地址上安装了 ISAPI 或 CGI 程序用于在继续执行之前检验用户证书。该程序能够禁止通过连接到服务器的身份验证证书来访问资源。</code></p></li><li><p>401.7 未经授权：由于 Web 服务器上的 URL 授权策略而拒绝访问。</p></li></ul><h4 id="403-X"><a href="#403-X" class="headerlink" title="403.X"></a>403.X</h4><ul><li>403 禁止访问：访问被拒绝。</li><li><p>403.1 禁止访问：执行访问被拒绝。<br><code>由于&quot;执行&quot;访问被禁止而造成的，若试图从目录中执行 CGI、ISAPI 或其他可执行程序，但该目录不允许执行程序时便会出现此种错误。</code></p></li><li><p>403.2 禁止访问：读取访问被拒绝。<br><code>导致此错误是由于没有可用的默认网页并且没有对目录启用目录浏览，或者要显示的 HTML 网页所驻留的目录仅标记为&quot;可执行&quot;或&quot;脚本&quot;权限。</code></p></li><li><p>403.3 禁止访问：写入访问被拒绝。<br><code>当试图将文件上载到目录或在目录中修改文件，但该目录不允许&quot;写&quot;访问时就会出现此种错误。</code></p></li><li><p>403.4 禁止访问：需要使用 SSL 查看该资源。<br><code>由于要求SSL而造成的，您必须在要查看的网页的地址中使用&quot;https&quot;。</code></p></li><li><p>403.5 禁止访问：需要使用 SSL 128 查看该资源。<br><code>由于要求使用 128 位加密算法的 Web 浏览器而造成的，如果您的浏览器不支持128位加密算法就会出现这个错误，您可以连接微软网站进行浏览器升级。</code></p></li><li><p>403.6 禁止访问：客户端的 IP 地址被拒绝。<br><code>如果服务器中有不能访问该站点的 IP 地址列表，并且您使用的 IP 地址在该列表中时您就会返回这条错误信息。</code></p></li><li><p>403.7 禁止访问：需要 SSL 客户端证书。</p></li><li><p>403.8 禁止访问：客户端的 DNS 名称被拒绝。<br><code>由于禁止站点访问而造成的，若服务器中有不能访问该站点的 DNS 名称列表，而您使用的 DNS 名称在列表中时就会返回此种信息。请注意区别403.6与403.8错误。</code></p></li><li><p>403.9 禁止访问：太多客户端试图连接到 Web 服务器。<br><code>由于连接的用户过多而造成的，由于Web 服务器很忙，因通讯量过多而无法处理请求时便会返回这条错误。</code></p></li><li><p>403.10 禁止访问：Web 服务器配置为拒绝执行访问。<br><code>由于无效配置而导致的错误，当您试图从目录中执行 CGI、ISAPI 或其他可执行程序，但该目录不允许执行程序时便会返回这条错误。</code></p></li><li><p>403.11 禁止访问：密码已更改。</p></li><li><p>403.12 禁止访问：服务器证书映射器拒绝了客户端证书访问。<br><code>由于映射器拒绝访问而造成的。若要查看的网页要求使用有效的客户证书，而您的客户证书映射没有权限访问该 Web 站点时就会返回映射器拒绝访问的错误。</code></p></li><li><p>403.13 禁止访问：客户端证书已在 Web 服务器上吊销。<br><code>由于需要查看的网页要求使用有效的客户证书而使用的客户证书已经被吊销，或者无法确定证书是否已吊销造成的。</code></p></li><li><p>403.14 禁止访问：在 Web 服务器上已拒绝目录列表。</p></li><li>403.15 禁止访问：Web 服务器已超过客户端访问许可证限制。</li><li>403.16 禁止访问：客户端证书格式错误或未被 Web 服务器信任。</li><li>403.17 禁止访问：客户端证书已经到期或者尚未生效。</li><li>403.18 禁止访问：无法在当前应用程序池中执行请求的 URL。</li><li>403.19 禁止访问：无法在该应用程序池中为客户端执行 CGI。</li><li>403.20 禁止访问：Passport 登录失败。</li></ul><h4 id="404-X"><a href="#404-X" class="headerlink" title="404.X"></a>404.X</h4><ul><li><p>404 找不到文件或目录。<br><code>由于无法找到文件而造成的，通常是由于正在搜索的网页可能已经删除、更名或暂时不可用。</code></p></li><li><p>404.1 文件或目录未找到：网站无法在所请求的端口访问。<br><code>表明所访问 Web 站点的 IP 地址不接受对端口（请求的来源端口）的请求。404.1 错误只会出现在具有多个 IP 地址的计算机上。如果在特定 IP 地址/端口组合上收到客户端请求，而且没有将 IP 地址配置为在该特定的端口上侦听，则 IIS 返回 404.1 HTTP 错误。例如，如果一台计算机有两个 IP 地址，而只将其中一个 IP 地址配置为在端口 80 上侦听，则另一个 IP 地址从端口 80 收到的任何请求都将导致 IIS 返回 404.1 错误。只应在此服务级别设置该错误，因为只有当服务器上使用多个 IP 地址时才会将它返回给客户端。</code></p></li><li><p>404.2 文件或目录无法找到：锁定策略禁止该请求。</p></li><li>404.3 文件或目录无法找到：MIME 映射策略禁止该请求。</li></ul><h4 id="else"><a href="#else" class="headerlink" title="else"></a>else</h4><ul><li><p>405 用于访问该页的 HTTP 动作未被许可。<br><code>由于资源被禁止而导致的网页地址不正确，因此要寻找的网页无法显示。</code></p></li><li><p>406 客户端浏览器不接受所请求页面的 MIME 类型。<code>由于浏览器无法打开正在寻找的资源而导致的错误。</code></p></li><li><p>407 Web 服务器需要初始的代理验证。</p></li><li>410 要寻找的网页已被永久删除而导致的，这意味着资源永远无法使用。</li><li><p>412 客户端设置的前提条件在 Web 服务器上评估时失败。<br><code>412错误是由于要查看的网页设置有先决条件，因此该请求无法完成。一般是网页中有一个或多个请求标题字段中具有先决条件，这些字段经服务器测试后被认为是&quot;FALSE&quot;。客户端为当前资源的 meta 信息（头文件字段数据）设置了先决条件，以便防止请求的方法被用于指定资源外的其他资源。</code></p></li><li><p>414 请求 URL 太大，因此在 Web 服务器上不接受该 URL。<br><code>一般的可能性有： 1）客户端错误地将 POST 请求转换为带有长查询信息的 GET 请求。 2）或者是客户端遇到重定向问题（例如，重定向 URL 的前缀指向自身的后缀）。 3）服务器遭到客户端的攻击，该客户端试图利用那些使用定长缓冲来读取或控制请求 URI 的服务器上的安全漏洞。</code></p></li></ul><h3 id="5XX-服务器内部错误"><a href="#5XX-服务器内部错误" class="headerlink" title="5XX 服务器内部错误"></a>5XX 服务器内部错误</h3><ul><li>500 服务器内部错误。</li><li>500.11 服务器错误：Web 服务器上的应用程序正在关闭。</li><li>500.12 服务器错误：Web 服务器上的应用程序正在重新启动。</li><li>500.13 服务器错误：Web 服务器太忙。</li><li>500.14 服务器错误：服务器上的无效应用程序配置。</li><li>500.15 服务器错误：不允许直接请求 GLOBAL.ASA。</li><li>500.16 服务器错误：UNC 授权凭据不正确。</li><li>500.17 服务器错误：URL 授权存储无法找到。</li><li>500.18 服务器错误：URL 授权存储无法打开。</li><li>500.19 服务器错误：该文件的数据在配置数据库中配置不正确。</li><li>500.20 服务器错误：URL 授权域无法找到。</li><li>500-100.asp 内部服务器错误：ASP 错误。</li><li><p>501 标题值指定的配置没有执行。</p></li><li><p>502 Web 服务器作为网关或代理服务器时收到无效的响应。<br><code>由于网关错误而造成的，当作为网关或代理的服务器与上层内容服务器联络时，收到无效的响应时就会出现502错误。</code></p></li><li><p>参考 <a href="https://blog.csdn.net/aaa_aa000/article/details/46997991" target="_blank" rel="noopener">https://blog.csdn.net/aaa_aa000/article/details/46997991</a></p></li><li><p>参考<a href="https://www.jianshu.com/p/d50bcc605a13" target="_blank" rel="noopener">https://www.jianshu.com/p/d50bcc605a13</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP状态码&quot;&gt;&lt;a href=&quot;#HTTP状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP状态码&quot;&gt;&lt;/a&gt;HTTP状态码&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;五个不同的类别:&lt;br&gt;　　1. &lt;code&gt;1XX&lt;/code&gt;临时/信息响
      
    
    </summary>
    
      <category term="Web Security" scheme="https://fleschier.github.io/categories/Web-Security/"/>
    
    
      <category term="๑Web" scheme="https://fleschier.github.io/tags/%E0%B9%91Web/"/>
    
      <category term="๑Security" scheme="https://fleschier.github.io/tags/%E0%B9%91Security/"/>
    
  </entry>
  
  <entry>
    <title>Maven构建项目的pom.xml文件详解</title>
    <link href="https://fleschier.github.io/2018/11/07/Maven-learning-02/"/>
    <id>https://fleschier.github.io/2018/11/07/Maven-learning-02/</id>
    <published>2018-11-07T12:50:00.000Z</published>
    <updated>2018-11-21T06:40:40.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><hr><ul><li><p>Maven仓库分为本地仓库,中央仓库和远程仓库.</p></li><li><p>中央仓库可以查询和获取大量常用的库—-<a href="https://search.maven.org/#browse" target="_blank" rel="noopener">地址</a></p></li><li><p>远程仓库是当我们在中央仓库也获取不到需要的库时,才会用到的. 一般也不会用到远程仓库.</p></li></ul><h3 id="仓库搜索顺序"><a href="#仓库搜索顺序" class="headerlink" title="仓库搜索顺序"></a>仓库搜索顺序</h3><ul><li>首先,maven会在本地仓库中搜索依赖的库,如果没有就去中央仓库,如果中央仓库也找不到,但是pom文件里设置了远程仓库,则去远程仓库中获取,否则就会报错,找不到依赖的文件.</li></ul><h2 id="Maven项目的创建"><a href="#Maven项目的创建" class="headerlink" title="Maven项目的创建"></a>Maven项目的创建</h2><hr><ul><li><p>我们一般使用intellij IDEA来创建maven项目</p></li><li><p>其中的gourpId一般的命名格式为: 组织名，公司网址的反写 + 项目名称</p></li></ul><h3 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h3><ul><li><p>Maven 使用 <strong>archetype(原型)</strong> 来创建自定义的项目结构，形成 Maven 项目模板。</p></li><li><p>我们在intellij IDEA中新建maven项目时,可以选择从创建一个archetype,这样maven会自动为pom.xml文件添加一些dependency</p></li></ul><h2 id="Maven快照-SNAPSHOT"><a href="#Maven快照-SNAPSHOT" class="headerlink" title="Maven快照(SNAPSHOT)"></a>Maven快照(SNAPSHOT)</h2><hr><ul><li><p>快照是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，Maven 每次构建都会在远程仓库中检查新的快照。</p><blockquote><p>对于版本，如果 Maven 以前下载过指定的版本文件，比如说 data-service:1.0，Maven 将不会再从仓库下载新的可用的 1.0 文件。若要下载更新的代码，data-service 的版本需要升到1.1。<br>快照的情况下，每次快照的更新，Maven 将自动获取最新的快照(data-service:1.0-SNAPSHOT)。</p></blockquote></li><li><p>快照和版本是用于团队开发时的,快照是为了避免频繁地手动更新pom文件,也避免了版本号的滥用.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Maven仓库&quot;&gt;&lt;a href=&quot;#Maven仓库&quot; class=&quot;headerlink&quot; title=&quot;Maven仓库&quot;&gt;&lt;/a&gt;Maven仓库&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Maven仓库分为本地仓库,中央仓库和远程仓库.&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑Maven" scheme="https://fleschier.github.io/tags/%E0%B9%91Maven/"/>
    
      <category term="๑Apache" scheme="https://fleschier.github.io/tags/%E0%B9%91Apache/"/>
    
  </entry>
  
  <entry>
    <title>Maven构建项目的pom.xml主要标签解释</title>
    <link href="https://fleschier.github.io/2018/11/07/Maven-learning/"/>
    <id>https://fleschier.github.io/2018/11/07/Maven-learning/</id>
    <published>2018-11-07T12:46:00.000Z</published>
    <updated>2018-11-21T06:40:40.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven-pom-xml文件标签详解"><a href="#Maven-pom-xml文件标签详解" class="headerlink" title="Maven pom.xml文件标签详解"></a>Maven pom.xml文件标签详解</h2><hr><blockquote><p><a href="http://www.runoob.com/maven/maven-pom.html" target="_blank" rel="noopener">菜鸟教程-maven标签详解</a>,为了方便记录到自己的博客下.</p></blockquote><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><hr><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>project</td><td>工程的根标签</td></tr><tr><td>modelVersion</td><td>模型版本,一般设为4.0</td></tr><tr><td>groupId</td><td>工程组的标志,一个项目或者一个组织一般是唯一的</td></tr><tr><td>artifaciId</td><td>工程标识,是工程的名称</td></tr><tr><td>version</td><td>工程版本号,在artifact的仓库中用来区分不同的版本</td></tr><tr><td>build</td><td>该元素设置了项目脚本的源码目录,当构建项目的时候,构建系统会编译目录里的源码,该路径相对于pom.xml是相对路径</td></tr><tr><td>dependencies</td><td>该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。</td></tr><tr><td>dependency</td><td>上个标签的子目录,一个dependency包含一个依赖</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Maven-pom-xml文件标签详解&quot;&gt;&lt;a href=&quot;#Maven-pom-xml文件标签详解&quot; class=&quot;headerlink&quot; title=&quot;Maven pom.xml文件标签详解&quot;&gt;&lt;/a&gt;Maven pom.xml文件标签详解&lt;/h2&gt;&lt;hr&gt;

      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑Maven" scheme="https://fleschier.github.io/tags/%E0%B9%91Maven/"/>
    
      <category term="๑Apache" scheme="https://fleschier.github.io/tags/%E0%B9%91Apache/"/>
    
  </entry>
  
  <entry>
    <title>gitignore的使用及写法</title>
    <link href="https://fleschier.github.io/2018/10/27/gitignore-learning/"/>
    <id>https://fleschier.github.io/2018/10/27/gitignore-learning/</id>
    <published>2018-10-27T10:32:00.000Z</published>
    <updated>2018-10-30T15:39:43.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gitignore的作用"><a href="#gitignore的作用" class="headerlink" title="gitignore的作用"></a>gitignore的作用</h2><hr><ul><li><p>对于git同步到github来说，估计没有人会 <code>git add 文件名</code>这样的方式来添加到工作区的，都是<code>git add .</code>这样一次添加吧</p></li><li><p>但是，有时候我们直接add所有的文件会将一些我们不需要的生成的临时文件也加入进去，导致文件冗余。同时，更有可能的是我们在push的时候失败，由于一些不支持的文件类型或者文件大小过大。</p></li><li><p>这时候我们就需要gitignore脚本来过滤我们需要上传的文件。</p></li></ul><h2 id="命名格式以及位置"><a href="#命名格式以及位置" class="headerlink" title="命名格式以及位置"></a>命名格式以及位置</h2><hr><ul><li><p>命名统一为<code>.gitignore</code></p></li><li><p>windows下由于不能文件名为空，则可以先命名为<code>.gitignore.</code>，回车确定之后windows会自动将最后一个点去掉。</p></li><li><p><code>.gitignore</code>文件放在根目录下即可。</p></li></ul><h2 id="内容写法"><a href="#内容写法" class="headerlink" title="内容写法"></a>内容写法</h2><hr><ul><li>gitignore本质上是一个按正则表达式匹配文件名/文件夹名的文件。</li></ul><h3 id="语法：-与正则表达式几乎一致"><a href="#语法：-与正则表达式几乎一致" class="headerlink" title="语法：(与正则表达式几乎一致)"></a>语法：(与正则表达式几乎一致)</h3><ul><li><p>空行或是以<code>#</code>开头的行即注释行将被忽略</p></li><li><p>以斜杠 <code>/</code>结尾表示目录</p></li><li><p>以星号<code>*</code>通配多个字符</p></li><li><p>以问号 <code>?</code> 通配单个字符</p></li><li><p>以方括号 <code>[]</code> 包含单个字符的匹配列表</p></li><li><p>以叹号 <code>!</code> 表示不忽略(跟踪)匹配到的文件或目录</p></li><li><p><a href="https://www.cnblogs.com/jingtyu/p/6831772.html" target="_blank" rel="noopener">参考</a></p></li></ul><h2 id="添加github仓库"><a href="#添加github仓库" class="headerlink" title="添加github仓库"></a>添加github仓库</h2><hr><ul><li>github上有一个为各种环境和编程语言提供gitignore模板的项目——<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></li></ul><blockquote><p>他的项目介绍是：This is GitHub’s collection of .gitignore file templates. We use this list to populate the .gitignore template choosers available in the GitHub.com interface when creating new repositories and files.(意思大概就是可以用它来实现在创建repository的时候可以选择初始化一个.gitignore文件，并且可以选择一个模板)</p></blockquote><ul><li>我们在创建github仓库的时候尽量先预先创建好.gitignore文件，因为一旦push之后，添加了新的.gitignore貌似也是不起作用的，非常麻烦，所以要养成写.gitignore的好习惯。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gitignore的作用&quot;&gt;&lt;a href=&quot;#gitignore的作用&quot; class=&quot;headerlink&quot; title=&quot;gitignore的作用&quot;&gt;&lt;/a&gt;gitignore的作用&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于git同步到github来说
      
    
    </summary>
    
      <category term="Computer" scheme="https://fleschier.github.io/categories/Computer/"/>
    
    
      <category term="๑Git" scheme="https://fleschier.github.io/tags/%E0%B9%91Git/"/>
    
      <category term="๑Ubuntu" scheme="https://fleschier.github.io/tags/%E0%B9%91Ubuntu/"/>
    
      <category term="๑Linux" scheme="https://fleschier.github.io/tags/%E0%B9%91Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18 Pycharm无法识别安装的Python库的解决方案</title>
    <link href="https://fleschier.github.io/2018/10/16/pycharm-problem-solving/"/>
    <id>https://fleschier.github.io/2018/10/16/pycharm-problem-solving/</id>
    <published>2018-10-15T16:47:00.000Z</published>
    <updated>2018-11-21T06:40:40.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>凌晨更~</p></blockquote><h2 id="pycahrm无法识别"><a href="#pycahrm无法识别" class="headerlink" title="pycahrm无法识别"></a>pycahrm无法识别</h2><hr><ul><li><p>我们有时候在需要使用一些第三方python库的时候，需要<code>pip install XXX</code>，然而愉快地安装完了之后，在pycharm中新建项目<code>import</code>却失败，提示找不到。</p></li><li><p>这个问题坑了好久，在终端里使用完全没有问题然而pycahrm里却不行。今天终于下定决心搞定这个问题。</p></li></ul><h2 id="首先从默认python版本下手"><a href="#首先从默认python版本下手" class="headerlink" title="首先从默认python版本下手"></a>首先从默认python版本下手</h2><hr><ul><li><p>由于我使用的是ubuntu18.04，其默认的python版本是python2.7，而我在IDE里使用的是后来安装的python3.6版本，因此pip install的module不会被识别(<em>因为终端里<code>pip install</code> 命令使用的解释器版本是2.7，安装的module也只能被2.7版本的识别</em>)</p></li><li><p>首先执行<code>python --version</code>查看当前默认版本</p></li><li><p>然后查看当前已安装的所有版本<code>ls /usr/bin/python*</code></p></li><li><p>接着修改系统信息：(<strong>需要管理员权限</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@fleschier-GE5S:/home/fleschier# update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br><span class="line">root@fleschier-GE5S:/home/fleschier# update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2</span><br><span class="line">update-alternatives: 使用 /usr/bin/python3.6 来在自动模式中提供 /usr/bin/python (python)</span><br></pre></td></tr></table></figure></li></ul><p><code>--install</code> 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 <code>/usr/bin/python3.6</code> 设置的优先级为2，所以<code>update-alternatives</code> 命令会自动将它设置为默认 Python 版本。</p><ul><li>参考<a href="https://blog.csdn.net/fang_chuan/article/details/60958329" target="_blank" rel="noopener">更改Ubuntu默认python版本的两种方法</a></li></ul><h3 id="一个坑接着一个坑"><a href="#一个坑接着一个坑" class="headerlink" title="一个坑接着一个坑"></a>一个坑接着一个坑</h3><ul><li><p>默认python版本改完了，下面就是<code>pip</code>了</p></li><li><p>改完之后会发现，执行<code>pip</code>命令会提示没有这个module。。。好吧又是坑</p></li><li><p>解决方案：<code>sudo apt-get install python3-pip</code></p></li><li><p>安装完成然后就可以使用pip的一系列命令了</p></li></ul><h3 id="更新pip版本"><a href="#更新pip版本" class="headerlink" title="更新pip版本"></a>更新pip版本</h3><ul><li><p><code>python -m pip install --upgrade pip</code></p></li><li><p>参考<a href="https://stackoverflow.com/questions/18363022/importerror-no-module-named-pip" target="_blank" rel="noopener">stackoverflow的一个问题</a></p></li></ul><h2 id="然后就是重新安装我们需要的库了"><a href="#然后就是重新安装我们需要的库了" class="headerlink" title="然后就是重新安装我们需要的库了"></a>然后就是重新安装我们需要的库了</h2><hr><ul><li><p>我这里要搞一个python绘图，需要matplotlib库</p></li><li><p>按照其官方的安装方法(<em>仍然需要管理员权限否则最后一步会失败提示权限不够</em>):<code>python -m pip install -U matplotlib</code></p></li><li><p>或者是一般的安装<code>pip3 install moduleName</code></p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><hr><ul><li>最后就是网上烂大街的解决方法，指定pycharm的编译器为python3.x，即可～</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;凌晨更~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;pycahrm无法识别&quot;&gt;&lt;a href=&quot;#pycahrm无法识别&quot; class=&quot;headerlink&quot; title=&quot;pycahrm无法识别&quot;&gt;&lt;/a&gt;pycahrm无法识别&lt;/h
      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑Python" scheme="https://fleschier.github.io/tags/%E0%B9%91Python/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记——强大的sprintf</title>
    <link href="https://fleschier.github.io/2018/10/08/C++-sprintf-printf/"/>
    <id>https://fleschier.github.io/2018/10/08/C++-sprintf-printf/</id>
    <published>2018-10-08T14:43:00.000Z</published>
    <updated>2018-11-21T06:40:17.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sprintf-函数与printf-函数"><a href="#sprintf-函数与printf-函数" class="headerlink" title="sprintf()函数与printf()函数"></a>sprintf()函数与printf()函数</h2><hr><ul><li><p><code>sprintf()</code>函数与<code>printf()</code>函数的用法几乎一样。只是前者是将内容打印到字符串中，后者直接在命令行打印出来。</p></li><li><p><code>sprintf()</code>函数原型： <code>int sprintf( char *buffer, const char *format [, argument] ... );</code> 除了前两个参数固定，后面可以接任意多个参数。</p></li><li><p>第二个参数为格式化字符串，<code>printf</code> 和<code>sprintf</code> 都使用格式化字符串来指定串的格式，以<code>%</code>开头，然后在后边的变参列表中提供相应的变量，最终相应的位置的变量就会被替换进来。</p></li></ul><ul><li><p><code>sprintf</code>最常见的应用之一莫过于把整数打印到字符串中，所以，<code>spritnf</code> 在大多数场合可以替代<code>itoa</code>。</p></li><li><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sprintf(s, &quot;%d&quot;, 123);</span><br><span class="line">sprintf(s, &quot;%8d%8d&quot;, 123, 5678);  //指定宽度，不足的左边补空格，结果为&quot; 123 5678&quot;</span><br></pre></td></tr></table></figure></li><li><p>浮点数用<code>%f</code>控制，默认打印6位小数。</p></li><li><p>使用<code>%d</code>或者<code>%x</code>打印一个字符，便能得出它的10进制或16进制的ASCII码；反过来，使用<code>%c</code>打印一个整数，便可以看到它所对应的ASCII字符。<strong>因为char类型本质上也是存储数值类型，只是习惯上用char来表示字符，实际上char就是byte，一个字节的数值类型。</strong></p></li><li><p><a href="http://lib.csdn.net/article/cplusplus/29221" target="_blank" rel="noopener">实现各种各样格式化字符串</a></p></li><li><p><code>sprinf</code>就是将格式化字符串里的所有内容打印到第一个参数(字符数组)中，因此也可以用来连接字符串，非常灵活。</p></li><li><p><code>spritnf</code>和<code>printf</code>都最终返回本次函数调用最终打印到字符缓冲区中的字符数目。</p></li></ul><h2 id="转换说明符"><a href="#转换说明符" class="headerlink" title="转换说明符"></a>转换说明符</h2><hr><h3 id="格式符"><a href="#格式符" class="headerlink" title="格式符"></a>格式符</h3><table><thead><tr><th>格式符</th><th>说明</th></tr></thead><tbody><tr><td>%a(%A)</td><td>浮点数、十六进制数字和p-(P-)记数法(C99)</td></tr><tr><td>%c</td><td>字符</td></tr><tr><td>%d</td><td>有符号十进制整数</td></tr><tr><td>%f</td><td>浮点数(包括float和doulbe)</td></tr><tr><td>%e(%E)</td><td>浮点数指数输出[e-(E-)记数法]</td></tr><tr><td>%g(%G)</td><td>浮点数不显无意义的零”0”</td></tr><tr><td>%i</td><td>有符号十进制整数(与%d相同)</td></tr><tr><td>%u</td><td>无符号十进制整数</td></tr><tr><td>%o</td><td>八进制整数</td></tr><tr><td>%x(%X)</td><td>十六进制整数0f(0F)</td></tr><tr><td>%p</td><td>指针</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%%</td><td>输出字符%</td></tr></tbody></table><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><table><thead><tr><th>标志</th><th>例子(说明)</th></tr></thead><tbody><tr><td>左对齐：”-“</td><td>%-20s</td></tr><tr><td>右对齐：”+”</td><td>%+20s</td></tr><tr><td>空格</td><td>若符号为正，则显示空格，负则显示”-“  比如：”% 6.2f”</td></tr><tr><td>#</td><td>对c,s,d,u类无影响；对o类，在输出时加前缀o；对x类，在输出时加前缀0x；对e,g,f 类当结果有小数时才给出小数点。</td></tr></tbody></table><h2 id="sprintf使用过程中遇到的一些问题记录"><a href="#sprintf使用过程中遇到的一些问题记录" class="headerlink" title="sprintf使用过程中遇到的一些问题记录"></a>sprintf使用过程中遇到的一些问题记录</h2><hr><h3 id="编译器报错：Buffer-is-too-small"><a href="#编译器报错：Buffer-is-too-small" class="headerlink" title="编译器报错：Buffer is too small"></a>编译器报错：<code>Buffer is too small</code></h3><ul><li><p>出现这个情况是因为被赋值的字符数组太小了。</p></li><li><p>实例：(矩阵乘积)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//计算矩阵的乘积</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">char tmpc[24];//存储转换的值,因为存储的是双精度浮点数，这里数据的整数部分为10位，小数部分要显示11位则至少开10+1+11=22位的数组才够</span><br><span class="line">for (int i = 0; i &lt; M; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">C[i][j] = 0;//initialize the result martrix element</span><br><span class="line">for (int k = 0; k &lt; K; k++) &#123;</span><br><span class="line">C[i][j] += A[i][k] * B[k][j];</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------------------------------------------------</span><br><span class="line">//itoa不如sprintf灵活，这里采用sprintf来完成double到char的转换</span><br><span class="line">////将数字转化为char数组写入, 采用itoa函数。函数原型：char *itoa(int value, char* string, int radix);</span><br><span class="line">//_itoa(C[i][j], tmpc, 10);</span><br><span class="line">//fputs(tmpc, fout);//fputs的第一个参数为char*</span><br><span class="line">//fputc(32, fout);//写入空格，fputc的第一个参数为int*(ASCII码)</span><br><span class="line">//---------------------------------------------------------------------------------------------</span><br><span class="line">//使用强大的sprintf来完成转换，打印11位小数</span><br><span class="line">sprintf_s(tmpc, &quot;%.11f &quot;, C[i][j]);//这里的数值是整数部分10位，小数点一位，小数部分11位，末尾空格1位，结束符&apos;\0&apos;一位所以一共要开24位的数组才够</span><br><span class="line">fputs(tmpc, fout);//fputs的第一个参数为char*</span><br><span class="line">&#125;</span><br><span class="line">fputc(10, fout);//写入换行符</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sprintf-函数与printf-函数&quot;&gt;&lt;a href=&quot;#sprintf-函数与printf-函数&quot; class=&quot;headerlink&quot; title=&quot;sprintf()函数与printf()函数&quot;&gt;&lt;/a&gt;sprintf()函数与printf()函数&lt;/
      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑C++" scheme="https://fleschier.github.io/tags/%E0%B9%91C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记——一些报错信息归因</title>
    <link href="https://fleschier.github.io/2018/10/08/C++-learning-error-collection/"/>
    <id>https://fleschier.github.io/2018/10/08/C++-learning-error-collection/</id>
    <published>2018-10-08T14:43:00.000Z</published>
    <updated>2018-11-21T06:40:17.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Expression-public-stream-nullptr"><a href="#Expression-public-stream-nullptr" class="headerlink" title="Expression: public_stream != nullptr"></a>Expression: public_stream != nullptr</h2><hr><ul><li><p>出现这个原因的问题很简单，就是用fopen打开文件失败了，创建的文件指针为空引起的。</p></li><li><p>解决方法就是查看文件路径是否正确。</p></li><li><p>在最后<code>fclose</code>的时候，先判断一下文件指针是否为空。</p></li></ul><h2 id="abort-has-been-called"><a href="#abort-has-been-called" class="headerlink" title="abort() has been called"></a>abort() has been called</h2><hr><ul><li><p>出现这个错误的原因基本上是越界或者内存泄漏。</p></li><li><p>这里的越界包括指针越界和数组越界</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Expression-public-stream-nullptr&quot;&gt;&lt;a href=&quot;#Expression-public-stream-nullptr&quot; class=&quot;headerlink&quot; title=&quot;Expression: public_stream !=
      
    
    </summary>
    
      <category term="Computer Programs" scheme="https://fleschier.github.io/categories/Computer-Programs/"/>
    
    
      <category term="๑C++" scheme="https://fleschier.github.io/tags/%E0%B9%91C/"/>
    
  </entry>
  
</feed>

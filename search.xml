<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tornado建站踩坑记录]]></title>
    <url>%2F2019%2F03%2F10%2Ftornado-bug%2F</url>
    <content type="text"><![CDATA[直入主题 被一个bug搞了一下午: 服务启动后localhost始终加载不出静态文件(诸如CSS,JS脚本,图片什么的). 仔细校验了文件中的路径,绝对路径和相对路径都试了,都是没用. 问题解决 如果有教程推荐你建的文件目录里有statics,相信我,你如果有机会见到它一定会砍死它 错误的文件结构: 123456789101112/.|handlers //后端 Python 程序，主要处理来自前端的请求，并且操作数据库|templates //存放html文件包括模板html文件|statics //存放静态文件的目录|methods //存放通用方法的目录,主要是供给handlers里面的程序调用|XXX.py //python程序... 如上的目录文件,你就算写死了,网站也不会加载出你的静态文件的 正确的目录结构:123456789101112/.|handlers //后端 Python 程序，主要处理来自前端的请求，并且操作数据库|templates //存放html文件包括模板html文件|static //存放静态文件的目录|methods //存放通用方法的目录,主要是供给handlers里面的程序调用|XXX.py //python程序... 咋一看是不是一样啊,再仔细看看,static是没有s的. 只要你敢加上这个s,你就走远了… 后记 这里感谢这位博主的文章,最终问题得以解决 tornado 静态文件路径绑定细节 人生苦短, 我用python~]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑FrontEnd</tag>
        <tag>๑Python</tag>
        <tag>๑Tornado</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ auto关键字使用]]></title>
    <url>%2F2019%2F03%2F06%2FC%2B%2B_auto_usage%2F</url>
    <content type="text"><![CDATA[简述 auto的使用在C++11之后得以推广和支持 对于C++这门静态编程语言而言,所有的变量数据类型是需要明确声明的,在编译时即需要检查和确定.而诸如python这样的语言是动态判断变量类型的,在运行时才会确定数据类型. auto关键字赋予了C++强大的类型自动判断的能力,并且会在很长的类型声明的地方极大地简化我们的代码. 例子 例如:12345//遍历vector,使用迭代器(原始版本)for(std::vector&lt;int&gt;::iterator it = vec.begin(); it != it.end(); it++)&#123; ...&#125; 1234//简化版for(auto it = vec.begin(); it != it.end(); it++)&#123; ...&#125; 还有一种遍历vector的简化写法(适合需要访问每个元素一遍的情况):1234567int main()&#123; vector&lt;int&gt; vec; .... for(auto n: vec)&#123; //这里n即为vec中的每个元素 ... &#125;&#125; 优点 简洁 在代码维护方面有一些”泛型”的好处,比如某个函数的返回值类型改变了,但是赋值的语句使用了auto关键字,那么便不再需要修改除函数以外的地方,减轻了代码的维护量.非常契合模板类等编程. 可以保存lambda表达式的类型的变量声明:auto ptr = [](double x){return 2*x;}; //类型为std::function&lt;double(double))&gt;函数对象 注意点 使用auto声明的变量必须初始化 auto不能与其他类型组合使用,例如auto int a;是错误的. 函数和模板参数不能被声明为auto: 1template&lt;auto T&gt; //错误 因为auto本质上只是一个占位符,并不是一个数据类型,因此也不能用于类型转换和sizeof以及typeid等操作. auto会自动退化为指向数组的指针,除非被声明为引用12345int arr[5];auto x = a;cout &lt;&lt; typeid(x).name() &lt;&lt; endl; // result: int*auto &amp;y = a;cout &lt;&lt; typeid(y).name() &lt;&lt; endl; // result: int[5]]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode python编译错误问题记录]]></title>
    <url>%2F2019%2F03%2F05%2Fvscode-python%2F</url>
    <content type="text"><![CDATA[问题 在Vscode上装完python环境后,在按F5运行后却报错了: 123...ImportError: No module named &apos;_tkinter&apos;... python版本为3.6, pip版本为18 查阅了网上相关资料后发现是缺少包的原因,在终端中手动下载一下即可: 1sudo apt-get install python3-tk 然后再运行python程序即可.]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Python</tag>
        <tag>๑VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插件live2d删除以及遇到的一些问题]]></title>
    <url>%2F2019%2F02%2F17%2Fhexo-live2d-delete%2F</url>
    <content type="text"><![CDATA[删除live2d插件 之前由于兴趣以及探索欲安装了live2d插件,但是在使用过程中不知道如何替换模型,也不是很懂怎么自己DIY模型,于是便放弃了这一插件. 首先删除\themes\next\layout下_layout.swig文件内的与live2d有关的代码 然后使用npm uninstall hexo-helper-live2d来删除这一momdule. 然而事情并没有结束 本以为这个事情就这样搞定了,直到最近我又npm install了一个插件,然后npm audit fix了一下,结果这个module就像幽灵一样又出现了!WTF?! 本着研究学习的想法捣鼓了半天也没用,只能按照原先删除的步骤再删除一遍 不过或许是npm audit fix这条命令的问题,查了一下: npm audit ： npm@5.10.0 &amp; npm@6，允许开发人员分析复杂的代码，并查明特定的漏洞和缺陷。npm audit fix ：npm@6.1.0, 检测项目依赖中的漏洞并自动安装需要更新的有漏洞的依赖，而不必再自己进行跟踪和修复。 官方还提供了其他的一些命令,比如: 12(1)运行audit fix，但是只更新pkglock， 不更新node_modules：$ npm audit fix --package-lock-only 12(2)只更新dependencies中安装的包，跳过devDependencies中的包：$ npm audit fix --only=prod 12运行命令，得到audit fix将会更新的内容，并且输出json格式的安装信息，但是并不真的安装更新：$ npm audit fix --dry-run --json 12得到json格式的详细检测报告$ npm audit --json 特此记录.]]></content>
      <categories>
        <category>Personal Blog</category>
      </categories>
      <tags>
        <tag>๑Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 对象部分]]></title>
    <url>%2F2019%2F01%2F15%2FJS-learning-03%2F</url>
    <content type="text"><![CDATA[window对象 window对象处于对象链的顶端,因为它是Web浏览器中查看所有内容的主要容器. 只要打开浏览器,即使窗口没有加载文档,window对象也在内存的当前模型中定义好了 除了文档所在的窗口内容外,窗口的影响范围还包括窗口的尺寸和包围内容区域的所有”元素”.滚动条,工具栏和菜单栏所在的区域叫做窗口的窗框.不是每个浏览器都可以完全控制浏览器主窗口的窗框,但可以便捷地创建其他窗口,随意地设置其大小,指定要显示的窗框元素. 每个框架都可以看做一个window对象,因为每个框架都可以存放不同的文档.脚本在其中一个文档上运行时,它把拥有这个文档的框架作为对象层次结构图中的window对象. 访问窗口的属性和方法 12window.propertyNamewindow.methodName([Parameters]) 在脚本引用指向包含文档的窗口时,window对象有一个同义词self,以上的引用也等价于:12self.propertyNameself.methodName([Parameters]) 创建窗口 脚本并不创建主浏览器窗口,用户在创建主窗口的时候需要启动浏览器.但是在主窗口打开后,脚本就可以生成大量子窗口. 生成新窗口的方法是:window.open().这个方法最多包含三个参数,来定义窗口属性. 例子:var subWindow = window.open(&quot;define.html&quot;,&quot;def&quot;,&quot;height=200,width=300&quot;);这个语句将新建的窗口赋值给了变量subWindow.(这个语句打开了一个具有指定大小的新窗口,这个窗口包含的html文档为define.html,并且与当前页面处于同一个服务器目录下) 如果要关闭此子窗口,则调用subWindow.close()即可.而调用window.close()/self.close()或者close()就会关闭主窗口. window对象的属性和方法window.alert()方法 可以直接使用alert()来调用这个方法(省略前面的window).这个window方法会生产一个对话框,显示作为参数传送的文本.OK按钮允许用户关闭这个对话框. window.confirm()方法 这个方法也是弹出一个对话框,但是有两个按钮(大多数平台上为Ok和Cancel),称为确认对话框.更重要的是,这个方法有返回值:单击OK返回值为true,单击Cancel返回值为false. 可以将这个方法的计算值作为if或if..else结构中的条件语句. 例子: 123if (confirm(&quot;Are you sure to start over?&quot;))&#123; location.href = &quot;index.html&quot;;&#125; window.prompt()方法 window对象的最后一种对话框是提示对话框,它显示了预置的信息,并提供一个文本域供用户输入响应.这个对话框有两个按钮:OK和Cancel. window.prompt()方法有两个参数,第一个参数是呈现给用户的提示信息;第二个参数是一个字符串,它在文本域中显示为默认的答案.如果不希望显示默认答案就传入一个空字符串(空双引号). 用户单击按钮时,这个方法就会返回一个值.不管用户在文本域中输入什么,单击Cancel按钮都会返回null值,单击OK则返回输入的字符串值.这个信息也可以用在判断中,null值等同于false,空字符串也看做false. load事件 window对象会响应几个系统和用户事件,最常见的是页面加载完毕时触发的事件.这个事件等待图像, Java applet和插件程序的数据文件完全下载到浏览器中.使用load事件调用函数的优点在于,它确保所有document对象都存在于浏览器的DOM中. 可以通过如下方式调用onload方法: 123window.addEventListener(&apos;load&apos;, functionName, false);window.attachEvent(&apos;onload&apos;, functionName);//其中functionName是页面下载完成后要运行的函数的名称.可以多次调用addEventListener和attachEvent,把多个函数添加到页面加载完毕要执行的列表中. 还可以把该事件直接应用于元素: 12window[&apos;onload&apos;] = functionName;window.onload = functionName; 但是这种用法表示,页面加载完毕后,只执行一个函数,并替代已赋予window对象的其他事件处理程序. location对象 这个对象表示载入窗口的URL.它和document对象不同:文档是页面的内容,而位置是页面的URL. 脚本大多数只使用该对象的一个属性:href,它定义了完整的URL. 如果要加载的页面在另一个窗口或框架中,就必须在语句中包含窗口的引用.例如:用脚本打开一个新窗口,并将它的引用赋值给变量newWindow,将页面载入子窗口,如下:newWindow.loaction.href = &quot;http://www.example.com&quot; navigator对象 navigator.userAgent属性返回一个包含浏览器和操作系统的诸多细节的字符串. document对象 document.getElementById()方法 此方法的唯一参数是带引号的字符串,该字符串包含要引用的元素的ID. 例子:var oneTable = document.getElementById(&#39;salesResults&#39;);.在赋值语句后,变量就表示对象,可用于获取和设置该对象的属性,或者调用此类对象的方法. document.getElementByTagName()方法 可以使用getElementByTagName()方法方便地收集一组共享同一个标记名称的页面元素.例如,要获得页面上所有的图像:var aImages = document.getElementByTagName(&#39;img&#39;); 然后可以通过数组的方法来获取数组的长度:aImages.length,然后每个对象就可以使用数组的偏移量来访问. document.forms[]属性 比较下面两个表达式:12var aForms = document.forms;var aForms = document.getElementByTagName(&apos;form&apos;); 一个重要的区别是,document.forms集合允许按名称直接引用某个表单,而不仅仅是按照数组的偏移量来访问. 因为有些时候按照下标号引用表单未必可行.动态网页可能根据上下文包含数量可变的表单,所以表单在页面上的位置可能随上下文而变化. 支持脚本编程的浏览器允许通过表单名或ID(即分配给&lt;form&gt;标记的name或者id属性)更直接地引用表单: 1234567891011&lt;form id=&apos;formId&apos; name=&apos;fromName&apos; ...&gt;//第一种方法是使用getElementById方法:document.getElementById(&quot;formId&quot;)//第二种方法是使用数组语法,将表单名称或者ID作为数组的字符串下标:document.forms[&quot;formId&quot;]document.forms[&quot;formName&quot;]//第三种按名称引用form对象的简短方式是把表单的名称附加为document对象的属性:document.fornName document.images[]属性 文档利用特殊的数组属性来跟踪表单,同样,document对象也通过&lt;img&gt;标记保存插入文档的图像集合(数组).通过document.images数组引用的图像可以用img元素名称中的数字或字符串下标来得到. document.createElement()和document.createTextNode()方法 在HTML文档中添加新元素至少需要两个步骤: 为文档创建新元素. 在页面的树形结构中,将其插入到需要的位置. document.createElement()方法可以在浏览器的内存中创建一个全新的元素对象.指定要创建的元素时,应将元素的标记名作为该方法的字符串参数:var newEle, = document.createElement(&quot;p&quot;); 还可以给元素添加一些属性值,为此应在元素成为文档的一部分之前,向新建对象赋值:newElem.setAttribute(&quot;class&quot;,&quot;intro&quot;); 可将这个元素插入文档中的任何位置,例如末尾:document.body.appendChild(newElem); document.write()方法 document.write()方法是给文档写入内容的另一种方式.他的优点是可以临时应急,缺点如下: 只有页面第一次加载到浏览器中时,document.write()才能给一个网页添加内容.以后调用该方法都会替代整个页面. document.write()会将旧文本块插入文档,编写出草率的程序和错误的标记,将标记与脚本内容混合在一起,不利于开发的分层. document.write()不能用于XHTML,XHTML这种文档类型不允许第一次解析期间修改其内容. 注:XHTML—可扩展超文本标记语言（英语：eXtensible HyperText Markup Language，XHTML），是一种标记语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。从继承关系上讲，HTML是一种基于标准通用标记语言（SGML）的应用，是一种非常灵活的置标语言，而XHTML则基于可扩展标记语言（XML），XML是SGML的一个子集。XHTML 1.0在2000年1月26日成为W3C的推荐标准。 表单和表单元素 form对象 表单以及其中的输入控件是DOM对象,其独特的属性是文档中其他对象所没有的.例如,表单对象的action属性告诉浏览器,在提价表单时,将输入的值发送到什么地方.select控件(下拉列表)的selectedIndex属性指出用户选择了哪个选项. 访问表单属性 在创建表单时,可以使用HTML页面中的标准标记,也可以使用JavaScript中的DOM方法.无论采用哪种方法,都可以设置name,target,action,method和enctype特性.这些都是form对象的属性. 用法的例子: 12var sURL = document.getElementById(&apos;formName&apos;).action;document.forms[0].action = &quot;http://www.example.com/cgi/login.pl&quot;; from.elements[]属性 elements[]属性是表单中所有输入控件的集合.这个数组中各项的顺序根据HTML标记在源代码中的顺序而定.使用ID直接引用单个元素通常更有效,但有时候需要遍历所有元素时会需要这样访问. 下面的代码段查看表单中所有的控件元素,并将文本域的内容设置为空字符串. 1234567var oForm = document.getElementById(&apos;registration-form&apos;); if(!oForm) return false;for(var i = 0; i &lt; oForm.elements.length; i++)&#123; if(oForm.elements[i].type == &quot;text&quot;)&#123; oForm.elements[i].values = &quot;&quot;; &#125;&#125; 将表单控件作为对象 在所有浏览器的DOM中,嵌套在&lt;form&gt;标记中的HTML元素有三种是脚本对象.多数对象都在页面源代码的&lt;input&gt;标记中,只有赋给&lt;input&gt;标记的type特性的值能确定元素是文本框,密码输入域,隐藏域,按钮,复选框还是单选框.其他两种表单控件textarea和select有各自的标记. 要将某个表单控件作为对象进行引用,可以使用其id或tagName直接引用,或者使用DOM level 0语法,将引用构造为一个以document开头,后跟form和控件的层次结构. 123document.getElementById(controlName)或者document.formName.controlName 例如有个简单的表单: 12345678&lt;form id=&quot;searchForm&quot; action=&quot;cgi-bin/search.pl&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; id=&quot;entry&quot; name=&quot;entry&quot;&gt; &lt;input type=&quot;submit&quot; id=&quot;sender&quot; name=&quot;sender&quot; value=&quot;Search&quot;&gt; &lt;/p&gt;&lt;/form&gt;```CPU对于文本输入控件,以下引用实例都是有效的: document.getElementById(“entry”)document.searchForm.entrydocument.searchForm.elements[0]qitakdocument.forms[“searchForm”].elements[“entry”]document.forms[“searchForm”].entry`]]></content>
      <categories>
        <category>Computer Software</category>
      </categories>
      <tags>
        <tag>๑FrontEnd</tag>
        <tag>๑JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础]]></title>
    <url>%2F2019%2F01%2F13%2FJS-learning-02%2F</url>
    <content type="text"><![CDATA[浏览器窗口中的DOM 所有现代浏览器的基本对象模型: window对象: 在层次结构顶部的是window对象.这个对象代表显示HTML文档的浏览器窗口的内容区域.在多框架环境下,每个框架也是一个窗口.所有的文档动作都是在窗口内发生的,所以窗口是对象层次结构中最外部的元素,它包含文档. navigator对象: 脚本从这个对象开始访问浏览器程序,主要是读取浏览器的品牌和版本.此对象为只读,以禁止流氓脚本对浏览器的不当操作.但如后面所述,不能依赖navigator对象获得当前浏览器的实际品牌,型号和版本. screen对象: 这是另一个只读对象,它给脚本提供了运行浏览器的物理环境信息.例如,此对象显示了监视器的高度和宽度(像素值). history对象: 尽管浏览器保留了最近浏览历史的内部细节(如单击后退显示的内容列表),但是脚本却无权访问这些细节.这一对象可以帮助脚本模拟后退或前进按钮的单击. document对象: 每个载入窗口的HTML文档都会变成一个document对象.document对象包含脚本中的内容.除了每个HTML文档中都有的html,head和body元素对象外,文档中元素对象层次的具体标记和结构取决于文档的内容. 文档的载入 简单文档 空文档的对象映射:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta ...&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 添加段落 添加段落标签, 在段落元素的开始和结束标记之间插入段落文本.在标记间插入的连续文本是DOM中的一种特殊的对象,称为文本结点.文本节点总是有一个容器元素,也就是说,文本结点是其父元素p的子元素. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta ...&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is the one and only Paragraph&lt;/p&gt; //添加了段落标签和段落内容 &lt;/body&gt;&lt;/html&gt; 生成新元素 将部分段落文本包含在一个标签中,表示要强调这些文本.这个插入操作对p元素对象的层次结构有很大的影响.p元素从只有一个(文本结点)子元素变成有三个子元素:两个文本节点,和一个它们之间的元素. 在W3C DOM中, 文本结点不能有任何子元素,因此不能包含元素对象.em元素中的文本结点不再是p元素的子元素,而是em元素的子元素. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta ...&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is the one and only Paragraph&lt;/p&gt; //添加了段落标签和段落内容 &lt;/body&gt;&lt;/html&gt; 对象 获取对象的属性 例如,下面的HTML标记定义了一个input元素对象,它指定了四个属性和属性值:1&lt;input type=&quot;button&quot; id=&quot;clicker&quot; name=&quot;clicker&quot; value=&quot;...&quot;&gt; 不必为每个对象设置每个属性,多数属性都有默认值.假如HTML或脚本没有特殊要求,他们就自动设置为默认值. 为了访问对象的属性,需要使用和前面对象相同的圆点定位方式.属性是从属于对象的资源,所以属性的引用就是对象引用后加属性名. 对于刚才的例子,属性的引用如下: 123document.getElementById(&quot;clicker&quot;).namedocument.getElementById(&quot;clicker&quot;).value... 如果JavaScript尝试引用不存在的元素的属性,就会失败或终止.因此引用之前最好先测试一下. 测试引用是否安全: 123val oClicker = document.getElementById(&quot;clikcker&quot;); if(!oClicker) return;var sName = oClicker.name; 在引用的过程中我们省略window部分(完整为window.document.XXX).因为一个窗口只能包含一个文档,所以文档中对象的引用可以省略window部分,但是不能省略document对象. 方法 方法的调用与大多数语言一样,需要在方法名后加一对圆括号. 参数之间以逗号间隔 事件 事件是文档执行中的动作,通常是用户活动的结果. 文档中的每个DOM对象几乎都接收某种类型的事件.我们只需要编写代码,告诉元素对象,只要接收到某种事件,就执行一个动作.这个动作就是执行其他的一些JavaScript代码. 具有事件处理能力的简单按钮: 12345678910111213141516//HTML: 1.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot; &lt;title&gt;A Simple Button with an Event Handler&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jab.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot;&gt; &lt;div&gt; &lt;button id=&quot;clicker&quot;&gt;Click here&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122//JAVASCRIPT:jsb.js//tell the browser to run this script when the page has finished loadingwindow.onload = applyBehavior;//apply behavior to the buttonfunction applyBehavior()&#123; //ensure a DOM-aware user agent if(document.getElementById)&#123; //point to the button var oButton = document.getElementById(&apos;clicker&apos;); //if it exists, apply behavior if(oButton)&#123; oButton.onclick = behave; &#125; &#125;&#125;//what to do when the button is clickedfunction behave(evt)&#123; alert(&apos;Ouch! &apos;);&#125; 事件的名称一般为事件的类型(例如click)以及前缀on构成,表示一接收到XXX事件就XXX. 把脚本链接到文档上 放在外部文件中:&lt;script type=&quot;text/javascript&quot; src=&quot;[/..../]example.js&quot;&gt;&lt;/script&gt; 内嵌在html中: 123&lt;script type=&quot;text/javascript&quot;&gt; JavaScript code here&lt;/script&gt; script标记的位置 大多数情况下script标记放在&lt;head&gt;标签中,有时候会放在&lt;body&gt;标签. 放在&lt;head&gt;中的标记一般会影响页面中的非内容设置—所谓的html指令元素,例如&lt;meta&gt;标记和文档题目,这里也适合放置响应页面载入或用户动作的脚本. 如果需要在页面载入时运行脚本,以便生成页面内容,则脚本应放在文档的&lt;body&gt;部分 注释 单行注释用//,多行注释用/**/ 脚本语句的执行时间 根据脚本要完成的功能,脚本运行的时间有四种选择: 文档载入时 文档载入后 响应用户动作时 其他脚本语句调用时 决定性因素是脚本语句在文档中的位置. 除了第一个,其他三种统称为延时脚本 页面载入后执行 假设定义了函数function done(){alert(&quot;....&quot;)},则如果想要在页面加载完成是调用它,可以用window.onload = done;来实现在页面加载完成时调用done函数. 注意此语句右侧只有函数名,没有圆括号. JavaScript值(数据)类型 类型 示例 说明 String “Test” 引号内的一系列字符 Number 4.5 不在引号内的数字 Boolean false 逻辑真或假 Null null 不包含任何内容,但仍然是一个值 Object 通过属性和方法定义的软件对象(数组也是对象) Function 函数定义 假如用户在表单的文本的输入域中输入数字,浏览器就把该数字存储为字符串类型.假如脚本要对这个数字执行算数操作,就需要将字符串转化为数字再进行操作. 变量 创建变量:var valueName; var关键字用于声明和初始化变量,文档中任何变量都只需要使用一次var关键字. 变量赋值:valueName = 45; JavaScript变量可以存储任何类型的值.在声明变量的时候,不必定义变量包含的值的类型. 类型转换 两个数值相加:3 + 3,结果为6没有问题. 但如果其中一个数字是字符串,JavaScript就会将另一个值转换为字符串,将这个加号操作从算数加变成字符串连接:3 + &quot;3&quot;,结果为&quot;33&quot;. 3 + 3 + &quot;3&quot;,结果为&quot;63&quot;. 将字符串转化为数值 JavaScript提供了两个内置函数:parseInt()和parseFloat() 12parseInt(&quot;43&quot;) //结果为42 parseInt(&quot;43.33&quot;) //结果为43,这里做截断处理 12parseFloat(&quot;43&quot;) //结果为43parseFloat(&quot;43.33&quot;) //结果为43.33 将数字转化为字符串 利用JavaScript的特性:&quot;&quot;+2500,结果即为&quot;2500&quot; 控制结构 if else与C++等用法一致 for循环(i用var声明,其余与C++一致): 123for(var i = startValue; i &lt;= MaxValue; i++)&#123; ...&#125; 函数 函数的正式语法结构:123functoin functionName([Parameter1]...[,ParameterN])&#123; statement[s]&#125; 局部变量和全局变量 在函数外声明的变量为全局变量,在函数体中定义的变量称为局部变量. 局部变量的作用域只局限于函数内部. 全局变量的作用域是 当前载入浏览器窗口或框架的文档.因此初始全局变量后,页面中所有的脚本语句可通过全局变量名直接访问其值.但是,一旦卸载页面,在页面中定义的所有全局变量都会从内存中清除.假如某个值需要在页面卸载后继续使用,则需要使用其他技术来保存它,比如将它存储为框架集文档中的全局变量,或将它存储在cookie中. 如果用var关键字在函数体中初始化了一个与全局变量同名的局部变量,则在函数体中该局部变量比全局变量优先级要高. 数组 创建:var Arr = new Array(100); 访问:Array[0]; 数组中的document对象 例如,如果页面包含两个&lt;form&gt;标记对时,在文档中就会出现两组&lt;form&gt;标记.浏览器为文档使用一个from对象数组,对这些表单的引用如下: 12document.forms[0]document.forms[1] 也可以使用DOM方法getElementByTagName()访问这个数组: 123var aForms = document.getElementByTagName(&apos;form&apos;);aForms[0]aForms[1] document对象的下标是由对象的载入顺序决定的,form对象的顺序由文档中&lt;form&gt;标记出现的顺序确定.]]></content>
      <categories>
        <category>Computer Software</category>
      </categories>
      <tags>
        <tag>๑FrontEnd</tag>
        <tag>๑JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 入门]]></title>
    <url>%2F2019%2F01%2F12%2FJS-learning-01%2F</url>
    <content type="text"><![CDATA[引例 12345678910111213141516171819202122232425262728293031//tell the browser to run this script when the page has finished loadingwindow.onload = insertDateTime;//insert the data &amp; timefunction insertDateTime()&#123; //ensure a DOM-aware user agent if(!document.getElementById) return; if(!document.createTextNode) return; //create a date-time object var oNow = new Data(); //get the current date &amp; time as a string var sDateTime = oNow.toLocaleString(); //point to the target element where we want to insert the date &amp; time var oTarget = document.getElementById(&apos;output&apos;); //make sure the target is found if(!oTarget) return; //delete everything inside the target while(oTarget.firstChild)&#123; oTarget.removeChild(oTarget.firstChild); &#125; //use the date-time string to create a new text node for the page var oNewText = document.createTextNode(sDateTime); //insert the mew text into the span oTarget.appendChild(oNewText);&#125; 解析触发事件 脚本要把日期和事件插入到页面的段落中,但浏览器在读取和运行JavaScript代码之前,并没有读取HTML体.在JavaScript开始运行时,要插入新内容的段落甚至在浏览器的内存中不存在. 解决办法就是告诉JavaScript,在文档完全读入内存之前,不要执行插入操作.为此使用了onload事件.页面的元素(在DOM中称为对象)可以感知很多事件,例如 鼠标单击或按下一个键. 文档加载到浏览器中后,就会触发window对象的onload事件. window.onload = insertDateTime;告诉JavaScript,文档加载完毕后调用insertDateTime()函数. 确保一个安全的环境 123//ensure a DOM-aware user agentif(!document.getElementById) return;if(!document.createTextNode) return; 这里调用的getElementById()和createTextNode()是两个某些旧的JavaScript解释器不能理解的DOM方法.感叹号!表示”not”,return告诉JavaScript停止运行当前的函数. 如果不包含这些保护措施,某些老式的浏览器或其JavaScript解释器就会在运行其后代码的时候崩溃. 生成日期和时间 要插入这个文档中的文本是当前的日期和时间.JavaScript很容易完成这个插入操作:创建一个Date对象,并使用它的一个方法生成字符串:1234//create a date-time objectvar oNow = new Date()//get the current date &amp; time as a stringvar sDateTime = oNow.toLocaleString(); 这些代码把oNow变量设置为一个新的Date对象.之后使用其toLocaleString()方法输出一个文本字符串,它包含:Thrusday, August 20, 2009 4:16:05 PM 确定目标 下一步就是把日期和事件插入文档中需要的位置.执行了以下操作: 指向目标span元素 删除该文本中已有的文本 在元素中插入新的文本 为了指向output span,使用ID的方式来定位:var oTarget = document.getElementById(&#39;output&#39;);该语句通过ID(ouput)lai定位目标元素,并把该对象的引用存储在oTarget变量中. HTML规范指出,每个元素的ID在当前页面必须是唯一的,即使不小心在页面上使用了相同的ID,getElementById()方法也仅返回第一个ID实例.所以,这个方法仅定位一个元素.(本例中就是span元素) 如果getElementById()没有找到对应的ID,则将返回空值.为了避免由于疏忽导致的这类错误,采用if(!oTarget) return;这个测试语句. 也可以将这个错误变成警告提示:if(!oTarget) return alert(&quot;Warning: output element not found!&quot;); 删除原来的内容 我们要删除span的文本,再插入新内容.在表示页面内容的DOM中,span是其所有子元素的父元素.span现在只有一个子元素:单词”now”. 为了删除span的内容,执行一个简单的循环.只要还有要删除的元素,该循环就一次删除一个子元素: 1234//delete everything inside the targetwhile(oTarget.firstChild)&#123; oTarget.removeChild(oTarget.firstChild);&#125; 在本例中这个循环只会执行一次. 插入日期和时间 最后在DOM中创建一个包含所有所需文本的新节点,并插入span:12345//use the date-time string to create a new text node for the pagevar oNewText = document.createTextNode(sDateTime);//insert the new text into the spanoTarget.appendChild(oNewText); sDateTime是从Date对象中生成的字符串. 这里调用document对象关联的一个方法,该方法会创建一个新的文本节点,并把日期和事件字符串作为其值.此时该文本结点还不是可见文档内容的一部分,使用目标元素的appendChild()方法就可以插入它.]]></content>
      <categories>
        <category>Computer Software</category>
      </categories>
      <tags>
        <tag>๑FrontEnd</tag>
        <tag>๑JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-自底向上]]></title>
    <url>%2F2018%2F12%2F24%2FInternet_protocol%2F</url>
    <content type="text"><![CDATA[一些概念性的名词用 斜体 标出了 互联网概述 计算机网络由若干的结点(node)和连接这些结点的链路(link)组成.结点可以是计算机,集线器,交换机或路由器. 网络之间可以通过路由器互连起来,因此互联网是 网络的网络. 网络把许多计算机连接在一起,而互联网把很多网络通过路由器连接在一起.与网络相连的计算机通常称为 主机. 以小写字母i开始的internet(互连网)是一个通用名词,泛指由多个计算机网络互连而成的计算机网络. 以大写字母I开始到Internet(互联网)是一个专有名词,特指采用TCP/IP协议族作为通信规则的互联网. RFC(Request For Comments)就是 “请求评论” 主机A和主机B进行通信,更为全面的说法是 主机A的某个进程和主机B的某个进程进行通信 互联网的组成 互联网的拓扑结构非常复杂,从其工作方式上来看分为以下两大块: 边缘部分: 这部分是用户直接使用的,由所有连接在互联网上的主机构成 核心部分: 这部分是为边缘部分提供服务的,由大量网络和链接这些网络的路由器组成 在客户机和服务器之间通信的过程中,服务请求方和服务提供方 都要使用网络核心部分所提供的服务 路由器 路由器是一种专用计算机,实现 分组交换 的关键部件.其任务就是转发收到的分组. 电路交换 必须经过建立连接(占用通信资源) -&gt; 通话(一直占用通信资源) -&gt; 释放连接(归还通信资源)这三个步骤的交换方式就叫 电路交换. 分组交换 分组交换采用 存储转发 技术. 通常把要发送的一整块数据叫做 报文. 把较长的报文划分成一个个更小等长的数据段,在每一个数据段的前面,加上一些必要的控制信息组成 首部 后,就构成了一个 分组.(分组又称为包) 路由器收到一个分组,先暂时存储一下,检查其首部,查找转发表,按照首部中的目的地址找到合适的端口发送出去,把分组交给下一个路由器. 三种交换方式的比较 电路交换: 整个报文的比特流连续地从源点直达终点,好像在一个管道中传送. 报文交换: 整个报文先传送到相邻结点,全部存储下来后查找转发表,转发到下一个结点. 分组交换: 单个分组(整个报文的一部分)传送到相邻的结点,存储下来后查找转发表,转发到下一个结点. 计算机网络的类别 计算机网络的定义: 计算机网络是有一些通用的,可编程的硬件互联而成的,而这些硬件并非专门用来实现某一特定的目的. WAN(Wide Area Network):广域网 MAN(Metropolitan Area Network):城域网 LAN(Local Area Network):局域网 PAN(Personal Area Network):个人局域网 计算机网络性能带宽 带宽本来是指某个信号具有的频带宽度.信号的带宽是指该信号所包含的各种不同的频率成分所占据的频率 范围.例如,传统通信线路上的电话信号的标准带宽是3.1kHz(从300Hz到3.4kHz,这个值代表的是一个 范围的大小),这时带宽的单位是Hz 带宽的另一个表示是网络中某通道传送数据的能力,即传输数据的速度,此时单位是bit/s 时延 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 利用率 信道利用率是指某信道有百分之几的时间是被利用的(有数据通过) 令D0表示网络空闲时的时延(也就是网络所能达到的最低时延),D表示网络当前的时延,U为网络的利用率,则有:D = D0/(1-U) 可以看出如果U(利用率)太高则时延会成指数级增长,一般尽量保证网络的利用率不超过50%. 计算机网络体系结构OSI的七层协议 物理层 - 数据链路层 - 网络层- 运输层 - 会话层 - 表示层 - 应用层 TCP/IP的四层协议 网络接口层 - 网际层IP - 运输层(TCP或UDP) - 应用层(各种应用层协议如TELNET,FTP,SMTP等) 五层协议 物理层 - 数据链路层 - 网络层 - 运输层 - 应用层 物理层 波特率和比特率 比特率(bit rate)又称传信率、信息传输速率(简称信息速率，information rate)。其定义是：通信线路(或系统)单位时间(每秒)内传输的信息量，即每秒能传输的二进制位数，通常用Rb表示，其单位是比特/秒(bit/s或b/s，英文缩略语为bps)。 在二进制系统中，信息速率(比特率)与信号速率(波特率)相等，例如，当系统以每秒50个二进制符号传输时，信息速率为50bit/s，信号速率也为50Bd(波特)。在无调制的情况下，比特率等于波特率；采用调相技术时，比特率不等于波特率。通信系统的发送设备和接收设备必须在相同的波特率下工作，否则会出现帧同步错误。 波特率(Baud rate)又称传码率、码元传输速率(简称码元速率)、信号传输速率(简称信号速率，signaling rate)或调制速率。其定义是：通信线路(或系统)单位时间(每秒)内传输的码元(脉冲)个数；或者表示信号调制过程中，单位时间内调制信号波形的变换次数，通常用RB表示，单位是波特(Bd或Baud，前者规范)。如果每秒传输1个码元就称为1Bd；如果1码元的时间长短为200ms，则每秒可传输5个码元，那么码元速率(波特率)就是5Bd。 波特率(码元速率)并没有限定是何种进制的码元，所以给出波特率时必须说明这个码元的进制。对于M进制码元，比特率(信息速率)Rb与波特率(码元速率)RB的关系式为:Rb=RB·lbM.式中：lbM=log2M，表示M的以2为底的对数。显然，对于二进制码元，由于lb2=1，所以Rb=RB，即波特率与比特率在数值上相等，但单位不同，也即二者代表的意义不同。 例如，波特率为600Bd，则在二进制时，比特率也为600bit/s；在四进制时，由于lb4=2，所以比特率为1200bit/s。可见，在一个码元中可以传送多个比特。 可以理解为,比特率在数值上等于二进制编码的波特率. 信道极限容量&amp;香农公式 码元的传输速率越高,或者信号传输距离越远,或噪声干扰越大,或传输媒体质量越差,在接收端的波形失真越严重. 限制码元在信道上传输速率的因素有两个: 信道能通过的频率范围:在任何信道中,码元传输的速率是有上限的,传输速率超过此上限,就会产生严重的码间串扰(码元之间的界限变得不再明确,前后都拖了”尾巴”). 信噪比: (突然的噪声会导致误判,0变成1,1变成0).信噪比就是信号的平均功率和噪声的平均功率之比. 码元:时间轴上的一个信号的编码单位 香农公式 信道的极限传输速率C是: C = W log2(1+S/N) (bit/s) 数据编码常用编码方式 不归零制,归零制,曼彻斯特编码,差分曼彻斯特编码 基本的带通调制方法(将数字信号转化为模拟信号) 调幅(AM):载波振幅随基带数字信号而变化.例如0或1对应于无载波输出和有载波输出 调频(FM):载波频率随基带数字信号而变化.0或10或1对应频率f1和f2 调相(PM):载波的初始相位随基带数字信号而变化.例0或1分别对应相位0度或180度 常用的通信介质导引型传输媒体 双绞线:绞合可减少对相邻导线的电磁干扰.绞合度越高最大传输速率就越高,但是价格也越高. 同轴电缆:主要用在有线电视网的居民小区. 光缆:多模光纤(只适合近距离传输),单模光纤. 非导引型传输媒体 短波通信 微波接力 微信通信 多路复用技术 频分复用(FDM):同一时间不同用户使用不同的频带宽度(就是信号的频率)进行通信. 时分复用(TDM):不同用户在不同的时间点占用过同样的频带宽度(表现为周期性出现用户的时隙) 波分复用(WDM) =&gt; 就是光的频分复用 码分复用(CDM, Code Division Multiplexing):更常用的是码分多址CDMA.码分复用即将0和1对应到一串特殊的二进制,每个用户不重复(更准确地说,要求是正交的).比如将1表示为001100这一串二进制,则对应的0就是将其每一位都取反,即110011. 数据链路层 数据链路层的基本传输单元叫做 帧 帧同步问题 帧的开始和结束的确认 数据链路层的三个功能: 透明传输, 流量控制, 差错检测(只检错不纠错) 封装成帧 所有在互联网上传送的数据都以分组(IP数据报)为传送单位,网络层的IP数据报送到数据链路层就成为帧的数据部分.对帧的数据部分加上首部和尾部就构成了一个完整的帧. 首部和尾部的一个重要作用就是帧定界(确认帧的开始和结束) 最大传输单元MTU(Maximum Transfer Unit): MTU是的是帧的数据部分的最大长度. 帧定界 SOH(Start Of Header):帧开始符(由一串不与数据部分重合的二进制位组成) EOT(End Of Transmission):帧结束符 帧定界符可以检测数据是否有差错,例如一个帧是否完整 透明传输 即用作帧定界的控制字符的比特编码不能出现在数据部分中 透明: 某一个实际存在的事物看起来却好像不存在一样 在数据链路层透明传输数据表示:无论什么样的比特组合的数据,都能够按照原样没有差错地通过这个数据链路层 为了解决透明传输的问题,对于数据中出现的控制字符’EOT’和’SOH’的前面插入一个转义字符’ESC’,接收端的数据链路层会在将数据交付网络层之前删除这个转义字符.这种方法称为字节填充或者字符填充.(如出现转义字符则再加转义字符) 差错检测 目前在数据链路层广泛地使用了CRC(Cyclic Redundant Check)的检错技术. 点对点协议ppp point to point protocol 互联网用户必须连接到某个ISP才能接入互联网,ppp协议就是用户计算机和ISP进行通信时使用的 数据链路层协议 ppp协议支持多种网络层协议(如IP和IPX)和多种类型链路(例如串行(一次发送一个比特)和并行(一次并行地发送多个比特)) 差错检测: ppp协议对接收端收到的帧进行检测,并 立即丢弃有差错的帧 最大传送单元: ppp协议对每一种类型的点对点链路设置最大传送单元MTU的标准默认值,如果高层协议发送的分组过长并超过MTU的数组,则 丢弃这样的帧 ppp协议的帧格式 首部为四个字段, 尾部为两个字段. 首部的第一个字段和尾部的第二个字段(最后一个字段)都是 标志字段,规定为0x7E.标志字段表示一个帧的开始或结束.因此标志字段就是ppp帧的定界符. 连续两个帧之间只需要一个标志字段,连续两个标志字段表示这是一个空帧 首部中的第二个字段(地址字段A)和第三个字段(控制字段C)没有实际的含义 首部的第四个字段是协议字段,占2字节. 数据部分(信息字段)长度是可变的,最长不超过1500字节 尾部的第一个字段(2字节)是使用CRC的检验序列FCS 字节填充: ppp使用异步传输时,转义符定义为0x7D,填充方法:将信息字段中每一个0x7E字符转化为(0x7D, 0x5E),将出现的0x7D转化为(0x7D, 0x5D),如果出现ASCII码的控制符(即数值小于0x20),则在该字符前增加一个0x7D,例如0x03转化为(0x7D, 0x03) 局域网的数据链路层 局域网的主要特点:网络为一个单位所拥有,且地理范围和站点数目均有限. 局域网使用的是数据链路层的协议 局域网的优点: 具有广播功能,从一个站点可以很方便地访问全网. 便于系统的扩展和逐渐演变,各设备的位置可以灵活调整和改变. 提高了系统的可靠性,可用性和生存性. 局域网的拓扑结构: 星型网,环形网和总线网. 局域网工作的层次跨越了数据链路层和物理层. 数据链路层在局域网中分为两个子层: 逻辑链路控制层(LLC) (现在使用的局域网协议–以太2型 取消了LLC层,只留下MAC层) 介质访问控制层(MAC) (MAC层与物理层使用的介质密切相关) 共享信道 由于局域网的广播信道是一人发送,所有人都可以接收,所以要制定发送规则. 静态信道划分 使用诸如频分复用,时分复用等技术,用户只要分配到了信道就不会和其他用户发生冲突,但代价太高,不适合局域网使用. 动态媒体接入控制 又称为 多点接入(multiple access) 又分为两类: 随机接入: 所有用户都可以随机地发送信息,但可能发生碰撞,需要解决碰撞的网络协议. 受控接入: 用户发送信息要服从一定的控制,例如集中控制的多点线路 探寻(polling) 受控接入在目前的局域网中使用的较少 适配器 计算机与外界局域网的连接是通过适配器(adapter)进行的. 适配器实现的功能包括了数据链路层和物理层. 适配器在接收和发送各种帧的时候,不使用计算机的CPU.当适配器收到有差错的帧的时候,就直接丢弃而不通知计算机.当接收到正确的帧的时候,就使用中断来通知计算机,并交付协议栈中的网络层.当计算机要发送IP数据报时,就由协议栈把IP数据报向下交给适配器,组装成帧后发送到局域网 注意: 计算机的硬件地址(MAC地址)就在适配器的ROM中 CSMA 为了通信简便,以太网使用以下两个措施: 采用 无连接 的工作方式,即尽最大努力交付(不可靠的交付).接收站对收到的差错帧直接丢弃(采用CRC检错),至于是否需要重传由高层协议决定(例如TCP协议) 以太网发送的数据都是使用曼彻斯特编码的信号 CSMA/CD CSMA/CD: Carrier Sense Multiple Access Protocl with Collision Detection.意思是载波监听多点接入/碰撞检测 要点: “多点接入”: 许多计算机是以多点接入的方式连接在一根总线上. “载波监听”: 就是用电子技术检测总线上有没有其他计算机也在发送.不管在发送前,发送中,每个站都必须不停地检测信道.在发送中检测信道,是为了及时发现有没有其它站的发送和本站发送的碰撞,这称为 碰撞检测. “碰撞检测”: 也就是边发送边监听,也称为 “冲突检测”.一旦发生冲突,总线上传输的信号产生了严重的失真,无法恢复出有用的信息来,因此任何一个正在发送的站一旦检测到冲突其适配器立即停止发送. 检测时信道空闲不代表没有站在通信,因为存在传播时延. 电磁波在1km电缆的传播时延约为5us 若总线上单程端到端的传播时延记为t,则最多经过2t就能确定有没有发生冲突.(发送数据后监听2t时间,没有冲突即发送成功) 使用CSMA/CD协议时,一个站不能边发送边接收,因此使用CSMA/CD的以太网只能进行 半双工通信 以太网规定最短帧长度为64字节(512bit).因为 对于10Mbit/s的以太网,争用期为51.2us,而发送512bit需要恰好51.2us,如果数据短于64字节,则可能无法检测出发生冲突的帧. 因此规定凡是长度小于64字节的帧都是由于冲突而异常终止的无效帧. 名词概念: 10BASE-T这里10表示10Mbit/s的数据率, BASE表示连接线上的信号是基带信号, T代表双绞线. 星型网使用 集线器(hub) 作为中心.使用集线器的以太网在逻辑上仍然是一个总线网,各站共享逻辑上的总线,使用的还是CSMA/CD协议. 集线器工作在物理层,它的每个接口仅仅简单地转发比特,不进行碰撞检测(碰撞检测由各站的适配器完成) 以太网的MAC层以太网V2的MAC帧 以太网V2的MAC帧由五个字段组成. 第一个字段为6个字节的目的地址 第二个字段为6个字节的源地址 第三个字段为2个字节的类型字段(用来标志上一层使用了什么协议,以便把收到的MAC帧交给上一层的这个协议) 第四个字段数据字段,长度在46-1500字节之间(由于之前提到帧的最小长度是64字节,所以46字节就是用64减去首部尾部得到的).数据字段就是网络层传下来的IP数据报. 最后一个字段是4字节的帧检验序列FCS(使用CRC检验) 从MAC子层向下传到物理层还要添加8个字节(包括7字节的前同步码(1和0的交替码)和1字节的帧开始定界符(定义为10101011)),它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率,使它和发送端同步. 设置MAC帧长度的限制的原因:最短64字节的原因在之前以太网帧长度处规定了.最长不能超过1518字节是因为如果数据帧太长,则单一站点占用信道的时间太长影响其他站点分享带宽,同时太长的帧在传输时容易出错. 网桥(bridge) 中继器只能识别出位(bit),网桥能够识别数据帧. 网桥的升级版为交换机,两者都是工作在数据链路层. 交换机(switch) 1990年问世的 交换式集线器(switching hub) 很快就淘汰了网桥.交换式集线器称为 以太网交换机或第二层交换机 以太网交换机实际上就是一个 多接口的网桥, 和工作在物理层的转发器,集线器有很大的区别,以太网交换机的每个接口都直接与一个单台主机或另一个以太网交换机相连,并且一般都工作在 全双工方式.其内部的交换表(又称为地址表)是通过 自学习 算法自动建立起来的. 虚拟局域网 使用了特殊的交换机,第三层交换机,即搭载了路由表的交换机,可以提供网络间通讯的功能. 网络层 网络层向上只提供简单灵活的,无连接的,尽最大努力交付的数据报服务. 传输单元为分组(即IP数据报) 虚电路和数据报的比较 对比方面 虚电路服务 数据报服务 思路 可靠通信应当由网络来保证 可靠通信应当由用户主机来保证 连接的建立 必须有 不需要 终点地址 尽在连接建立阶段使用,每个分组使用短的虚电路号 每个分组都有完整地址 分组的转发 属于同一条虚电路的分组均按照同一路由进行转发 每个分组独立选择路由进行转发 当结点出现故障时 所有通过出故障结点的虚电路均不能工作 出故障的结点可能会丢失分组,一些路由可能会发生变化 分组的顺序 总是按发送顺序到达终点 到达终点的时间不一定按发送顺序 端到端的差错处理和流量控制 可由网络负责,也可以由用户主机负责 由用户主机负责 网际协议IP网络互联 将互联网连接起来需要使用一些中间设备,不同的层次使用的中间设备有不同的名称: 物理层: 转发器(repeater) 数据链路层: 网桥或者桥接器(bridge) 网络层: 路由器(router) 网络层以上各层: 网关(gateway) IP地址的分类 A类,B类,C类地址都是由两个固定长度的字段组成: 第一个字段是网络号(net-id), 一个网络号在整个互联网范围内必须是唯一的. 第二个字段是主机号(host-id), 一台主机号在它前面的网络号所指明的网络范围内必须是唯一的. IPV4地址长度是32位,A类,B类和C类的网络号分别是1个字节(8位),2个字节(16位)和3个字节(24位)长,在网络号最前面有1-3位类别位,A,B,C类网络分别为0,10和110. A类地址 A类地址网络号占一个字节,只有7位可以使用(第一位固定为0),但可指派的网络号是126个(2^7 - 2),减2的原因是: (1)网络号全为0的IP地址是个保留地址,意思是”本网络”.(2) 网络号为127的网络地址保留作为本地软件 环回测试(loopback test) 本机的进程之间的通信之用. A类地址主机号占3字节,可以指派的主机数为2^24-2, 这里 减2的原因是: (1)全0的主机号字段表示该IP地址是”本主机”所连接到的 单个网络地址 (例如: 一台主机的IP地址是5.6.7.8,则5.0.0.0表示这个主机所在的 网络地址) (2)全1的主机号表示 所有的(all), 因此全1的主机号表示该网络上的所有主机. 例如: B类地址128.7.255.255表示”在网络128.7.0.0上的所有主机”,A类地址0.0.0.35表示”在这个网络上主机号为35的主机” A类地址第一个可指派的网络号为1.0.0.0,最后一个可指派的网络号为126.0.0.0 B类地址 B类地址网络号有2个字节,最前面两位已经固定(为10),值剩下14位.由于B类地址128.0.0.0是不指派的,所以可以指派的 B类最小网络地址是128.1.0.0.因此B类可指派的网络数为2^14-1. B类地址主机号占2字节, 由于全0和全1的主机号不能指派(理由同A类地址),所以可以指派的主机数为2^16-2 B类地址第一个可指派的网络号为128.1.0.0,最后一个可指派的网络号为191.255.0.0 C类地址 C类地址有3个字节的网络号,前3个字节固定(为110),C类地址192.0.0.0也是不指派的,指派的 最小的C类网络地址是192.0.1.0,因此C类地址可指派的网络总数是2^21-1. 每个C类地址的最大主机数为2^8-2 C类地址第一个可指派的网络号为192.0.1.0, 最后一个可指派的网络号为223.255.255.0 一般不使用的特殊IP地址 网路号 主机号 源地址使用 目的地址使用 代表意思 0 0 可以 不可以 在本网络上的本主机 0 host-id 可以 不可以 在本网络上的某台主机(host-id) 全1 全1 不可以 可以 在本网络上进行广播 net-id 全1 不可以 可以 对net-id上的所有主机进行广播 127 非全0或全1的 任何数 可以 可以 用于本地软件环回测试 IP地址特点 实际上,IP地址标志一台主机(或路由器)和一条链路的 接口.当一台主机同时连接到两个网络上时,该主机就必须同时具有两个相应的IP地址,其网络号必须是不同的. 按照互联网的观点, 一个网络就是具有相同网路号net-id的主机的集合. 地址解析协议ARP ARP协议根据IP地址获取物理地址. 由于网络层使用的是IP地址,但是在实际网络的链路上传送数据帧时,最终还是必须使用该网络的硬件地址.但IP地址和下面的网络的硬件地址之间由于格式的不同而不存在简单的映射关系(IP地址32位而局域网的硬件地址是48位).此外,在一个网络上可能经常会有新的主机加进来或者撤走旧的主机.更换网络适配器也会使主机的硬件地址改变. 地址解析协议ARP解决这个问题的方法是,在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表,并且这个映射表还经常动态更新. 即IP数据报格式 一个IP数据报由 首部 和 数据 两部分组成. 首部的前一部分是固定长度,共20字节,是所有IP数据报必须具有的.在首部固定部分后面是一些可选字段,其长度是可变的. 首部固定部分中的各字段 一共12个字段 版本: 占4位,指IP协议的版本,通信双方使用的IP协议的版本必须一致. 首部长度: 占4位,可表示的最大十进制数值是15.注意,这个长度的单位是32位字(1个32位字是4字节),即当值为1111(15)时,表示首部长度为60字节.当IP分组的首部长度不是4字节的整数倍时,必须利用最后的填充字段加以填充. 区分服务: 占8位, 用来获得更好的服务.(一般情况下都不使用这个字段) 总长度: 占16为,因此最大值为2^16-1=65535.总长度指首部和数据之和的长度,单位为字节.一般下面的数据链路层都规定了MTU(Maximum Transfer Unit),即最大传送单元.一个IP数据包封装成帧之后长度一定不能超过这个值,否则就要进行分片. 标识(identification): 占16位.IP软件在存储器中维持一个计数器,每产生一个数据报,计数器就加1,并将此值赋给标识字段.但这个不是序号,因为数据报不存在顺序接收. 标志(flag): 占3位,目前只有前两位有意义. 标志字段中的最低位记为MF(More Fragment). MF=1表示后面”还有分片”的数据报.MF=0表示这已是若干数据报片的最后一个. 标志字段中间一位记为DF(Don&#39;t Fragment),意思是”不能分片”.只有当DF=0时才允许分片. 片偏移: 占13位.片偏移指出:较长的分组在分片后,某片在原分组中的相对位置.也就是说,相对于用户数据字段的起点,该片从何处开始.片偏移的单位是8字节,所以说每个分片的长一定是8字节(64位)的整数倍. 生存时间: 占8位.英文缩写是TTL(Time To Live),表明这是数据包在网络中的寿命.其目的是防止无法交付的数据包无限在网络中兜圈子.路由器每转发一次就将数据报的TTL的值减1,如果某个数据报的TTL=0,则路由器接收之后直接丢弃而不转发. 协议: 占8位.协议字段指出此数据包携带的数据使用的是何种协议, 以便使目的主机的IP层知道将数据部分上交给哪个协议进行处理. 首部校验和: 占16位.这个字段只检验数据报的首部,但不包括数据部分.每经过一个路由器,都要重新计算一遍校验和(因为生存时间,标志,片偏移等可能会变化). 源地址:占32位 目的地址: 占32位 IP转发分组的流程 在路由表中,对每一条路由最主要的是以下两个信息(还会包括其他的一些信息):(目的网络地址, 下一跳地址) 只有到达最后一个路由器时,才试图向目的主机进行交付. 划分子网和构造超网子网 在IP地址中增加了一个”子网号字段”,使得两级IP地址变为三级IP地址.这种做法叫做 划分子网(subnetting). IP地址 ::= {&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;} 子网号字段占用了主机号字段的长度,因此划分子网会使主机数目减少,但是不改变原来的网络号,因此对外这个网络还是原来的网络. 子网掩码 从IP数据报的首部无法看出源主机或者目的主机所连接的网络是否进行了子网划分,就必须使用 子网掩码 例如将IP地址145.13.3.10与子网掩码255.255.255.0做与操作,得到的网络地址是145.13.3.0. 使用子网划分后,路由表必须包含一下三项内容:目的网络地址,子网掩码和下一跳地址. 超网无分类编址CIDR 使用 变长子网掩码VLSM(Variable Length Subnet Mask) 可以进一步提高IP地址资源的利用率.在VLSM的基础上又进一步研究出无分类编址方法,正式名称是 无分类域间路由选择CIDR(Classless Inter-Domain Routing) CIDR的主要特点有两个: CIDR消除了传统的A类, B类和C类的地址以及划分子网的概念.CIDR把32位的IP地址分成前后两个部分,前面部分是网络前缀(network-prefix),用来指明网络,后面部分用来指明主机.因而CIDR是无分类的两级编址,记法为:IP地址:={&lt;网络前缀&gt;,&lt;主机号&gt;}.CIDR还使用”斜线记法”,即在IP地址后面加上斜线/,然后写上网络前缀所占的位数. CIDR把网络前缀都相同的连续的IP地址组成一个”CIDR地址块”,我们只要知道CIDR地址块中的任何一个地址,就可以知道这个地址块的起始地址和最大地址,以及地址块中的地址数.例如:128.14.35.78/20 = 10000000 00001110 0010 0011 00000111 (20位网络前缀已加粗)所以最小地址可以很方便地写出: 128.14.32.0(10000000 00001110 00100000 00000000),最大地址也可以很方便写出:128.14.47.255(10000000 00001110 0010 1111 11111111) 为了更方便进行路由选择,CIDR使用32位 地址掩码(address mask), 地址掩码由一串1和一串0组成,1的个数就是网络前缀的长度.(原理与子网掩码一致,都是通过与操作获取网络地址) CIDR仍然可以划分子网,但子网的网络前缀比整个单位的网络前缀长一些. CIDR记法有很多种,例如地址块10.0.0.0/10可以简写为10/10,也就是把点分十进制中低位连续的0省略. 另一种简化表示法是在网络前缀后加一个*,如00001010 00*,表示*之前是网络前缀,而*表示IP地址中的主机号,可以是任意值. 使用CIDR时, 由于采用了网络前缀这种记法,IP地址由网络前缀和主机号这两个部分组成,因此路由表中的项目也要相应地改变.这时每个项目由”网络前缀”和”下一跳地址”组成. 但是查找路由表 可能会得到不止一个匹配结果, 因此 应当从匹配结果中选择具有最长网络前缀的路由,这叫做 最长前缀匹配(longest-prefix matching). 这因为网络前缀越长,其地址块就越小,因而路由也就越具体.因此在转发的时候是选择匹配到的地址中更具体的. 最长前缀匹配又称为 最长匹配 或 最佳匹配 路由选择算法 从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分, 则只有两大类: 静态路由选择策略 和 动态路由选择策略 静态路由选择也叫 非自适应路由选择, 适用于简单的小网络. 动态路由选择也叫 自适应路由选择, 适用于复杂的大网络.(因为实现较复杂,开销也比较大) 分层次的路由选择协议 内部网关协议IGP(Interior Gateway Protocol): 在一个自治系统内部使用的路由选择协议.(如RIP和OSPF协议) 外部网关协议EGP(External Gateway Protocol): 若源主机和目的主机处在不同的自治系统中(这两个自治系统可能使用不同的内部网关协议),当数据包传到自治系统的边界时,就要使用外部网关协议. IP多播 多播和单播的区别: 例如要向100台主机发送同一份数据, 单播则要发送90份相同的副本给每个主机,而多播只要发送一个副本就可以了(不需要复制分组). 虚拟专用网VPN和网络地址转换NAT RFC1918指明了一些 专用地址(private address),这些地址只能用于一个机构内部通信,即只能用作本地地址不能用作全球地址. 例如: 10.0.0.0到10.255.255.255 172.16.0.0到172.31.255.255 192.168.0.0到192.168.255.255这三个地址相当于一个A类网络,16个连续的B类网络和256个连续的C类网络. VPN(Virtual Private Network) 使用IP隧道技术实现虚拟专用网. 例子: 某个机构两个场所建立了专用网A和B,其网络地址分别为专用地址10.1.0.0和10.2.0.0.现在这两个场所需要 通过公用的互联网构成一个VPN.显然 每个场所至少有一个路由器具有合法的全球IP地址,这个具有全球IP地址的路由器在专用网内部的接口地址则是专用网的本地地址.即两个场所内主机的相互通信借由连到公网的路由器来转发和接收实现. NAT(Network Address Translation) 需要在专用网连接到互联网的路由器上安装NAT软件.装有NAT软件的路由器叫做 NAT路由器, 它至少有一个有效的全球IP地址.所有使用本地地址的主机和外界通信的时候,都要在NAT路由器上将其本地地址转换成全球IP地址 当NAT路由器具有N个全球IP地址的时候,专用网内部最多 同时 有N台主机可以接入互联网. 现在常用的NAT转换表把运输层的 端口号 也用上, 这样就可以使多个拥有本地地址的主机公用一个NAT路由器上的全球IP地址. 运输层 网络层只是将分组从一台主机传输到另一台主机,而运输层则再将这一通信过程精确到主机中的进程. IP协议虽然能把分组送到目的主机, 但是这个分组还停留在主机的网络层而没有交付主机在的应用程序.从运输层角度来看,通信真正的端点并不是主机而是主机中的进程.也就是说, 端到端的通信是应用进程之间的通信. TCP/IP运输层的两个主要协议: 用户数据报协议UDP(User Datagram Protocol) 和 传输控制协议TCP(Transmission Control Protocol) 传送的数据单元根据协议的不同,分别称为 TCP报文段 和 UDP用户数据报 使用UDP和TCP协议的各种应用和应用层协议 应用 应用层协议 运输层协议 名字转换 DNS(域名系统) UDP 文件传送 TFTP(简单文件传送协议) UDP 路由选择协议 RIP(路由信息协议) UDP IP地址配置 DHCP(动态主机配置) UDP 网络管理 SNMP(简单网络管理协议) UDP 远程文件服务器 NFS(简单网络管理协议) UDP IP电话 专用协议 UDP 流式多媒体通信 专用协议 UDP 多播 IGMP(网际组管理协议) UDP 电子邮件 SMTP(简单邮件传送协议) TCP 远程终端接入 TELNET(远程终端协议) TCP 万维网 HTTP(超文本传送协议) TCP 文件传送 FTP(文件传送协议) TCP 运输层的端口 由于进程的创建和撤销是动态的,所以通信的一方几乎无法识别对方机器上的进程.解决这个问题的方法就是在运输层使用 端口协议号(protocol port number),通常简称为 端口. 不同的端口用来标志不同的应用进程.虽然通信的终点是应用进程,但是只要把所传送的报文交到目的主机的某个合适的目的端口,剩下的工作(交付目的进程)就由TCP和UDP来完成. 这种在协议栈层间的抽象的协议端口是 软件端口,和路由器或交换机的硬件端口是完全不同的概念.硬件端口是不同硬件设备进行交互的接口, 而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址. TCP/IP的运输层用一个16位的端口号来标志一个端口. 注意,端口号只有本地意义,只是为了标记本计算机应用层中各个进程在和运输层交互时的层间接口 互联网上的计算机通信采用客户-服务器方式(C/S方式).客户在发起通信请求的时候,必须知道对方服务器的IP地址和端口号. 运输层端口号分为两大类: 一. 服务器端使用的端口号 这里又可以分为两类: 熟知端口号 和 登记端口号. 熟知端口号是最重要的一类, 又叫做 系统端口号 ,数值为0-1023. 需要记住的常用端口号: 应用程序 熟知端口号 协议类型 FTP 21 TCP TELNET 23 TCP SMTP 25 TCP DNS 53 UDP TFTP 69 UDP HTTP 80 TCP HTTPS 443 TCP SNMP 161 UDP SNMP(trap) 162 UDP 二. 客户端使用的端口号 数值为49152-65535 由于这类端口号仅在客户进程运行时才动态选择,因此又叫做 短暂端口号 当服务器进程收到客户进程的报文时,就知道了客户进程现在所使用的端口号,因而可以把数据发送给客户进程.当通信结束后,刚才使用的客户端口号就不复存在了,这个端口号就可供其他客户进程使用. 连续ARQ协议 将流量控制和差错控制结合了起来. ARQ协议规定,发送方每收到一个确认,就把发送窗口向前滑动一个分组的位置.于是就可以接着发送下一个分组进入窗口的分组. 接收方一般采用累积却认的方式,也就是说接收方不必对收到的分组逐个发送确认,只要对按序到达的最后一个分组发送确认,这表示:到这个分组为止的所有分组都已经正确收到了. 累积确认的优点是:容易实现,即使确认丢失也不必重传.缺点是:不能向发送方反映出接收方已经正确收到的所有分组的信息.(因为可能存在可能没有按序到达的分组,比如收到了1,2,3,5四个分组,只能对前三个进行确认,而5号分组到达的消息发送方没有办法知道,而且很有可能会重传5号分组) TCP可靠传输的实现以字节为单位的滑动窗口 发送窗口表示: 在没有收到B的确认的情况下,A可以连续地把窗口内的数据都发送出去.凡是已经发送过的数据,在未收到确认之前都必须暂时保留以便在超时重传时使用. 接收方会把自己的接收窗口的数值放在窗口字段中发送给对方,这相当于告诉发送方,自己的剩余缓冲区域的大小.因此A的发送窗口一定不能超过B的接收窗口的值. 发送窗口的位置由窗口的前后沿共同决定.发送窗口的后沿不动有两种可能:(1)没有收到新的确认. (2)收到了新的确认但是对方通知窗口缩小了,使得前沿刚好不动. 发送缓存用来暂时存放: 发送应用程序发送给发送方TCP准备发送的数据 TCP已发送出但尚未收到确认的数据 接收缓存用来暂时存放: 按序到达的,但尚未被接收应用程序读取的数据 未按序到达的数据 拥塞控制 拥塞控制与流量控制的区别: 流量控制管理的是两个点,而拥塞控制管理的是整个网络. 计算机网络中的链路容量(即带宽),交换结点中的缓存和处理机等,都是网络的资源.在某段时间,对网络中某一资源的需求超过了该资源所能提供的可用部分,网络性能就要变坏,这种情况就叫 拥塞(congestion) 问题的实质是,整个系统的各个部分不匹配,只有所有部分平衡了,问题才会得到解决. 拥塞控制 : 防止过多的数据注入到网络中,这样可以使网络中的路由器或链路不致过载.拥塞控制是一个全局性的过程,涉及到所有的主机,所有的路由器,以及降低网络传输性能的所有因素. 拥塞控制可以分为 开环控制 和 闭环控制. 开环控制就是事先考虑所有的因素,一旦开始运作就不再更改. 闭环控制是基于反馈回路的概念. TCP的拥塞控制方法慢开始和拥塞避免 发送方维护一个叫做 拥塞窗口cwnd(congestion window) 的状态变量. 发送方让自己的发送窗口等于拥塞窗口. 判断网络拥塞的依据是 出现了超时. 慢开始: 由小到大逐渐增加拥塞窗口(发送窗口). 从慢开始开始指数增长,直到一个阈值(慢开始门限ssthresh),开始加法增长,最后出现超时,再从慢开始从头再来. 当cwnd小于ssthresh时,使用慢开始算法(指数增长).当cwnd&gt;ssthresh时,停止使用慢开始算法 改用拥塞避免算法.(cwnd = ssthresh时两个算法任意选取) 拥塞避免算法 的思路是让拥塞窗口cwnd缓慢地增大,即每过一个RTT就把发送方的拥塞窗口加1.注意拥塞避免并不是完全避免了拥塞,而是是吧拥塞窗口控制为按线性增长,使网络比较不容易出现拥塞. 主动队列管理AQM 随机早期检测RED(Random Early Detection) TCP连接的建立和断开(重点) 三次握手, 四次挥手 ACK=1 表示这是一个确认报文, 对之前收到的报文进行确认. SYN=1 表示这是一个同步报文段,用于请求同步. SYN报文段 不能携带数据, 并且要消耗一个序号 ACK报文段可以携带数据,如果不携带数据 则不消耗序列号 FIN报文段可以携带数据, 但是不管携带与否,都要消耗一个序列号 三报文握手(TCP连接建立) 一开始,B的TCP服务器进程先创建一个 传输控制块TCB(Transmission Control Block), 准备接收客户进程的连接请求. 然后服务器就处于LISTEN(收听)状态 A的TCP客户进程也是首先创建传输控制模块TCB,然后在打算建立TCP连接时,向B发出连接请求报文段,这时首部中的同步位SYN=1,同时 选择一个初始序号seq=x.(SYN报文不能携带数据,但要消耗掉一个序号).TCP客户进程进入SYN-SENT(同步已发送)状态 B收到连接请求报文段后,如同意连接,则向A发送确认.这个确认报文段中SYN位和ACK位都置为1.确认号ack=x+1(由A发送的确认号为x的请求报文而得到的),同时也为自己选择一个初始序号seq=y(注意B的确认报文的seq字段与A的同步报文的seq无关),同时,这个报文也不能携带数据,而且同样要消耗掉一个序列号. 这时TCP服务器进程进入SYN-RCVD(同步收到)状态 确认报文的确认号ack总是等于被确认的报文的序号seq的值加1 TCP客户进程收到B的确认后,还要向B给出确认.(防止A发出的连接请求报文在网络中长时间逗留而没有丢失,在A重新发送请求并且完成连接,结束通信后,B又收到了A之前误以为被丢失而实际只是滞留了的连接请求报文,这时B会以为这是A的一个新的连接请求,从而发送确认给A.而A没有请求,因此会忽略B的这个确认.设想如果没有A的第三次确认,则B以为连接已经建立而无限地等待A发送数据,从而造成资源的浪费.) 确认报文的ACK置为1,确认号为ack=y+1(确认号为y+1是因为这是对B发送过来的报文的确认报文),自己的序号seq=x+1.(如果这个报文没有携带数据,则下一个报文的序号仍然是x+1)这时,TCP连接已经建立,A进入ESTABLISHED(已建立连接)状态. 当B收到A的确认后,也进入ESTABLISHED状态. 四报文挥手(TCP连接释放) 数据传输结束后,通信双方都可以释放连接(释放连接是单向的,可以一方停止向另一方发送数据,但另一方还可以向这一方发送数据).(同时也说明,两个方向都要释放一遍连接) A的应用进程先向其TCP发出连接释放报文段,并停止再发送数据,主动关闭TCP连接.A把连接释放报文段首部的终止控制位FIN置1,其序号seq=u(u等于前面A已经传送过的数据的最后一个字节的序号加1).这时A进入FIN-WAIT-1(终止等待1)状态,等待B的确认. B收到连接释放报文段后立即发出确认,确认号ack=u+1.这个报文段自己的序号为v(v等于B前面已经传送过的数据的最后一个字节的序号加1).然后B就进入CLOSE-WAIT(关闭等待)状态. 这时TCP服务器进程会通知高层应用进程,因而从A到B这个方向上的连接就释放了,这时TCP处于半关闭(half-close)状态,即A已经没有数据要向B发送了,但是如果B要发送数据,A仍然要接收.也就是说从B到A这个方向的连接还未关闭,这个状态可能会持续一段时间. A收到来自B的确认后,就进入FIN-WAIT2(终止等待2)状态,等待B发出的连接释放报文段. 若B也没有要向A发送的数据,其应用进程就通知TCP释放连接.这时B发出的连接释放报文段FIN=1.假定B的序号为w(因为在半关闭状态B可能又发送了一些数据),此时B还必须重复上次发送过的确认号ack=u+1.这时B就进入了LAST-ACK(最后确认)状态,等待A的确认. A在收到B的连接释放报文段后,在确认报文段中把ACK置1,确认号ack=w+1,序号seq=u+1.进入TIME-WAIT(时间等待)状态. 注意!此时TCP连接没有释放掉,必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后,A才进入CKISED状态.时间 MSL 叫做 最长报文段寿命(Maximum Segment Lifetime). 这里A需要等待2MSL(B在收到确认后就立即进入CLOSED状态无需等待)有两个理由: 为了保证A发送的最后一个ACK报文段能够到达B(A发送的ACK确认报文段可能丢失,B会超时重传这个FIN+ACK报文段,而A就能在2MSL时间段内收到重传的FIN+ACK报文段,并重新发送一次确认,重启2MSL计时器). 防止”已失效的连接请求报文段”出现在本连接中.再经过2MSL,就可以使本连接持续时间内所产生的所有报文段从网络中消失,确保下一个连接不会收到旧的无效报文段而引发错误. 最后,TCP还设置 保活计时器(keepalive timer),在服务器长时间(一般为2小时)没有收到客服的数据(服务器每收到一次客户数据就重置这个等待时间),服务器就发送一个探测请求报文,之后每隔75秒发送一次,若连续10次没有收到客户响应,则关闭这个连接.(为了防止客户机出现故障) 应用层 域名系统DNS 域名系统DNS(Domain Name System)能够把互联网上的主机名字转换为IP地址. 每一个域名都由 标号(label) 序列组成,各标号之间用点隔开.例如mail.cctv.com,其中mail为三级域名,cctv为二级域名,com为一级域名.(级别最低的域名写在最左边) 每一个标号不超过63字符,也不区分大小写. 域名解析 过程如下:当某一个应用进程需要把主机名解析为IP地址时,该应用进程就调用 解析程序(resolver), 并称为DNS的一个客户,把待解析的域名放在DNS请求报文中,以UDP用户数据报方式发给本地域名服务器.(使用UDP是为了减小开销) 如果本地域名服务器不能回答该请求,则此域名服务器就暂时成为DNS中的另一个客户,向其他域名服务器发出查询请求. 文件传送协议FTP FTP的工作流程: 打开熟知端口(21),使客户进程能够连接上. 等待客户进程发出连接请求 启动从属进程处理客户进程发来的请求. 回到等待状态 万维网WWW 万维网WWW(Worl Wide Web) 是一个大规模的,联机式的信息储藏所. 超文本: 所谓超文本是指 包含指向其他文档的链接的文本(text).也就是说,一个超文本由多个信息源链组成, 而这些信息源可以分布在世界各地,并且数目不受限制. 超媒体: 超媒体与超文本的区别是文档内容不同.超文本文档仅包含文本信息, 而超媒体文档还包含其他表示方式的信息,如图形,图像,声音,动画以及视频图像等. 万维网以客户服务器方式工作,浏览器就是在用户主机上的万维网客户程序. 客户程序向服务器程序发出请求,服务器程序就向客户程序送回客户所要的万维网文档.在一个客户程序主窗口上显示出的万维网文档称为 页面(page). 三要素URL,HTML和HTTP 万维网使用 统一资源定位符URL(Uniform Resource Locator) 来标志万维网上的各种文档,并使每一个文档在整个互联网的范围内具有唯一的标识符URL.(解决怎样标志分布在整个互联网上的万维网文档) 超文本传送协议HTTP(HyperText Transfer Protocol): HTTP是一个应用层协议,使用TCP连接进行可靠的传送.HTTP协议使得万维网客户程序与万维网服务器程序之间的交互严格遵守这一标准.(解决用什么样的协议来实现万维网上的各种链接) 万维网使用 超文本标记语言HTML(HyperText Markup Language),使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到互联网上的任何一个万维网页面.(解决各种不同风格的文档都能在各种不同的主机上显示出来的问题) 电子邮件 TCP/IP协议规定的电子邮件地址的格式如下:用户名@邮件服务器域名 电子邮件最重要的两个标准就是: 简单邮件传送协议SMTP(Simple Mail Transfer Protocol)[RFC 5321] 和 互联网文本报文格式[RFC 5322] 邮件读取协议POP3和IMAP(Internet Message Access Protocol). 不要把POP3或IMAP与SMTP弄混,发件人的用户代理向发送方邮件服务器发送邮件,以及发送方邮件服务器向接收方邮件服务器发送邮件,都使用SMTP协议. 而POP3或IMAP是用户代理从接收方邮件服务器上读取邮件时所使用的协议. 动态主机配置协议DHCP DHCP提供了一种机制,即 即插即用网(plug-and-play networking).这种机制允许一台计算机接入新的网络和获取IP地址而不用手工参与. 简单网络管理协议SNMP SNMP(Simple Network Management Protocol)的网络管理由三个部分组成: 即SNMP本身,管理信息结构SMI(Structure of Management Information) 和 管理信息库MIB(Management Information Base)]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>๑Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记——指针]]></title>
    <url>%2F2018%2F12%2F19%2FC%2B%2B_ptr%2F</url>
    <content type="text"><![CDATA[典型错误 12long * fellow;*fellow = 23333; fellow的确是一个指针,但是它指向的地址还没确定,那么23333会被存放到哪里呢?我们也不知道,这就会引发一个编译错误. 指针使用的金科玉律: 一定要在对指针解除引用运算符(*)之前,将指针初始化为一个确定的,适当的地址. ——–from C++ Primer Plus 指针和数字 例子:12int * pt;pt = 0xB8000000; 在这里左边是一个int类型的指针,而右边是一个 整数, 0xB8000000是老式计算机系统中组合段的偏移地址,但是在这条语句中编译器并不知道这是个地址,因此C++编译器会报错. 正确的写法应该是:12int * pt;pt = (int *) 0xB8000000; 使用new来分配内存 在C语言中,只能用库函数malloc()来分配内存,C++也支持这样做,但是有更好的选择—new运算符. new运算符同时要配合delete来使用 例子: 123int * pt = new int;...delete pt; 这将释放pt指向的内存块,但不会删除指针pt本身,它的值也没有改变. 一点要配对地使用new 和 delete,否则会发生内存泄漏(memory leak). 不要尝试释放已经释放的内存块,这会导致很严重的不确定性. 不能使用delete来释放声明变量所获得的内存:(也就是delete只能用来删除new分配的内存) 123456int * ps = new int; //okdelete ps; //okdelte ps; //not ok nowint jugs = 5; //okint * pi = &amp;jugs; //okdelete pi; //not allowed now, memory not allocated by &apos;new&apos; 使用new创建动态数组 12345int num = 100;int * psome = new int[num];//可以使用psome[0]这样的形式来访问数组元素,与普通的数组无异...delete []psome; delete的方括号告诉程序,应该释放整个数组,而不是仅仅是指针指向的元素 C++将数组名解释为地址(一般情况) 数组名被解释为其第一个元素的地址,而对数组名应用取地址符时,得到的是整个数组的地址. 123short tell[10];cout &lt;&lt; tell &lt;&lt; endl; //display &amp;tell[0]cout &lt;&lt; &amp;tell &lt;&lt; endl; //display address of whole array 上面这个例子中,从数值上来说,这两个地址相同;但从概念上来说,&amp;tell[0](即tell)是一个2字节内存块地址,而&amp;tell是一个20字节内存块的地址.因此,表达式tell+1将地址的值加2,而表达式&amp;tell+1将地址的值加20. 换句话说:tell是一个short指针(short),而&amp;tell是一个这样的指针,即指向包含20个元素的short数组(short()[20]). 这种指针可以这样初始化:short (*pas)[20] = &amp;tell.这里pas的类型为short (*)[20] 小结 应将内存地址赋值给指针. 可以是对已经赋值的变量名使用&amp;来获得 被命名的内存的地址, 或者使用new运算符返回未命名的内存的地址,只有这两种情况可以赋值给指针.]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 面向对象编程]]></title>
    <url>%2F2018%2F11%2F25%2Fpython-class%2F</url>
    <content type="text"><![CDATA[模块与包 简单举例就是: 1234mypackage├─ __init__.py├─ abcd.py└─ efgh.py 注意每个包下需要一个__init__.py文件 如果另一个py文件需要引用abcd.py,则写为mypackage.abcd python类 类不需要显式地申明类成员变量(与C++和Java不同) 类中所有的方法的第一个参数都是self, self代表类的实例而非类,并且在调用类方法时,self参数不必传入. __init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法 python类内置属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是’main.className’，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 判断一个对象是否是一个类的实例 目前我所知的只有两个方法可行(python3):1234a = myclass()b = myclass()type(a) == type(b) #a和b都是类实例isinstance(a, myclass.__bases__) #虽然__bases__返回的是父类元组,但是却能成功判断]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18 VsCode搭建C++编译环境(已测试)]]></title>
    <url>%2F2018%2F11%2F21%2Fvscode-cpp%2F</url>
    <content type="text"><![CDATA[坑了一早上,终于摸索出两个编译运行C++的方法,特此记录. 环境 安装VsCode和g++环境这里就不赀述了 安装C++插件 安装一系列C++的插件,我安装的有:12C/C++C/C++ Intellisense 重点 两种方法编译C++文件第一种:安装C/C++ Compile Run插件(简单,推荐) 人生苦短,何必浪费时间在环境搭建上~ 虽然只支持单文件(single file)的编译和运行,但是日常使用足够了啊 打开C++文件F6即可运行 官方使用手册: RequirementsIf you are on linux you must install gccIf you are on window you must install mingwHow to useMake sure you have .c or .cpp file open and press “F6”, this will compile the file. If you want to register gcc/g++ path manually you can set it under settings. You can also set to save file before compiling. 第二种:手动添加task.json和launch.json 打开C++文件,切换到Debug下,运行一次,他会创建一个默认文件,改成如下即可: 12345678910111213141516171819202122232425&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;preLaunchTask&quot;: &quot;build&quot;, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; 然后切回C++文件,Ctrl + Shift + B build &gt;&gt; 选择other新建一个 &gt;&gt; 修改tasks.json如下: 123456789101112131415161718192021&#123; &quot;version&quot;: &quot;0.1.0&quot;, &quot;showOutput&quot;: &quot;always&quot;, &quot;tasks&quot;: [ &#123; &quot;taskName&quot;: &quot;build&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;isShellCommand&quot;: true, &quot;showOutput&quot;: &quot;always&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot; ], &quot;problemMatcher&quot;: [ &quot;$g++&quot; ] &#125; ] &#125; 最后 Ctrl + Shift + B build 点击debug下的绿色箭头即可运行 愿天下再没有配环境的坑~]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑C++</tag>
        <tag>๑Ubuntu</tag>
        <tag>๑VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10蓝屏巨坑--已填]]></title>
    <url>%2F2018%2F11%2F14%2Fwin10-problem-01%2F</url>
    <content type="text"><![CDATA[win10蓝屏问题 最近一个月也不知道干了啥,Windows有时候就是莫名其妙地蓝掉…内心无比崩溃 而且是我在玩Fortinite的时候无限崩… 问题规律 最近在使用Android Studio开发, 但是莫名其妙就模拟器打不开, intel虚拟线程插件安装也报错,就很炸裂. 偶然间又打开了我的木木模拟器,结果马上蓝屏!!! 至此我发现了蓝屏的一点规律性—跟模拟器(虚拟化技术)有关!! 有了线索,问题便得以解决 经过几番搜索和尝试, 最终锁定了问题的源泉—Windows服务–Hyper-V 原来是Windows自己的虚拟化技术与别的虚拟化技术有冲突, 导致了蓝屏的问题. 解决 Ctrl+R -&gt; control.exe(控制面板) -&gt; 启动或关闭Windows功能 -&gt; 取消Hyper-V服务 -&gt;重启电脑]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>๑Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10使用navicat链接mySQL错误]]></title>
    <url>%2F2018%2F11%2F09%2FmySQL-download-windows%2F</url>
    <content type="text"><![CDATA[错误代码 安装mysql8.0服务器端，连接Navicat会提示报错：1251 Client does not support authentication protocol requested by server; consider upgrading MySQL client 网上一堆方法,但是很麻烦 根本原因 最后终于发现了发生这种情况的根本原因,就是加密方式的更新. 由于最新版的MySQL安装的时候,推荐使用了一种最新的加密方式,就是在安装过程中,Authentication Method这一配置过程，给了两个基于不同的加密方式. 第一个是推荐的,当时我也没多想就选了第一个,所以才导致了后面的状况. 解决 再次打开mysql的安装程序,这里不需要卸载重装,选择更改设置, 将Authentication Method的加密方式改为第二个兼容加密方式就可以在navicat正确链接了.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>๑Windows</tag>
        <tag>๑mySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker使用]]></title>
    <url>%2F2018%2F11%2F08%2Fdocker-learning-02%2F</url>
    <content type="text"><![CDATA[需要的docker image可以从Docker Hub获取 Docker images Docker images文件: Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 查看本机的image文件:docker image ls 删除某个image:docker image rm [imageName] 获取image docker image pull 仓库路径/文件名 运行 docker container run containID 可以先用docker image ls查看所有的镜像文件. 同时docker container run当本地仓库不存在相对应的image时,会自动从远程仓库获取,所以上面pull的一步不是必须的. 终止 有些容器需要手动终止,使用命令:docker container kill containID Docker container image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行。 列出正在运行的容器:docker container ls 列出所有的容器: docker container ls --all 删除容器 docker container rm containerID 删除之后的容器不会再出现在容器列表里 创建自己的docker容器 待更新 补充 注意,docker container run命令是创建一个container,每运行一次就会多一个容器,如果要重复使用一个容器需要用:docker container start 查看容器的输出,即容器里面shell的标准输出:docker container logs containerID. 如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。 进入一个正在运行的容器:docker container exec -it containerID /bin/bash.如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的Shell执行命令了。 从容器中拷贝文件到本地:$ docker container cp containID:[/path/to/file] [/dest/path/]. 如果要拷贝到当前目录,则可以写为:$ docker container cp [containID]:[/path/to/file] .]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>๑Ubuntu</tag>
        <tag>๑Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18 安装Docker]]></title>
    <url>%2F2018%2F11%2F08%2Fdocker-learning-01%2F</url>
    <content type="text"><![CDATA[为什么用Docker 环境搭建一直是运维一件非常头疼的事情, 如果系统崩溃而重新安装系统,则所有的环境都需要重新搭建一遍,非常耗时而且恼人. 我使用的Ubuntu18下配置好了大量的环境,如果这时候要我重新安装一遍的话,就算我做了详细的记录,也至少是一下午的工作量. 而Docker相当于一个容器,与虚拟机不同,虚拟机模拟了一个完整的操作系统,非常消耗系统资源,而且就算不做任何操作,内存也必须被占用.而Docker是容器,基于Linux容器的概念,封装而成. Docker将运行在其中的软件隔离开来, 不占用额外的系统资源. Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 Docker Hub Docker Hub是一个平台,注册之后我们可以下载使用别人搭建好的image,非常方便. Ubuntu18安装Docker 由于Docker被墙得厉害,导致经常性地连官网也进不去. 我们为了安装过程的顺利,首先切换到中国科技大的源: 123sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo sed -i &apos;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&apos; /etc/apt/sources.listsudo apt update 安装需要的包:sudo apt install apt-transport-https ca-certificates software-properties-common curl 添加 GPG 密钥，并添加 Docker-ce 软件源: 123curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \$(lsb_release -cs) stable&quot; 更新缓存:sudo apt update 安装Docker-ce:sudo apt install docker-ce 测试Helloworld:sudo docker run hello-world 结果: 添加当前用户到 docker 用户组，可以不用 sudo 运行 docker: 12sudo groupadd dockersudo usermod -aG docker $USER docker pull之后文件的存放目录 使用docker pull XXX下载的文件存放在/var/lib/docker/中 其中目录结构如下: containers中每个序列号都是一个镜像 Docker是使用repositories JSON文件来记述镜像信息的，此JSON文件包含了仓库名、标签、以及标签对应的镜像ID。 Uninstall Docker-ce 摘自官方文档 Uninstall the Docker CE package:sudo apt-get purge docker-ce Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:sudo rm -rf /var/lib/docker]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>๑Ubuntu</tag>
        <tag>๑Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页状态码记录]]></title>
    <url>%2F2018%2F11%2F07%2Fweb-learning-01%2F</url>
    <content type="text"><![CDATA[HTTP状态码 五个不同的类别: 1. 1XX临时/信息响应 2. 2XX成功 3. 3XX重定向 4. 4XX客户端/请求错误 5. 5XX服务器错误 五个类别的响应状态代码的第一个数字是唯一代表。 4XX 服务器外部错误400 400 无法解析此请求。说明正在搜索的网页可能已经删除、更名或暂时不可用。 401.X 401.1 未经授权：访问由于凭据无效被拒绝。说明没有权限查看该目录或网页。 401.2 未经授权: 访问由于服务器配置倾向使用替代身份验证方法而被拒绝。由于服务器配置问题而导致登陆失败，由于服务器端脚本未能正确发送 WWW 身份验证头文件字段。如果要通过 Active Server Pages 脚本完成此项任务，可以使用&quot;Response&quot;对象的&quot;AddHeader&quot;方法来要求客户端用特定身份验证方法访问资源。 401.3 未经授权：访问由于 ACL 对所请求资源的设置被拒绝。 401.4 未经授权：Web 服务器上安装的筛选器授权失败。如果Web 服务器安装了筛选器程序以检查连接到服务器的用户。该筛选器程序能够禁止通过连接到服务器的身份验证来访问资源。 401.5 未经授权：ISAPI/CGI 应用程序授权失败。由于 ISAPI/CGI 应用程序导致授权失败。如果所要访问的 Web 服务器地址上安装了 ISAPI 或 CGI 程序用于在继续执行之前检验用户证书。该程序能够禁止通过连接到服务器的身份验证证书来访问资源。 401.7 未经授权：由于 Web 服务器上的 URL 授权策略而拒绝访问。 403.X 403 禁止访问：访问被拒绝。 403.1 禁止访问：执行访问被拒绝。由于&quot;执行&quot;访问被禁止而造成的，若试图从目录中执行 CGI、ISAPI 或其他可执行程序，但该目录不允许执行程序时便会出现此种错误。 403.2 禁止访问：读取访问被拒绝。导致此错误是由于没有可用的默认网页并且没有对目录启用目录浏览，或者要显示的 HTML 网页所驻留的目录仅标记为&quot;可执行&quot;或&quot;脚本&quot;权限。 403.3 禁止访问：写入访问被拒绝。当试图将文件上载到目录或在目录中修改文件，但该目录不允许&quot;写&quot;访问时就会出现此种错误。 403.4 禁止访问：需要使用 SSL 查看该资源。由于要求SSL而造成的，您必须在要查看的网页的地址中使用&quot;https&quot;。 403.5 禁止访问：需要使用 SSL 128 查看该资源。由于要求使用 128 位加密算法的 Web 浏览器而造成的，如果您的浏览器不支持128位加密算法就会出现这个错误，您可以连接微软网站进行浏览器升级。 403.6 禁止访问：客户端的 IP 地址被拒绝。如果服务器中有不能访问该站点的 IP 地址列表，并且您使用的 IP 地址在该列表中时您就会返回这条错误信息。 403.7 禁止访问：需要 SSL 客户端证书。 403.8 禁止访问：客户端的 DNS 名称被拒绝。由于禁止站点访问而造成的，若服务器中有不能访问该站点的 DNS 名称列表，而您使用的 DNS 名称在列表中时就会返回此种信息。请注意区别403.6与403.8错误。 403.9 禁止访问：太多客户端试图连接到 Web 服务器。由于连接的用户过多而造成的，由于Web 服务器很忙，因通讯量过多而无法处理请求时便会返回这条错误。 403.10 禁止访问：Web 服务器配置为拒绝执行访问。由于无效配置而导致的错误，当您试图从目录中执行 CGI、ISAPI 或其他可执行程序，但该目录不允许执行程序时便会返回这条错误。 403.11 禁止访问：密码已更改。 403.12 禁止访问：服务器证书映射器拒绝了客户端证书访问。由于映射器拒绝访问而造成的。若要查看的网页要求使用有效的客户证书，而您的客户证书映射没有权限访问该 Web 站点时就会返回映射器拒绝访问的错误。 403.13 禁止访问：客户端证书已在 Web 服务器上吊销。由于需要查看的网页要求使用有效的客户证书而使用的客户证书已经被吊销，或者无法确定证书是否已吊销造成的。 403.14 禁止访问：在 Web 服务器上已拒绝目录列表。 403.15 禁止访问：Web 服务器已超过客户端访问许可证限制。 403.16 禁止访问：客户端证书格式错误或未被 Web 服务器信任。 403.17 禁止访问：客户端证书已经到期或者尚未生效。 403.18 禁止访问：无法在当前应用程序池中执行请求的 URL。 403.19 禁止访问：无法在该应用程序池中为客户端执行 CGI。 403.20 禁止访问：Passport 登录失败。 404.X 404 找不到文件或目录。由于无法找到文件而造成的，通常是由于正在搜索的网页可能已经删除、更名或暂时不可用。 404.1 文件或目录未找到：网站无法在所请求的端口访问。表明所访问 Web 站点的 IP 地址不接受对端口（请求的来源端口）的请求。404.1 错误只会出现在具有多个 IP 地址的计算机上。如果在特定 IP 地址/端口组合上收到客户端请求，而且没有将 IP 地址配置为在该特定的端口上侦听，则 IIS 返回 404.1 HTTP 错误。例如，如果一台计算机有两个 IP 地址，而只将其中一个 IP 地址配置为在端口 80 上侦听，则另一个 IP 地址从端口 80 收到的任何请求都将导致 IIS 返回 404.1 错误。只应在此服务级别设置该错误，因为只有当服务器上使用多个 IP 地址时才会将它返回给客户端。 404.2 文件或目录无法找到：锁定策略禁止该请求。 404.3 文件或目录无法找到：MIME 映射策略禁止该请求。 else 405 用于访问该页的 HTTP 动作未被许可。由于资源被禁止而导致的网页地址不正确，因此要寻找的网页无法显示。 406 客户端浏览器不接受所请求页面的 MIME 类型。由于浏览器无法打开正在寻找的资源而导致的错误。 407 Web 服务器需要初始的代理验证。 410 要寻找的网页已被永久删除而导致的，这意味着资源永远无法使用。 412 客户端设置的前提条件在 Web 服务器上评估时失败。412错误是由于要查看的网页设置有先决条件，因此该请求无法完成。一般是网页中有一个或多个请求标题字段中具有先决条件，这些字段经服务器测试后被认为是&quot;FALSE&quot;。客户端为当前资源的 meta 信息（头文件字段数据）设置了先决条件，以便防止请求的方法被用于指定资源外的其他资源。 414 请求 URL 太大，因此在 Web 服务器上不接受该 URL。一般的可能性有： 1）客户端错误地将 POST 请求转换为带有长查询信息的 GET 请求。 2）或者是客户端遇到重定向问题（例如，重定向 URL 的前缀指向自身的后缀）。 3）服务器遭到客户端的攻击，该客户端试图利用那些使用定长缓冲来读取或控制请求 URI 的服务器上的安全漏洞。 5XX 服务器内部错误 500 服务器内部错误。 500.11 服务器错误：Web 服务器上的应用程序正在关闭。 500.12 服务器错误：Web 服务器上的应用程序正在重新启动。 500.13 服务器错误：Web 服务器太忙。 500.14 服务器错误：服务器上的无效应用程序配置。 500.15 服务器错误：不允许直接请求 GLOBAL.ASA。 500.16 服务器错误：UNC 授权凭据不正确。 500.17 服务器错误：URL 授权存储无法找到。 500.18 服务器错误：URL 授权存储无法打开。 500.19 服务器错误：该文件的数据在配置数据库中配置不正确。 500.20 服务器错误：URL 授权域无法找到。 500-100.asp 内部服务器错误：ASP 错误。 501 标题值指定的配置没有执行。 502 Web 服务器作为网关或代理服务器时收到无效的响应。由于网关错误而造成的，当作为网关或代理的服务器与上层内容服务器联络时，收到无效的响应时就会出现502错误。 参考 https://blog.csdn.net/aaa_aa000/article/details/46997991 参考https://www.jianshu.com/p/d50bcc605a13]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>๑Web</tag>
        <tag>๑Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven构建项目的pom.xml文件详解]]></title>
    <url>%2F2018%2F11%2F07%2FMaven-learning-02%2F</url>
    <content type="text"><![CDATA[Maven仓库 Maven仓库分为本地仓库,中央仓库和远程仓库. 中央仓库可以查询和获取大量常用的库—-地址 远程仓库是当我们在中央仓库也获取不到需要的库时,才会用到的. 一般也不会用到远程仓库. 仓库搜索顺序 首先,maven会在本地仓库中搜索依赖的库,如果没有就去中央仓库,如果中央仓库也找不到,但是pom文件里设置了远程仓库,则去远程仓库中获取,否则就会报错,找不到依赖的文件. Maven项目的创建 我们一般使用intellij IDEA来创建maven项目 其中的gourpId一般的命名格式为: 组织名，公司网址的反写 + 项目名称 项目模板 Maven 使用 archetype(原型) 来创建自定义的项目结构，形成 Maven 项目模板。 我们在intellij IDEA中新建maven项目时,可以选择从创建一个archetype,这样maven会自动为pom.xml文件添加一些dependency Maven快照(SNAPSHOT) 快照是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，Maven 每次构建都会在远程仓库中检查新的快照。 对于版本，如果 Maven 以前下载过指定的版本文件，比如说 data-service:1.0，Maven 将不会再从仓库下载新的可用的 1.0 文件。若要下载更新的代码，data-service 的版本需要升到1.1。快照的情况下，每次快照的更新，Maven 将自动获取最新的快照(data-service:1.0-SNAPSHOT)。 快照和版本是用于团队开发时的,快照是为了避免频繁地手动更新pom文件,也避免了版本号的滥用.]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Maven</tag>
        <tag>๑Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven构建项目的pom.xml主要标签解释]]></title>
    <url>%2F2018%2F11%2F07%2FMaven-learning%2F</url>
    <content type="text"><![CDATA[Maven pom.xml文件标签详解 菜鸟教程-maven标签详解,为了方便记录到自己的博客下. 记录 标签 描述 project 工程的根标签 modelVersion 模型版本,一般设为4.0 groupId 工程组的标志,一个项目或者一个组织一般是唯一的 artifaciId 工程标识,是工程的名称 version 工程版本号,在artifact的仓库中用来区分不同的版本 build 该元素设置了项目脚本的源码目录,当构建项目的时候,构建系统会编译目录里的源码,该路径相对于pom.xml是相对路径 dependencies 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。 dependency 上个标签的子目录,一个dependency包含一个依赖]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Maven</tag>
        <tag>๑Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitignore的使用及写法]]></title>
    <url>%2F2018%2F10%2F27%2Fgitignore-learning%2F</url>
    <content type="text"><![CDATA[gitignore的作用 对于git同步到github来说，估计没有人会 git add 文件名这样的方式来添加到工作区的，都是git add .这样一次添加吧 但是，有时候我们直接add所有的文件会将一些我们不需要的生成的临时文件也加入进去，导致文件冗余。同时，更有可能的是我们在push的时候失败，由于一些不支持的文件类型或者文件大小过大。 这时候我们就需要gitignore脚本来过滤我们需要上传的文件。 命名格式以及位置 命名统一为.gitignore windows下由于不能文件名为空，则可以先命名为.gitignore.，回车确定之后windows会自动将最后一个点去掉。 .gitignore文件放在根目录下即可。 内容写法 gitignore本质上是一个按正则表达式匹配文件名/文件夹名的文件。 语法：(与正则表达式几乎一致) 空行或是以#开头的行即注释行将被忽略 以斜杠 /结尾表示目录 以星号*通配多个字符 以问号 ? 通配单个字符 以方括号 [] 包含单个字符的匹配列表 以叹号 ! 表示不忽略(跟踪)匹配到的文件或目录 参考 添加github仓库 github上有一个为各种环境和编程语言提供gitignore模板的项目——https://github.com/github/gitignore 他的项目介绍是：This is GitHub’s collection of .gitignore file templates. We use this list to populate the .gitignore template choosers available in the GitHub.com interface when creating new repositories and files.(意思大概就是可以用它来实现在创建repository的时候可以选择初始化一个.gitignore文件，并且可以选择一个模板) 我们在创建github仓库的时候尽量先预先创建好.gitignore文件，因为一旦push之后，添加了新的.gitignore貌似也是不起作用的，非常麻烦，所以要养成写.gitignore的好习惯。]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>๑Git</tag>
        <tag>๑Ubuntu</tag>
        <tag>๑Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18 Pycharm无法识别安装的Python库的解决方案]]></title>
    <url>%2F2018%2F10%2F16%2Fpycharm-problem-solving%2F</url>
    <content type="text"><![CDATA[凌晨更~ pycahrm无法识别 我们有时候在需要使用一些第三方python库的时候，需要pip install XXX，然而愉快地安装完了之后，在pycharm中新建项目import却失败，提示找不到。 这个问题坑了好久，在终端里使用完全没有问题然而pycahrm里却不行。今天终于下定决心搞定这个问题。 首先从默认python版本下手 由于我使用的是ubuntu18.04，其默认的python版本是python2.7，而我在IDE里使用的是后来安装的python3.6版本，因此pip install的module不会被识别(因为终端里pip install 命令使用的解释器版本是2.7，安装的module也只能被2.7版本的识别) 首先执行python --version查看当前默认版本 然后查看当前已安装的所有版本ls /usr/bin/python* 接着修改系统信息：(需要管理员权限) 123root@fleschier-GE5S:/home/fleschier# update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1root@fleschier-GE5S:/home/fleschier# update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2update-alternatives: 使用 /usr/bin/python3.6 来在自动模式中提供 /usr/bin/python (python) --install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /usr/bin/python3.6 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。 参考更改Ubuntu默认python版本的两种方法 一个坑接着一个坑 默认python版本改完了，下面就是pip了 改完之后会发现，执行pip命令会提示没有这个module。。。好吧又是坑 解决方案：sudo apt-get install python3-pip 安装完成然后就可以使用pip的一系列命令了 更新pip版本 python -m pip install --upgrade pip 参考stackoverflow的一个问题 然后就是重新安装我们需要的库了 我这里要搞一个python绘图，需要matplotlib库 按照其官方的安装方法(仍然需要管理员权限否则最后一步会失败提示权限不够):python -m pip install -U matplotlib 或者是一般的安装pip3 install moduleName 最后 最后就是网上烂大街的解决方法，指定pycharm的编译器为python3.x，即可～]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记——一些报错信息归因]]></title>
    <url>%2F2018%2F10%2F08%2FC%2B%2B-learning-error-collection%2F</url>
    <content type="text"><![CDATA[Expression: public_stream != nullptr 出现这个原因的问题很简单，就是用fopen打开文件失败了，创建的文件指针为空引起的。 解决方法就是查看文件路径是否正确。 在最后fclose的时候，先判断一下文件指针是否为空。 abort() has been called 出现这个错误的原因基本上是越界或者内存泄漏。 这里的越界包括指针越界和数组越界]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记——强大的sprintf]]></title>
    <url>%2F2018%2F10%2F08%2FC%2B%2B-sprintf-printf%2F</url>
    <content type="text"><![CDATA[sprintf()函数与printf()函数 sprintf()函数与printf()函数的用法几乎一样。只是前者是将内容打印到字符串中，后者直接在命令行打印出来。 sprintf()函数原型： int sprintf( char *buffer, const char *format [, argument] ... ); 除了前两个参数固定，后面可以接任意多个参数。 第二个参数为格式化字符串，printf 和sprintf 都使用格式化字符串来指定串的格式，以%开头，然后在后边的变参列表中提供相应的变量，最终相应的位置的变量就会被替换进来。 sprintf最常见的应用之一莫过于把整数打印到字符串中，所以，spritnf 在大多数场合可以替代itoa。 例子： 12sprintf(s, &quot;%d&quot;, 123);sprintf(s, &quot;%8d%8d&quot;, 123, 5678); //指定宽度，不足的左边补空格，结果为&quot; 123 5678&quot; 浮点数用%f控制，默认打印6位小数。 使用%d或者%x打印一个字符，便能得出它的10进制或16进制的ASCII码；反过来，使用%c打印一个整数，便可以看到它所对应的ASCII字符。因为char类型本质上也是存储数值类型，只是习惯上用char来表示字符，实际上char就是byte，一个字节的数值类型。 实现各种各样格式化字符串 sprinf就是将格式化字符串里的所有内容打印到第一个参数(字符数组)中，因此也可以用来连接字符串，非常灵活。 spritnf和printf都最终返回本次函数调用最终打印到字符缓冲区中的字符数目。 转换说明符 格式符 格式符 说明 %a(%A) 浮点数、十六进制数字和p-(P-)记数法(C99) %c 字符 %d 有符号十进制整数 %f 浮点数(包括float和doulbe) %e(%E) 浮点数指数输出[e-(E-)记数法] %g(%G) 浮点数不显无意义的零”0” %i 有符号十进制整数(与%d相同) %u 无符号十进制整数 %o 八进制整数 %x(%X) 十六进制整数0f(0F) %p 指针 %s 字符串 %% 输出字符% 标志 标志 例子(说明) 左对齐：”-“ %-20s 右对齐：”+” %+20s 空格 若符号为正，则显示空格，负则显示”-“ 比如：”% 6.2f” # 对c,s,d,u类无影响；对o类，在输出时加前缀o；对x类，在输出时加前缀0x；对e,g,f 类当结果有小数时才给出小数点。 sprintf使用过程中遇到的一些问题记录 编译器报错：Buffer is too small 出现这个情况是因为被赋值的字符数组太小了。 实例：(矩阵乘积) 123456789101112131415161718192021222324//计算矩阵的乘积...... char tmpc[24]; //存储转换的值,因为存储的是双精度浮点数，这里数据的整数部分为10位，小数部分要显示11位则至少开10+1+11=22位的数组才够 for (int i = 0; i &lt; M; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; C[i][j] = 0; //initialize the result martrix element for (int k = 0; k &lt; K; k++) &#123; C[i][j] += A[i][k] * B[k][j]; &#125; //--------------------------------------------------------------------------------------------- //itoa不如sprintf灵活，这里采用sprintf来完成double到char的转换 ////将数字转化为char数组写入, 采用itoa函数。函数原型：char *itoa(int value, char* string, int radix); //_itoa(C[i][j], tmpc, 10); //fputs(tmpc, fout); //fputs的第一个参数为char* //fputc(32, fout); //写入空格，fputc的第一个参数为int*(ASCII码) //--------------------------------------------------------------------------------------------- //使用强大的sprintf来完成转换，打印11位小数 sprintf_s(tmpc, &quot;%.11f &quot;, C[i][j]); //这里的数值是整数部分10位，小数点一位，小数部分11位，末尾空格1位，结束符&apos;\0&apos;一位所以一共要开24位的数组才够 fputs(tmpc, fout); //fputs的第一个参数为char* &#125; fputc(10, fout); //写入换行符 &#125; ...]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记——数值类型,char和string的相互转化问题]]></title>
    <url>%2F2018%2F10%2F08%2FC%2B%2B-Int-Char-String-translation%2F</url>
    <content type="text"><![CDATA[C++提供了一些功能强大的函数来高效地完成这些转化 string转char 使用c_str()方法 示例： 123string s = &quot;abcd&quot;;char p[10];p = (char*)s.c_str(); 上面的强制类型转换在 不修改字符串内容的情况下 是可以省略的。因为c_str()方法的返回值类型为const char*，返回的是一个不可修改的指向该字符串的指针。 使用data()方法 data()方法与c_str()方法用法几乎一致，这里不再赀述。 使用copy()方法 copy()方法与上面两种有所不同，它是拷贝函数，这只是他的一种用法。 实例: 1234string s = &quot;abcd&quot;;char p[5];s.copy(p, 4, 0); //4代表拷贝四个字符，0代表写入的位置*(p + 4) = &apos;\0&apos;; //拷贝的字符串需要手动加上结束标记 char转string 对于已经存在的char*，可以直接赋值给string类型的数据 数值类型转string C++库有直接的转换函数to_string() to_string()函数有多个重载函数，支持目前所有的数据类型转换为string类型。 需要引入头文件#include&lt;string&gt; -12345#include&lt;string&gt;...int a = 10;string s = to_string(a);... 数值类型转char 这里就需要用到强大的转换函数itoa()。 还有ltoa,ultoa等函数可以将 任意类型(整型、长整型、浮点型等)的数字 转换为字符串。 需要引入头文件stdlib.h 示例： 123456789#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;int main()&#123; int i = 100; char p[10]; itoa(i, p, 10); //说明：第一个参数为待转换的数字，第二个参数为待存储数值的char数组指针，第三个参数为待转换数字的进制，这里为十进制。 cout &lt;&lt; p &lt;&lt; endl;&#125; itoa并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。 字符串转数值类型 函数原型为 int atoi (const char * str); //参数为指针类型，如果为string需要在变量名前加取址符。 atoi() 函数会扫描参数str字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过isspace()函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(\0)才结束转换，并将结果返回。 ANSI C 规范定义了 stof()、atoi()、atol()、strtod()、strtol()、strtoul()共6个可以将字符串转换为数字的函数。另外在 C99 / C++11 规范中又新增了5个函数，分别是 atoll()、strtof()、strtold()、strtoll()、strtoull()。这里根据名称就可以对应看出各个函数的转换目标。]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark实际操作过程中的一些调优笔记]]></title>
    <url>%2F2018%2F09%2F13%2FSpark-notes%2F</url>
    <content type="text"><![CDATA[Spark调优的一些参数设置 SparkConf的一些参数设置 见博客Spark性能优化：资源调优篇 较为全面的一个Spark性能参数讲解 Spark性能相关参数配置 spark分区器 主要有HashPartitioner和RangePartitioner两种。 HashPatitioner按照给定key计算出的HashCode通过模运算来分区，缺点是可能造成分区出现数据倾斜。 RangePartioner尽量保证每个分区中数据量的均匀，而且分区与分区之间是有序的(分区内部无序)。在分区计算时可能需要消耗部分资源，因此选择那种分区方法应看具体情况。 Spark分区器HashPartitioner和RangePartitioner代码详解]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑BigData</tag>
        <tag>๑Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala IO 记录]]></title>
    <url>%2F2018%2F09%2F06%2Fscala-io%2F</url>
    <content type="text"><![CDATA[控制台IO 调用java的IO库 scala使用java的io类来读取 需要引入java的io类：import java.io._ 使用Java的BufferedReader和InputStreamReader方法来实现 例： 12val br = new BufferedReader(new InputStreamReader(System.in))val x = br.readLine().trim //注意readLine的L是大写 所有的读入的内容都是String类型，可以使用toInt，toDouble等方法来将输入转化成各种需要的格式 调用scala的IO库 例: 1234567import scala.io._object Test &#123; def main(args: Array[String]) &#123; val line = StdIn.readLine() ... &#125;&#125; scala的IO库更为简洁，可以调用readInt(),readBoolean等一系列方法，直接进行转换。 Scala2.11 后的版本 Console.readLine 已废弃，使用 scala.io.StdIn.readLine() 方法代替。 文件IO 需要引入scala.io库 例子(读取test.txt文件的内容)： 12345678910import scala.io.Sourceobject Test &#123; def main(args: Array[String]) &#123; println(&quot;文件内容为:&quot; ) Source.fromFile(&quot;test.txt&quot; ).foreach&#123; println &#125; &#125;&#125;]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo重新构建博客]]></title>
    <url>%2F2018%2F09%2F03%2FHexo-rebuild%2F</url>
    <content type="text"><![CDATA[环境搭建 在使用hexo搭建博客之前，需要搭建好环境。需要git、node.js和hexo 详细搭建见——链接 hexo hexo有大量的主题可供选择，而且支持一键部署 但是hexo每次预览要重新生成页面，而jekyll是即时体现更改 安装 npm install -g hexo-cli 常用命令 初始化： hexo init //在一个空文件夹下初始化 hexo一些命令： 1234567$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; # 新建页面$ hexo generate # 生成静态页面至public目录 =hexo g$ hexo server # 开启预览访问端口(默认端口4000，&apos;ctrl+c&apos;关闭server) = hexo s$ hexo deploy # 项目部署 = hexo d$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本 一些问题记录 无法’hexo d’:缺少插件 使用命令：npm install hexo-deployer-git --save (在博客的根目录下执行) 侧边栏文章索引错乱 尽量不要使用跳跃式的标题，比如使用了一个一号标题，然后使用了一个三号标题，接着又使用了一个一号标题，这样很容易就会出现错乱的现象。 标题应当逐级递增逐级递减，这样规范之后才会有清晰美观的显示效果。 部署到git 部署到Github前需要配置_config.yml文件: 1234deploy: type: git repository: git@github.com:Fleschier/Fleschier.github.io.git branch: master 然后输入:hexo d 三部曲 修改然后预览 123hexo cleanhexo ghexo s --debug //运行预览同时实时生成错误报告 修改然后部署 123hexo cleanhexo ghexo d 添加页面 刚使用的主题是默认只有两个页面的，home和archive。要添加页面，需要在source中添加文件夹并创建index.md文件。 例如，添加tags页面： 新建tags文件夹，并创建index.md 在index.md中写入如下内容： 123456---title: tagsdate: 2016-09-05 23:41:32type: &quot;tags&quot;comments: false--- 到_config.yml文件中将对应的路径添加进去(next主题默认是将这几个页面注释掉的，取消注释即可) 重新建站即可看到效果 添加搜索引擎支持 首先登录google的Search Console 因为hexo每次clean都会将验证的html删除，所以我们采用其他的验证方法。将Search Console给的meta标签的信息添加到主题的目录下head.swig文件中，这里使用的是Next主题,其他主题也是类似的，在Hexo/themes/next/layout/_partials/head/head.swig文件中原有meta标签后面添加刚才复制的meta标签。 百度搜索引擎 百度验证与google验证方法一致 重新deploy博客之后可以验证通过 一些细节补充见博客 安装插件 为Hexo安装hexo-generator-sitemap和hexo-generator-baidu-sitemap插件，在Hexo博客目录下运行：12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 重新建站 配置Hexo的_config.yml文件，添加如下字段: 1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 在博客的_config.yml文件中添加博客的url,否则生成的站点地图在提交的时候会报错。 例如我的： 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://fleschier.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults: 重新生成博客页面即可看到sitemap.xml文件和baidusitemap.xml文件 最后分别在google和百度搜索引擎界面提交各自的站点地图即可。 添加robots文件 可以在source文件夹下添加robots.txt文件来限制爬虫抓取网页的内容范围 robots例子： 123456789101112131415# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Allow: /tags/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://Fleschier.github.io/sitemap.xmlSitemap: https://Fleschier.github.io/baidusitemap.xml 文章中的图片 由于换到hexo,图片的文件夹在themes文件夹下的source文件夹中,我们在博客中写图片路径时还是/images/...这样即可. md文章命名 hexo文章的命名不需要日期。日期在文章的开头的date属性里写。 11.4日更 hexo文章统计阅读量 使用leanCloud来完成访问统计 需要设置安全链接,参考博客 问题错误码429 出现这个问题的报错信息是too many requests,原因是我们使用leanCloud的免费版本线程数是十分受限的,在我们deploy的时候发送了太多的同步请求导致线程栈溢出而报错. 解决方案 —hexo-leancloud-counter-security 插件 Too many requests 错误 问题依旧存在 使用leanCloud deploy之后博客修改的内容迟迟没有生效不知为何,用git的方法deploy之后就能很快生效,难道只能两个方法各deploy一次?待续… 更新 原来是我还缺少了一个步骤,就是需要在leanCloud的云引擎&gt;设置&gt;deploy中将自己的github仓库地址填入,并且将其deploy key添加到我们github的仓库deploy key 一栏中.如下 最后不要忘了在leanCloud上点保存,并且生成生产环境: 但是好像还是不能同步到github…待更新]]></content>
      <categories>
        <category>Personal Blog</category>
      </categories>
      <tags>
        <tag>๑Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Scala编程》阅读记录——列表进阶]]></title>
    <url>%2F2018%2F07%2F24%2Fscala-learning-04%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 第十六章 使用列表 列表的使用方法表格见另一篇博客 列表跟数组非常像，但是有两个重要的区别： 列表是不可变的，也就是说列表的元素不能通过赋值改变 列表是递归的(即链表)，而数组是平的 init和last要消耗的时间与列表的长度成正比，而head和tail消耗常量级别的时间 indices方法返回包含了指定列表所有有效的下标，所以一般用在for表达式遍历列表时： 1234val lst = new List(&quot;af&quot;,&quot;g3g&quot;,&quot;g53v&quot;)for( i &lt;- lst.indices)&#123; //这里i即是从lst的第一个有效下标开始直到最后一个下标 ...&#125; flatten方法：接受一个列表的列表并返回单个列表 例子： 12scala&gt; List(List(1,2),List(3),List(),List(4,5)).flattenres0: List[Int] = List(1,2,3,4,5) 例子： zip和unzip zip操作接受两个列表，返回一个有对偶组成的列表 如果两个列表的元素个数不同，那么任何没有配对上的元素将被丢弃 zipWithIndex方法 例子： 1234scala&gt; val abcde = List(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;)abcde: List[Char] = List(a,b,c,d,e)scala&gt; abcde.zipWithIndexres0: List[(Char,Int)] = List((a,0),(b,1),(c,2),(d,3),(e,4)) 任何元组的列表都可以通过unzip方法转换回由列表组成的元组 显示列表 下面一些例子：12345678scala&gt; abcde mkString(&quot;[&quot;, &quot;,&quot;, &quot;]&quot;)res0: String = [a,b,c,d,e]scala&gt; abcde mkString &quot;&quot;res1: String = abcdescala&gt; abcde.mkStringres2: String = abcdescala&gt; abcde mkString (&quot;List(&quot;, &quot;, &quot;, &quot;)&quot;)res3: String = List(a,b,c,d,e) 过滤列表 filter，partition，find，takeWhile，dropWhile和span 这些过滤函数的参数都是T =&gt; Boolean类型的 x.takeWhile(p)返回x列表中连续满足p的最长前缀，例：nums.takeWhile(_ &gt; 0) x.dropWhile将去除列表x中连续满足p的最长前缀，例：words.dropWhile(_.startsWith(&quot;t&quot;)) 对列表前提条件的检查 forall和exists xs.forall(p)，如果列表中所有元素都满足p则返回true xs.exists(p)，如果列表中有至少一个元素满足p则返回true 最后更新于2018.7.24]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Scala编程》阅读记录——集合类进阶]]></title>
    <url>%2F2018%2F07%2F24%2Fscala-learning-05%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 第十七章 使用集合类 序列列表 List类是不可变 链表, 因此支持在头部快速添加和移除条目，但是不提供按下标快速访问的功能，因为实现这个功能需要线性地遍历列表。 列表缓冲(ListBuffer) List类提供对列表头部的快速访问，但是对尾部就不那么高效，因此在尾部添加元素时我们经常需要用到reverse方法，在头部添加元素最后再reverse来获得我们想要的顺序 ListBuffer是一个可变对象(包含在scala.collection.mutable中)，帮助我们在需要追加元素来构建列表时能够更加高效。ListBuffer提供了常量时间的往前和往后追加元素的操作。 可以使用+=来往后追加元素，使用+=:来往前追加元素 最后可以使用toList方法来转换成List类型 使用ListBuffer的另一个原因是可以防止可能的栈溢出 数组缓冲(ArrayBuffer) 创建数组缓冲的时候不需要指定长度，只要给定类型 12import scala.collection.mutable.ArrayBufferval buf = new ArrayBuffer[Int]() 使用+=方法来追加元素 所有的数组的常规操作都是可以用的 字符串(通过StringOps) StringOps实现了很多序列的方法。由于Predef有一个从String到StringOps的隐式转换，可以将任何字符串当做序列来处理 例如: 12def hasUpperCase(s: String) = s.exists(_.isUpper)hasUpperCase(&quot;Robert Frost&quot;) 这里由于String类本身并没有任何名为exists的方法，但是StringOps有，通过隐式转换将s转换成StringOps来实现 集和映射 使用集 集的关键特征是它们会确保在同一时刻，以==为标准，集里的每个对象都最多出现一次 集的方法见博客方法查询 使用映射 映射使用键来索引对应的值 下面是一个统计每个单词在字符串中出现次数的方法： 1234567891011def countWords(text: String) = &#123; val counts = mutable.Map.empty[String,Int] for (rawWord &lt;- text.split(&quot;[ ,!.]+&quot;))&#123; val word = rawWord.toLowerCase // 统一变为小写字母 val oldCount = if(counts.contains(word)) counts(word) else 0 counts += (word -&gt; (oldCount + 1)) &#125; counts&#125; 映射的方法见博客方法查询 可变集合和可变映射的工厂方法都采用了hash的技术。例如scala.collection.mutable.Set()这个工厂方法返回一个scala.collection.mutable.HashSet。同理， scala.collection.mutable.Map()这个工厂方法返回一个scala.collection.mutable.HashMap 元组 元组帮助我们省去定义那些简单的主要承载数据的类的麻烦。元组的一个常见的应用场景是从方法返回多个值 最后更新于2018.7.24]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10使用过程中遇到的一些坑]]></title>
    <url>%2F2018%2F07%2F23%2Fwindows-realated%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 解决windows下atom字体模糊的问题 这种情况是由windows下GPU的一些优化带来的问题，主要是会导致字体模糊。 也有人说是由于抗锯齿导致的问题 更改方法如下： 关闭windows自动更新 首先ctrl+s呼出小娜，搜索service,出现服务这个匹配项。 在弹出的窗口中找到Windows Update的本地服务，右键 -&gt; 属性，在弹出的窗口中，首先点击并停止服务，然后将启动类型由自动改为手动。 重启电脑即可。]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>๑Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Scala编程》阅读记录——类进阶]]></title>
    <url>%2F2018%2F07%2F23%2Fscala-learning-03%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 第十章 组合和继承 面向对象进阶抽象类 例子：123abstract class Element&#123; def contents: Array[String]&#125; 注意，Element类中content方法没有标上abstract修饰符。一个方法只要是没有实现的(即没有等号或方法体)，那么它就是抽象的。跟Java不同，我们不能对方法加上abstract修饰符 定义无参方法 例子： 12345abstract class Element &#123; def contents: Array[String] def height: Int = contents.length def width: Int = if(height == 0) 0 else contents(0).length&#125; 这个无参方法的特点是，如果将def换成val，那么他就成了一个字段而不会有编译错误 在这里无参方法和字段的区别是：字段的调用会更加快，但是每次实例化对象都要分配内存空间。具体取舍要看具体的用法。 总结下来就是，scala推荐我们将那些没有参数也没有副作用的方法定义为无参方法，而对于无参数而有副作用的方法不应当省略空括号，例如： 12&quot;hello&quot;.length //没有()，因为没有副作用println() //有()，因为有副作用 扩展类 使用extends关键字，相当于继承 scala中所有类的默认父类是AnyRef 继承的意思是超类的所有成员也是子类的成员，但是有两个例外：一个是超类的私有成员不会被子类继承；二是如果子类实现了相同名称和参数的成员，那么该成员不会被继承(重写，override) scala只有两个命名空间用于定义： 值(字段，方法，包和单例对象) 类型(类和特质名) 因此scala可以用val来重写一个无参方法(即将一个无参方法重写为一个字段) 如果我们要在子类中重写父类的方法，则要在方法前加上override修饰符：override def funcName(...){...} 使用final修饰符来确保某个成员不能被子类继承 scala的继承关系图 第十二章 特质 特质的定义跟类定义很像，除了关键字trait scala可以使用extends或者with关键字来 混入 特质，而不是继承。 例子：class Frog extends Animal with Philosophical with HasLegs{..}混入多个特质用with连接 要点如下: Scala中类只能继承一个超类, 可以扩展任意数量的特质 特质可以要求实现它们的类具备特定的字段, 方法和超类 与Java接口不同, Scala特质可以提供方法和字段的实现 当将多个特质叠加使用的时候, 顺序很重要 scala特质详细解析 重写特质的抽象方法时, 不需要override关键字 可以为类和对象添加多个相互调用的特质时, 从最后一个开始调用. 这对于需要分阶段加工处理某个值的场景很有用. 第十三章 包和引入 scala的引入可以出现在任何地方，不仅仅是某个编译单元的开始 例如，假设一个Fruit类，其中有有name和color字段。有如下的一个函数： 1234def showFruit(fruit: Fruit) = &#123; import Fruit._ println(name + &quot;s are&quot; + color)&#125; showFruit引入了其参数fruit(Fruit类)的所有成员。下面的name和color就相当于fruit.name和fruit.color 第十四章 断言和测试 在scala中，断言的写法是对预定义方法assert的调用。 表达式：assert(condition)。如果condition不满足则抛出AssertionError 另一种：assert(condition,explanation)如果condition不满足则抛出指定的explanation的AssertionError 第十五章 样例类和模式匹配 样例类使用case关键字修饰，scala编译器会自动创建工厂方法，即可以直接用className(parameter1,parameter2,...)而不用new关键字即可创建对象 模式匹配，例子： 1234expr match&#123; case BinOp(...) =&gt; println(...) case _ =&gt; //处理器默认case,这一行是必须的，否则所有非满足第一个条件的case都会返回MatchError&#125; 通配模式(_)会匹配任何对象 第二十章 抽象成员 所有四种抽象成员：val，var，方法和类型 例子：下面这个特质声明了四种抽象成员：一个抽象类型(T)，一个抽象方法(transform)，一个val(initial)和一个var(current) 123456trait Anstract&#123; type T def transform(x: T): T val initial: T var current: T&#125; scala的抽象类型指的是用type关键字声明为某个类或者特质的成员(但并不给出定义)的类型。类或者特质都不能够叫抽象类型，抽象类型永远是某个类或者特质的成员，比如Abstract特质中的T lazy关键字：如果在val关键字前面加上lazy关键字，则该变量会在第一次被使用时被赋值。 T是指一个在声明时还未知的类型。不同的子类可以提供不同的T的实现 最后更新于2018.7.24]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop集群使用中的一些问题记录]]></title>
    <url>%2F2018%2F07%2F20%2Fcluster-usage%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 无法运行spark-shell 一般出现这种情况是集群的内存满了 使用df -h命令来查看存储情况 空间几乎占满的状况： Linux下/proc目录简介 linux下proc目录的作用 删除文件夹 尽量使用rmdir来删除一个空目录，如果目录下存在多个文件，要一次性删除所有的使用rm -rf来实现。-r表示递归删除，-f表示强制执行。不过在删除之前一定要仔细确认，一旦删除无法撤销]]></content>
      <categories>
        <category>Hadoop CLuster</category>
      </categories>
      <tags>
        <tag>๑Linux</tag>
        <tag>๑Hadoop</tag>
        <tag>๑CLuster</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Scala编程》阅读记录——进阶部分]]></title>
    <url>%2F2018%2F07%2F19%2Fscala-learning-02%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 概念 序列 Seq trait用于表示序列。所谓序列，指的是一类具有一定长度的可迭代访问的对象，其中每个元素均带有一个从0开始计数的固定索引位置。 常用线性序列有 scala.collection.immutable.List和scala.collection.immutable.Stream。常用索引序列有 scala.Array scala.collection.mutable.ArrayBuffer。Vector 类提供一个在索引访问和线性访问之间有趣的折中。它同时具有高效的恒定时间的索引开销，和恒定时间的线性访问开销。正因为如此，对于混合访问模式，vector是一个很好的基础。 缓冲器 Buffers是可变序列一个重要的种类。它们不仅允许更新现有的元素，而且允许元素的插入、移除和在buffer尾部高效地添加新元素。buffer 支持的主要新方法有：用于在尾部添加元素的+= 和 ++=；用于在前方添加元素的+=: 和 ++=: ；用于插入元素的 insert和insertAll；以及用于删除元素的 remove 和 -=。 第四章 类和对象 在类定义中，我们会填入字段(field)和方法(method)，这些统称为成员(member) 保持健壮性，我们可以将字段声明为私有(在字段前面加上private修饰符)，访问和修改都通过方法来实现。scala的默认访问级别是public scala方法参数有一个特征，就是 它们都是val而不是var 一个类的例子： 123456789class test&#123; private var sum = 0 def add(b: Byte): Unit = &#123; sum += b &#125; def checksum(): Int = &#123; return ~(sum &amp; 0xFF) + 1 &#125;&#125; 在方法中，没有任何显式的return语句时，scala返回的是该方法计算出的最后一个(表达式的)值 ,因此上面这个例子的return语句可以省略不写 同时，另一种方法的简写方式是，当一个方法只会计算一个返回结果的表达式时，可以不写花括号。如果这个表达式很短，他甚至可以被放置在def的同一行。为了极致的精简，还可以省略掉结果类型。 更改后的写法： 12345class test&#123; private var sum = 0 def add(b: Byte) = sum += b def checksum() = ~(sum &amp; 0xFF) + 1&#125; 在这段代码中，scala能够正确地推断出add和checksum这两个方法的结果类型。但是最好的写法是显式地给出结果类型，这样便于代码的调试和维护 本例中的add方法结果类型为Unit，执行它的目的就是产生副作用。对于那些仅仅为了其副作用而被执行的方法被称作过程。 一般分号是没有必要加的，但是如果一行写多个语句，则用分号间隔 单例对象 scala比Java更面向对象一点，是scala 不允许有静态成员。因此，scala提供了单例对象，单例对象与普通的类很像，只是将class关键字换成了object 当单例对象跟某个类共用同一个名字时，它被称作这个类的 伴生对象(companion object) 必须在同一个源码文件中定义类和类的伴生对象，同时，类又叫做这个单例对象的 伴生类(companion class) 类和它的伴生对象可以互相访问对方的私有成员 单例对象当中的方法可以像Java中的静态方法一样直接通过类名来访问 单例对象不仅仅用来存放静态方法，他是一等的对象，可以把单例对象想象成附加在对象身上的“名字标签” 类和单例对象的区别是单例对象不能被实例化(即没法new一个单例对象，除非这个单例对象有伴生类) 单例对象在有代码首次访问时才会被初始化 没有同名的伴生类的单例对象称为 孤立对象(standalone object)，一般用来将工具方法归集在一起，或定义scala程序的入口。 scala应用程序 要运行一个scala程序，必须提供一个孤立对象，这个孤立对象需要包含一个main方法，该方法接收一个Array[String]作为参数，结果类型为Unit,例如：12345object Test&#123; def main(args: Array[String]): Unit = &#123; ... &#125;&#125; 注意：scala在每一个源码文件都隐式地引入了java.lang和scala包的成员，以及名为Predef的单例对象的所有成员。例如使用的println和assert都是来自于Predef 注意要运行这个程序，那么文件名需要与这个单例对象的名称相同。 App特质 scala提供了一个特质scala.App，我们可以不用编写main方法，而是将打算放在main方法里的代码直接写在单例对象的花括号里。不过首先要在单例对象名后加上extends App。例子：12345object AppTest extends App&#123; for(i &lt;- 0 to 10)&#123; println(&quot;...&quot;) &#125;&#125; 它可以像正常的scala程序一样运行 第五章 基础类型和操作一些基础类型 Byte、Short、Int、Long和Char类型统称为 整数类型，整数类型加上Float和Double类型统称为 数值类型 String是java.lang包的成员 注意这些数据类型实际上都是封装好的类，所以首字母都是大写 Long类型以l或者L结尾 字符串插值： 12val name=&quot;reader&quot;println(s&quot;Hello, $name&quot;) 这个的结果与println(&quot;Hello&quot; + name)是一样的 scala中raw可以屏蔽转义字符/，例如println(raw&quot;abc\n\n&quot;)其中斜杠和n将被原样输出 scala中判断任意两个对象都可以用==方法，甚至可以是与null值进行比较而不会报错，并且总能返回正确的比较结果。scala的== 只比较值，而Java的引用类型的==比较的是引用是否相同。 赋值操作符=的优先级是最低的,而像*=这样的操作符也被当做赋值操作符，因此其优先级不如+操作符 第六章 函数式对象 如果要在类中重新实现一个已经实现的方法，例如toString方法，要用到override关键字 例如override def toString = {...} 一个例子：创建一个有理数的类，这是个不可变的类并且要求分母不为零 1234class Rational(n: Int, d:Int)&#123; require(d!=0) override def toString = n + &quot;/&quot; + d&#125; require方法接受一个boolean的参数。如果传入的参数为true，require将会正常返回。否则,require将会抛出IllegalArgumentException来阻止对象的构建。 添加字段 例如添加一个add方法：123def add(that: Rational): Rational = new( new Rational(n * that.d + that.n * d, d * that.d)) 这个方法是会报错的 上面那个类如果要添加一个add方法，实现两个Rational类型的值的相加，此时add是不能直接调用this.n或者this.d的(虽然类参数n和d在add方法中是在作用域内的，但是编译器并不允许使用that.n和that.d，因为that并非指向调用add的那个对象，要访问that的d和n，需要将它做成字段(相当于成员变量))我们需要添加字段才行： 1234567891011class Rational(n: Int, d:Int)&#123; require(d != 0) val numer: Int = n val denom: Int = d override def toString = numer + &quot;/&quot; + denom def add(that: Rational): Rational = new Rational( numer * that.denom + that.numer * denom, denom * that.denom )&#125; scala中 字段 默认的访问权限是public 自引用 使用关键字this，写法为this.字段名，也可以直接写字段名，用法与C++和Java一致 辅助构造方法：def this(...){...} 操作符也可以像方法一样定义，例如： 1def + (that: MyClass): MyClass =&#123;...&#125; scala支持方法重载，用法与C++和Java相同，通过定义多个参数不同的同名函数来实现重载 第七章 内建的控制结构 scala的控制语句都有返回值，可以直接拿来用 例子：println(if (!args.isEmoty) args(0) else &quot;default.txt&quot;) 形如 a &lt;- b的称为生成器语法 1 to 4 包含上界 4 1 until 4 不包含上界 4 过滤 有时候遍历集合的时候不想完整地遍历集合，而是先过滤成一个子集。这时可以给for表达式添加过滤器(filter)例： 123val filesHere = (new java.io.File(&quot;.&quot;)).listDilesfor(file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;)) println(file) 过滤器就是for表达式圆括号中的一个if子句，并且可以随意添加更多的过滤器，直接添加if子句即可 嵌套迭代 如果添加多个&lt;-子句，将得到嵌套的循环例： 123456789101112def fileLines(file: java.io.File) = scala.io.Source.fromFile(file).getLines().toListdef grep(pattern: String) = for( file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;); trimed = line.trim line &lt;- fileLines(file) if trimed.matches(pattern) ) println(file + &quot;: &quot; + line.trimed)grep(&quot;.*gcd.*&quot;) 其中，外部循环遍历filesHere，内部循环遍历每个以.scala结尾的file的fileLines(file) 其中trimed作为中途变量绑定，用来保存line.trim的值，避免line.trim被重复计算两次 match表达式 例子： 123456789val firstArg = if (args.length &gt; 0) args(0) else &quot;&quot;val friend =firstArg match &#123; case &quot;salt&quot; =&gt; println(&quot;pepper&quot;) case &quot;chips&quot; =&gt; println(&quot;salsa&quot;) case &quot;eggs&quot; =&gt; println(&quot;bacon&quot;) case _ =&gt;println(&quot;huh?&quot;)&#125;println(friend) 这个例子中，match 表达式跟java的switch相比，有一些很重要的区别。其中一个区别是任何常量、字符串等都可以用作样例。另一个区别是，每个可选项后面没有break，因为scala中break是隐含的，不会出现某个可选项执行完又执行下一个的情况 match表达式会返回值，上例可以直接将匹配的结果打印出来 一般不会用到continue和break 例如一段java代码： 12345678910111213int i = 0;boolean foundIt = false;while (i &lt; args.length)&#123; if(args[i].startsWith(&quot;-&quot;))&#123; i = i + 1; continue; &#125; if(args[i].endsWith(&quot;.scala&quot;))&#123; foundIt = true; break; &#125; i = i+ 1&#125; scala可以写成： 123456789var i = 0var foundIt : Boolean = falsewhile (i &lt; args.length &amp;&amp; !foundIt)&#123; if(!args(i).startsWith(&quot;-&quot;))&#123; if(args(i).endsWith(&quot;.scala&quot;) foundIt = true &#125; i = i + 1&#125; 或者用递归函数代替循环： 1234567def searchFrom(i: Int): Int = &#123; if(i &gt;= args.length) -1 //未找到返回-1 else if(args(i).startsWith(&quot;-&quot;)) searchFrom(i + 1) //递归查找下一处 else if(args(i).endsWith(&quot;.scala&quot;)) i //找到了就返回 else searchFrom(i + 1)&#125;val i = searchFrom(0) 这个递归去掉了循环，每一个continue都换成了一次以i+1为入参的递归调用 第八章 函数和闭包 局部函数 我们可以在某个函数内部定义函数，就像局部变量一样，这样局部函数只在包含他的代码块中可见，实现了与类中私有方法相同的效果。例：12345678910def processFile(filename: String, width: Int) = &#123; def processLine(line: String) = &#123; //局部函数可以访问包含它们的函数的参数 if(line.length &gt; width) println(filename + &quot;: &quot; + line.trim) &#125; val source = Source.fromFile(filename) //从文件名创建一个名为source的Source对象 for (line &lt;- source.getLines())&#123; //getLines()返回一个每次迭代从文件读取一行并去掉换行符的迭代器 processLine(filename, width, line) &#125;&#125; 一等函数* 函数字面量被编译成类，并在运行时实例化为函数值。因此，函数字面量和函数值的区别在于，函数字面量存在于，函数字面量存在于源码，而函数值以对象的形式存在于运行时 一个函数字面量的简单示例：(x: Int) =&gt; x + 1 =&gt;表示该函数将左侧的内容转换成右侧的内容，因此这是一个将任何整数x 映射 成 (x + 1)的函数 函数值是对象，所以还可以将他们存放在变量中。同时他们也是函数，也可以用常规的圆括号来调用他们： 123var increase = (x: Int) =&gt; x + 1 //可以将函数字面量赋值给变量val n = increase(10) //可以像一般的函数一样调用increase = (x: Int) =&gt; x + 999 //因为increase是var类型，还可以重新赋值 如果在函数字面量中有多于一条语句，可以将函数体用花括号括起来 所有的集合类(List,Set,Array,Map)都提供了foreach方法，它接受一个函数作为入参，并对它的每个元素调用这个函数 同时，集合类还有个filter方法。这个方法从集合中选出那些满足条件的元素。这个指定条件由函数表示,例如：(x: Int) =&gt; x &gt; 0这个方法可以被用来过滤。 这个函数将所有的正整数映射成true，所有其他的整数映射成false 函数字面量的简写形式 一种更为简要的方法是省去参数类型声明：someNumbers.filter((x) =&gt; x &gt; 0) 同时圆括号也可以去掉，因为可以省略掉自动推断类型的参数的圆括号：someNumbers.filter(x =&gt; x &gt; 0) 占位符语法 为了让函数字面量更加精简，还可以使用下划线作为占位符，用来表示一个或多个参数，只要满足每个参数只在函数字面量中出现一次即可。例如：_ &gt; 0 是一个非常短的表示法，表示一个检查某个值是否大于0的函数 例子：someNumber.filter(_ &gt; 0) 可以将下划线当成是表达式中需要被”填”的”空”。函数每次被调用，这个空都会被一个入参给填上 如果someNumber被初始化为List(11,10,9,8)，那么filter方法首先把 _ &gt; 0中的空替换成11，即 11 &gt; 0，然后替换成10，以此类推，直到List末尾 有时候当你用下划线作为参数占位时，编译器可能没有足够的信息来推断缺失的参数类型。 例如： 1234scala&gt; val f = _ + _&lt;console&gt; error: missing parameter type for expandedfunction ((x$1, x$2) =&gt; x$1.$plus(x$2))... 这种情况下，可以用冒号来给出类型，就像这样： 1234scala&gt; val f = (_: Int) + (_: Int)f: (Int, Int) =&gt; Int = &lt;function0&gt;scala&gt; f(5,10)res0: Int = 15 注意，_ + _将会展开成一个接收两个参数的函数字面量。这就是为什么只有当每个参数在函数字面量中出现不多不少正好一次的时候才能使用这样的精简写法。多个下划线意味着多个参数，而不是对单个参数的重复利用。 部分应用的函数 下划线还能替换掉整个参数列表，例如： 123456scala&gt;def sum(a:Int, b:Int, c:Int) = a + b + csum: (a:Int, b:Int, c:Int)Intscala&gt;val a = sum _a:(Int, Int, Int) =&gt; Int = &lt;function3&gt;scala&gt; a(1,2,3)res0: Int = 6 后面的a 即是基于sum创建的一个部分应用函数 特殊的函数调用形式重复参数 scala允许你标示出的参数的最后一个参数可以被重复，这样我们可以对函数传入一个可变长度的参数列表。这样一个重复参数的表示，需要在参数的类型之后加上一个*号：123scala&gt; def echo(args: String) = for (arg &lt;- args) println(arg)echo: (args: String*)Unit 这样echo就可以接受任意多个String类型的参数(可以是0个) 但是如果要将一个适合类型的数组以这种重复参数的形式传入的时候，需要写成如下形式：123456scala&gt; var arr = Array(&quot;a&quot;,&quot;v&quot;,&quot;gf&quot;)arr:Array[String] = Array(a,v,gf)scala&gt; echo(arr: _*)avgf 这种表示法告诉编译器将arr的每个元素作为参数传给echo，而不是将所有元素放在一起作为单个实参传入 尾递归 例子：123def approximate(guess: Double): Double = if (isGoodEnough(guess)) guess else approximate(improve(guess)) 在合适的isGoodEnough和improve函数的实现下，这个函数就是一个递归函数。而这个递归调用在最后一步的函数称为尾递归(tail recursive)函数 scala编译器对尾递归函数有特殊的优化，能够检测到尾递归并将他替换为跳转到函数的最开始，并在跳转之前更新参数的值 也就是说，我们完全可以用尾递归的方法来代替循环而不用付出任何额外的开销 尾递归不会在每次调用时构建一个新的栈，所有的调用都会在同一个栈中进行 如下有个例子： 123def boom(x: Int): Int = if(x == 0) throw new Exception (&quot;boom!&quot;) else boom(x - 1) + 1 这个函数不是一个尾递归的，因为 它在递归调用之后还执行了一个递增操作 但是scala中尾递归是受限的，更高级形式的尾递归实现十分困难。scala只能对那些直接尾递归的函数做优化 第九章 控制抽象 减少代码重复 例子： 12345def filesMatching(query: String, matcher: (String, String) =&gt; Boolean) = &#123; for (file &lt;- filesHere; if matcher(file.getName, query)) yield file&#125; 在这个方法中，if子句用matcher来检查文件名是否满足条件，这个检查具体做什么，取决于具体的matcher。matcher本身是一个函数，因此类型声明中有一个=&gt;符号。这个函数接受两个字符串类型的参数(分别是文件名和查询条件)，返回一个布尔值，因此这个参数的类型为(String, String) =&gt; Boolean 下面三个方法分别使用三种不同的参数matcher来实现不同的文件查找功能: 12def filesEnding(query: String) = filesMatching(query, _.endsWith(_)) 12def filesContaning(query: String) = filesMatching(query, _.contains(_)) 12def filesRegex(query: String) = filesMatching(query, _.matches(_)) 其中，_.endsWith(_)的含义与下面的代码是一样的(fileName: String, query: String) =&gt; fileName.endsWith(query) 两个下划线按顺序作为传入的两个参数的占位符 最后更新于2018.7.23]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Scala编程》阅读记录——入门部分]]></title>
    <url>%2F2018%2F07%2F12%2FScala-learning-01%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 入门 scala是一门函数式编程语言,同时也是面向对象的 函数值就是对象 scala对面向对象的实现是纯的：每个值都是对象，每个操作都是方法调用 例如，两个Int类型的相加（注意scala里所有的数据类型首字母都是大写，这说明了他们都是类），+实际上是调用了一个名为+的方法 函数式编程以两大核心概念为指导： (1)函数是一等的值：函数值可以作为参数传递给其他函数，可以作为返回值，可以保存在一个变量里。还可以在一个函数里定义另一个函数，就像在函数里定义一个整数一样。也可以在定义函数时不指定名字。 (2)程序中的操作应该将输入值映射成输出值，而不是当场修改数据。例如Java对String的修改就是生成了一个新的String对象而原先的String不变。这个理念的另一种表述就是函数不应该有副作用(sideeffect)。方法只能通过接受入参数和返回结果这两种方式与外部通信，即参数本身不会被修改，这样的方法被称为是“指称透明的”。函数式编程鼓励不可变的数据结构和指称透明的方法。 Scala可以选择使用指令式编程的方法，即使用可变数据和副作用编程。但是推荐使用函数式编程。 scala定义类的简便的写法： class MyClass(index: Int, name:String)这样scala编译器就会产生带有两个 私有 实例变量和一个接受这两个变量初始值的参数的构造方法类 假设name是一个String 类型的变量val IfHasUpperCase = name.exists(_.isUpper) 这段代码实现了判断name中是否存在大写字母，并赋值给IfHasUpperCase这个Boolean类型的变量(scala赋值时如果不明确写出变量类型，则编译器会自动判断) scala代码将字符串当做更高级的字符序列(sequence) 来处理，用 前提(predicate) 来处理 这里的 前提 _.isUpper 是scala的函数字面量(当函数字面量的结果类型是Boolean时，可以被称作前提)。它描述了一个接受 字符 作为 入参(以下划线表示)，判断该字符是否为大写字母的函数。 布尔值不能和整数相加 scala几乎所有语法结构都支持嵌套 scala输出： println(&quot;....&quot;) 注意编译器不会推断函数参数的类型，因此函数中参数的数据类型要显式地写出 scala函数形式： 12345def FuncName(x:Int, y:Int): Int = &#123; if(...)&#123;..&#125; else&#123;..&#125; x&#125; 注意函数结果类型前面的冒号不能省（这里函数的格式实际山是与变量保持一致的，即类型跟在冒号后面） scala的函数会将函数体里的最后一条语句的值作为函数的返回值（例子里的函数将x的值返回） 大多数时候函数的结果类型不需要显式地给出。但是递归函数必须显式地给出结果类型 scala表达式if(x&gt;y) x else y的行为，与Java里的(x&gt;y)? x:y的含义一致 编译scala脚本：scala hello.scala 命令行参数可以通过名为args的scala数组来获取：println(&quot;Hello &quot; + args(0) + &quot;!&quot;) 然后执行： $ scala hello.scala planet //其中planet被当做参数传入 结果： Hello planet! 尽量少用for 和 while 循环 foreach遍历 打印每一个命令行参数的方式：args.foreach(arg =&gt; println(arg))这段代码中，对args执行foreach方法，传入一个函数。本例中传入的是一个函数字面量(function literal) 这个(匿名)函数接受一个名为arg的参数(arg仅仅是参数名没有别的特殊含义)上面也可以指明类型名(这样需要将参数的部分包在圆括号里，这是函数字面量的常规语法)：args.foreach((arg:String) =&gt; println(arg)) scala函数字面量语法： (x:Int, y: Int) =&gt; x + y其中从左到右，括号中的是参数部分，然后是右箭头，最右边是函数体 scala对函数字面量还有一个特殊的简写规则：如果函数字面量只是一个接收单个参数的语句，可以不必给出参数名和参数本身。因此上例可以写为：args.foreach(println) scala只支持指令式的for语句的函数式亲戚。for表达式 for表达式一个简单的例子： 12for(arg &lt;- args) println(arg) 其中，位于 &lt;- 符号右边的，是args数组，在 &lt;- 左边的是一个 val变量的名字，为arg。注意左边的这个变量一定是 val类型 的(即它不能在for表达式循环体里被重新赋值)，并且只能写为 arg 而不能写成 val arg 用类型参数化数组 在scala中，可以用new来实例化对象或类的实例，当实例化对象时，可以用值和类型来对其进行参数化(parameterize) 参数化的意思是：在创建实例的时候对实例做”配置”，可以用值来参数化一个实例，做法是在构造方法的括号中传入对象参数。 参数化创建数组： 1234val myArr = new Array[String](3)myArr(0) = ...myArr(1) = ...myArr(2) = ... 另一种创建方法： val numArr = Array(&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;) 这实际上是调用了一个名为apply的工厂方法，这个方法创建并返回了新的数组。这个apply方法接受一个变长的参数列表。 scala数组使用 圆括号 来访问元素而不是方括号，原因(原文)： 数组不过是类的实例，这一点跟其他scala的实例没有本质区别。当你用一组圆括号讲一个或多个值包起来，并将其应用(apply)到某个对象时，scala会将这段代码转换成对这个对象的一个名为apply的方法调用。因此myArray(i)实际上就是myArray.apply(i)。因此，在scala中访问一个数组的元素就是一个简单的方法调用。 scala将从数组到表达式的一切都当做带有方法的对象来处理，由此来实现概念是的简单化。不需要记住各种特例。同时，这种统一并不会带来显著的性能开销。因为scala在编译代码时，会尽可能使用Java数组、基本类型和原生的算术指令。 使用列表 scala的列表(list)是不可变的(数组虽然不能更改长度，但是元素是可以改变的，因此是可变的)因此list的修改有点像Java的字符串，每次对其中元素的修改都会返回一个新的list对象。 不需要写 new List，因为scala.List的伴生对象上定义了一个工厂方法List.apply() 列表上用的最多的操作是 ::，读作”cons”。它是在一个已有的列表最前面添加一个新元素，并返回这个新的列表。例： 123val twoThree = List(2,3)val oneTwoThree = 1 :: twoThreeprintln(onTwoThree) 结果： List(1,2,3) 注意：在表达式1::twoThree中，::是它右操作元的方法。（一般用在操作符表示法的方法都是左结合的，例如 a * b相当于 a.*(b) ) 除非方法名是以 : 结尾的，那么这个方法的调用就会发生在他的右操作元上。 因此上例相当于： twoThree.::(1)，1是作为参数传入的。 表示空列表的快捷方式是Nil，初始化一个新的列表的另一种方式是用::将元素串接起来，并将Nil作为最后一个元素。例如： 12val oneTwoThree = 1 :: 2 :: 3 :: Nilprintln(oneTwoThree) :::连接两个List： 123val a = List(1)val b = List(2,3)val c = a ::: b //c: List(1,2,3) 列表也有从末尾增加元素的方法，但是应当尽力避免这种写法，因为末尾追加元素的操作所需时间随列表的大小线性增加，而使用::只需要常量级的时间。 可以通过在头部添加元素的方法，最后调用reverse方法来实现末尾添加的效果 也可以使用ListBuffer，这是个可变列表，支持追加操作，最后使用toList方法即可转换为List 使用元祖 元祖也是不可变的，但是元祖可以容纳不同类型的元素。 当需要从方法返回多个对象时，元祖就非常有用 实例化一个元祖非常简单，只要将对象放在圆括号当中，用逗号隔开即可 一旦实例化好一个元祖，就可以用英文句点、下划线和 从1开始 的序号来访问每一个元素。 例如： 123val pair = (99,&quot;test&quot;)pritln(pair._1) //访问第一个元素println(pair._2) //访问第二个元素 元祖的实际类型取决于它的元素。例如：(99,&quot;test&quot;)的类型为Tuple2[Int,String],而元祖(&#39;u&#39;,&#39;r&#39;,&quot;the&quot;,1,4,&quot;me&quot;)的类型是Tuple6[Char,Char,String,Int,Int,String] 元祖为什么不能像数组一样用圆括号来访问元素(原文)： 你也许正好奇问什么不能像访问列表元素，也就是“pair(0)”那样访问元祖元素。背后的原因是列表的apply方法永远只返回同一种类型，但元祖里的元素可以是不同类型的：_1可能是一种类型，_2可能是另一种 使用集和映射 scala的API包含了一个基础的特质(trait)来表示集，这里的特质跟Java的接口定义类似 scala提供了两个子特质：一个表示可变集，一个表示不可变集。(可变集与不可变集位于不同的包) 创建一个集合的例子： 123var jetSet = Set(&quot;Boeing&quot;,&quot;Airbus&quot;)jetSet += &quot;Lear&quot;println(jetSet.contains(&quot;Cessna&quot;)) 第一行代码表示，可以像创建列表和数组那样创建集：通过调用Set伴生对象的apply工厂方法。 在这个例子中，实际上调用了scala.collection.immutable.Set的伴生对象的apply方法，返回一个默认的、不可变 的Set对象，类型为Set[String] 向集添加元素需要调用+方法。无论是可变集还是不可变集，+方法都会创建并返回一个新的集 而本例中的+=方法，实际上不可变集并不提供这个方法，其本质上是jetSet = jetSet + ”Lear&quot;的简写。因此，其本质上是将jetSet这个var重新赋值成了一个包含三个元素的新的集 最后一行是打印集中是否包含”Cessna”这个元素，结果应当是false 可变集 使用可变集需要一次引入，例： 1234import scala.collection.mutableval movieSet = mutable.Set(&quot;Hitch&quot;,&quot;Peter&quot;)movieSet += &quot;Shrek&quot;println(movieSet) 通过import语句，可以使用简短的mutable.Set()而不是scala.colection.mutable.Set()这样完整的句子 这里的+=方法在可变集里是有定义的，因此这个可变集声明时用的是 val而不是 var(上面也提到了不可变集实际上是被重新赋值了，如果使用val会编译报错) HashSet的用法与Set一致，只是HashSet的存储方式不同，因此一般在需要考虑性能的地方会用到HashSet 映射(Map) 与Set类似，Map也有可变与不可变的版本。 例子： 123456import scala.collection.mutableval treasureMap = mutable.Map[Int,String]()treasureMap += (1 -&gt; &quot;Go to island&quot;)treasureMap += (2 -&gt; &quot;Find big X on ground&quot;)treasureMap += (3 -&gt; &quot;Dig&quot;)println(treasureMap(2)) 上面的例子引入了可变Map(默认为不可变映射)，这里与上面可变集一样，定义为val类型。接下来，使用-&gt;来定义键值对。这里scala会将二元操作，比如1 -&gt; &quot;Go to island&quot;转换为标准的方法调用，即(1).-&gt;(&quot;Go to island&quot;)，这里&quot;Go to island&quot;是方法-&gt;的参数。 可以对任何对象调用-&gt;方法，它将返回包含键和值两个元素的元组。 若要获取Map里的某个键的值，如上面代码的最后一行treasureMap(2)将返回2这个键对应的值。 函数式编程风格 如果一段代码避免了使用var(也就是全是val类型的变量)，那么它很可能是函数式的。因此，向函数式风格的转化应该尽可能地避免使用var类型的变量。 指令式编程的例子： 1234567def printArgs(args: Array[String]): Unit = &#123; var i = 0 while (i &lt; args.length)&#123; println(args(i)) i += 1 &#125;&#125; 可以将这段代码转化为函数式的： 第一种： 1234def printArgs(args: Array[String]): Unit = &#123; for (arg &lt;- args) //for表达式形式 println(arg)&#125; 第二种： 123def printArgs(args: Array[String]): Unit = &#123; args.foreach(println)&#125; 另一方面，尽量避免使用带有副作用的函数。就比如上面修改之后的函数，它依旧不是“纯”的函数式代码，因为他有副作用(本处的副作用是向标准输出流打印)。带有副作用的函数的标志特征就是结果类型为Unit。(因为一个一个结果类型为Unit的函数，存在世上的唯一意义就是产生副作用) 对于这一问题，函数式编程的做法就是定义一个将传入的args作为格式化(用于打印)的方法，但是只返回这个格式化的字符串。例如上例可以改成：def formatArgs(args: Array[String]) = args.mkString(&quot;\n&quot;)这个函数就满足了既没有var变量也没有副作用。 这时我们就可以使用println(formatArgs(args))来实现与上面相同的打印的效果。 从文件读取文本行 例子：从文本读取文本行，并将它们打印出来，在每一行前面带上当前的字符数。 1234567import scala.io.Sourceif(args.length &gt;0)&#123; for (line &lt;- Source.fromFile(args(0)).getLines()) println(line.length + &quot; &quot; + filename) else Console.err.println(&quot;Please enter filename&quot;)&#125; 这段脚本首先引入了scala.io名为Srouce的类，然后检查命令行是不是至少给出了一个参数。表达式Source.fromFile(args(0))尝试打开指定的文件并且返回一个Source对象。在这个对象上，继续调用getLines方法。 getLines方法返回一个Iterator[String]，每次迭代都给出一行内容，去掉了最后的换行符。for表达式遍历这些文本行。 可以将文本行赋值给一个变量：val lines = Source.fromFile(args(0)).getLines().toList 其中，最后的toList是必须的。因为getLines方法返回的是一个迭代器，一旦完成遍历，迭代器就会被消耗掉，通过toList方法将它转化为列表，就可以随便遍历这些文本行，多少次都可以(迭代器只能遍历一次)。但是代价就是要在内存中同时存储所有的行。因此lines指向了一个字符串列表。 scala也可以使用*来重复一个字符串，例： 12scala&gt; var s = &quot;a&quot; * 5s: String = aaaaa 最后更新于2018.7.16]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala方法查询记录]]></title>
    <url>%2F2018%2F07%2F12%2FScala-infos%2F</url>
    <content type="text"><![CDATA[仅供查询，禁止转载 一般的Int类型的都可以通过.max和.min获取最大最小元素 List的一些方法和用途 方法 用途 List()或者Nil 表示空列表 List(“Cool”,”Tools”) 创建一个新的List[String],包含两个值:”Cool”,”Tools” val thrill = “Will”::”Fill”::Nil 创建一个新的List[String]包含两个值：”Will”和”Fill” List(“a”,”b”):::List(“c”,”d”) 将两个列表拼接起来(返回一个新的列表List(“a”,”b”,”c”,”d”)) thrill(2) 返回列表thrill下标为2(从0开始计数) thrill.count(s =&gt; s.length == 4) 对thrill中长度为4的字符串进行计数 thrill.drop(2) 返回去掉了thrill的头两个元素的列表 thrill.dropRight(2) 返回去掉了thrill后两个元素的列表 thrill.exists(s =&gt; s==”until”) 判断thrill中是否有字符串元素的值为”until”，返回值为Boolean thrill.filter(s =&gt; s.length == 4) 按顺序返回列表thrill中所有长度为4的元素列表 thrill.forall(s =&gt; s.endsWith(“1”)) 表示列表中是否所有元素都以字母”1”结尾 thrill.foreach(s =&gt; println(s)) / thrill.foreach(println) 遍历列表执行打印 thrill.head 返回列表的首个元素 thrill.init 返回列表thrill除最后一个元素之外其他元素组成的列表 thrill.isEmpty 判断列表是否为空 thrill.last 返回thrill的最后一个元素 thrill.length 返回列表的元素个数 thrill.map(s =&gt; s + “y”) 返回一个对列表thrill所有字符串元素末尾添加”y”的新字符串列表 thrill.makeString”, “ 返回用列表thrill的所有元素组合成的字符串，以”, “连接各个元素 thrill.filterNot(s =&gt; s.length == 4) 按顺序返回列表中所有长度不为4的元素列表 thrill.reverse 返回包含列表thrill的逆序列表 thrill.sort( (s,t) =&gt; s.charAt(0).toLower &lt; t.charAt(0).toLower) 返回包含thrill的所有元素，按照首字母小写顺序排序的列表 thrill.tail 返回列表thrill除首个元素之外其他元素组成的列表 常用的集操作 操作 效果 val nums = Set(1,2,3) 创建一个不可变集(nums.toString返回Set(1,2,3)) nums + 5 添加一个元素(返回Set(1,2,3,5)) nums - 3 移除一个元素(返回Set(1,2)) nums ++ List(5,6) 添加多个元素(返回Set(1,2,3,5,6)) nums – List(1,2) 移除多个元素(返回Set(3)) nums &amp; Set(1,3,5,7) 获取两个集的交集(返回Set(1,3)) nums.size 返回集的大小(返回3) nums.contains(3) 检查是否包含(此处返回true) import scala.collection.mutable 让可变集易于访问 val words = mutable.Set.empty[String] 创建一个空的可变集(words.toString将返回Set()) words += “the” 添加一个元素(words.toString将返回Set(the)) words -= “the” 移除一个元素，如果这个元素存在(words.toString将返回Set()) words ++= List(“do”,”re”,”mi”) 添加多个元素(words.toString将返回Set(do,re,mi)) words –= List(“do”,”re”) 移除多个元素(words.toString将返回Set(mi)) words.clear 移除所有元素(words.toString将返回Set()) 更详细的链接 常用的映射操作 操作 效果 val nums = Map(“i” -&gt; 1, “ii” -&gt; 2) 创建一个不可变映射(nums.toString返回Map(i -&gt; 1, ii -&gt; 2)) nums + (“vi” -&gt; 6) 添加一个条目(返回Map(i -&gt; 1, ii -&gt; 2, vi -&gt; 6)) nums - “ii” 移除一个条目(返回Map(i -&gt; 1)) nums ++ List(“iii” -&gt; 3, “v” -&gt; 5) 添加多个条目(返回Map(i -&gt; 1, ii -&gt; 2, iii -&gt; 3, v -&gt; 5)) nums – List(“i”,”ii”) 移除多个条目(返回Map()) nums.size 返回映射的大小(返回2) nums.contains(“ii”) 检查是否包含(返回true) nums(“ii”) 获取指定键的值(返回2) nums.keys 返回所有键(返回字符串”i”和”ii”的Iterable) nums.keySet 以集的形式返回所有的键(返回Set(i,ii)) nums.values 返回所有的值(返回整数1和2的Iterable) nums.isEmpty 表示映射是否为空 import scala.collection.mutable 让可变集合易于访问 val words = mutable.Map.empty[String,Int] 创建一个空的可变映射 words += (“one” -&gt; 1, “two” -&gt; 2, “three” -&gt; 3) 添加一个从”one”到1的映射条目 words -= “one” 移除一个映射条目，如果存在 words ++= List(“one” -&gt; 1, “two” -&gt; 2, “three” -&gt; 3) 添加多个条目 words –= List(“one”,”two”) 移除多个条目 更详细的链接 序列 操作 说明 索引和长度的操作 apply、isDefinedAt、length、indices，及lengthCompare 序列的apply操作用于索引访问；因此，Seq[T]类型的序列也是一个以单个Int（索引下标）为参数、返回值类型为T的偏函数。换言之，Seq[T]继承自Partial Function[Int, T]。序列各元素的索引下标从0开始计数，最大索引下标为序列长度减一。序列的length方法是collection的size方法的别名。lengthCompare方法可以比较两个序列的长度，即便其中一个序列长度无限也可以处理。 索引检索操作（indexOf、lastIndexOf、indexofSlice、lastIndexOfSlice、indexWhere、lastIndexWhere、segmentLength、prefixLength） 用于返回等于给定值或满足某个谓词的元素的索引。 加法运算（+:，:+，padTo） 用于在序列的前面或者后面添加一个元素并作为新序列返回。 更新操作（updated，patch） 用于替换原序列的某些元素并作为一个新序列返回。 排序操作（sorted, sortWith, sortBy） 根据不同的条件对序列元素进行排序。 反转操作（reverse, reverseIterator, reverseMap） 用于将序列中的元素以相反的顺序排列。 比较（startsWith, endsWith, contains, containsSlice, corresponds） 用于对两个序列进行比较，或者在序列中查找某个元素。 多集操作（intersect, diff, union, distinct） 用于对两个序列中的元素进行类似集合的操作，或者删除重复元素。 Seq类的操作 WHAT IT IS WHAT IT DOES 索引和长度 ———————————– xs(i) (或者写作xs apply i)。xs的第i个元素 xs isDefinedAt i 测试xs.indices中是否包含i。 xs.length 序列的长度（同size）。 xs.lengthCompare ys 如果xs的长度小于ys的长度，则返回-1。如果xs的长度大于ys的长度，则返回+1，如果它们长度相等，则返回0。即使其中一个序列是无限的，也可以使用此方法。 xs.indices xs的索引范围，从0到xs.length - 1。 索引搜索 ———————————– xs indexOf x 返回序列xs中等于x的第一个元素的索引（存在多种变体）。 xs lastIndexOf x 返回序列xs中等于x的最后一个元素的索引（存在多种变体）。 xs indexOfSlice ys 查找子序列ys，返回xs中匹配的第一个索引。 xs indexOfSlice ys 查找子序列ys，返回xs中匹配的倒数一个索引。 xs indexWhere p xs序列中满足p的第一个元素。（有多种形式） xs segmentLength (p, i) xs中，从xs(i)开始并满足条件p的元素的最长连续片段的长度。 xs prefixLength p xs序列中满足p条件的先头元素的最大个数。 加法 ———————————– x +: xs 由序列xs的前方添加x所得的新序列。 xs :+ x 由序列xs的后方追加x所得的新序列。 xs padTo (len, x) 在xs后方追加x，直到长度达到len后得到的序列。 更新 ———————————– xs patch (i, ys, r) 将xs中第i个元素开始的r个元素，替换为ys所得的序列。 xs updated (i, x) 将xs中第i个元素替换为x后所得的xs的副本。 xs(i) = x （或写作 xs.update(i, x)，仅适用于可变序列）将xs序列中第i个元素修改为x。 排序 ———————————– xs.sorted 通过使用xs中元素类型的标准顺序，将xs元素进行排序后得到的新序列。 xs sortWith lt 将lt作为比较操作，并以此将xs中的元素进行排序后得到的新序列。 xs sortBy f 将序列xs的元素进行排序后得到的新序列。参与比较的两个元素各自经f函数映射后得到一个结果，通过比较它们的结果来进行排序。 反转 ———————————– xs.reverse 与xs序列元素顺序相反的一个新序列。 xs.reverseIterator 产生序列xs中元素的反序迭代器。 xs reverseMap f 以xs的相反顺序，通过f映射xs序列中的元素得到的新序列。 比较 ———————————– xs startsWith ys 测试序列xs是否以序列ys开头（存在多种形式）。 xs endsWith ys 测试序列xs是否以序列ys结束（存在多种形式）。 xs contains x 测试xs序列中是否存在一个与x相等的元素。 xs containsSlice ys 测试xs序列中是否存在一个与ys相同的连续子序列。 (xs corresponds ys)(p) 测试序列xs与序列ys中对应的元素是否满足二元的判断式p。 多集操作 ———————————– xs intersect ys 序列xs和ys的交集，并保留序列xs中的顺序。 xs diff ys 序列xs和ys的差集，并保留序列xs中的顺序。 xs union ys 并集；同xs ++ ys。 xs.distinct 不含重复元素的xs的子序列。 Buffer类的操作 WHAT IT IS WHAT IT DOES 加法： ———————————– buf += x 将元素x追加到buffer，并将buf自身作为结果返回。 buf += (x, y, z) 将给定的元素追加到buffer。 buf ++= xs 将xs中的所有元素追加到buffer。 x +=: buf 将元素x添加到buffer的前方。 xs ++=: buf 将xs中的所有元素都添加到buffer的前方。 buf insert (i, x) 将元素x插入到buffer中索引为i的位置。 buf insertAll (i, xs) 将xs的所有元素都插入到buffer中索引为i的位置。 移除： ———————————– buf -= x 将元素x从buffer中移除。 buf remove i 将buffer中索引为i的元素移除。 buf remove (i, n) 将buffer中从索引i开始的n个元素移除。 buf trimStart n 移除buffer中的前n个元素。 buf trimEnd n 移除buffer中的后n个元素。 buf.clear() 移除buffer中的所有元素。 克隆： ———————————– buf.clone 与buf具有相同元素的新buffer。 Traversable对象的操作 WHAT IT IS WHAT IT DOES 抽象方法： xs foreach f 对xs中的每一个元素执行函数f 加运算（Addition）： xs ++ ys 生成一个由xs和ys中的元素组成容器。ys是一个TraversableOnce容器，即Taversable类型或迭代器。 Maps: xs map f 通过函数xs中的每一个元素调用函数f来生成一个容器。 xs flatMap f 通过对容器xs中的每一个元素调用作为容器的值函数f，在把所得的结果连接起来作为一个新的容器。 xs collect f 通过对每个xs中的符合定义的元素调用偏函数f，并把结果收集起来生成一个集合。 转换（Conversions）： xs.toArray 把容器转换为一个数组 xs.toList 把容器转换为一个list xs.toIterable 把容器转换为一个迭代器。 xs.toSeq 把容器转换为一个序列 xs.toIndexedSeq 把容器转换为一个索引序列 xs.toStream 把容器转换为一个延迟计算的流。 xs.toSet 把容器转换为一个集合（Set）。 xs.toMap 把由键/值对组成的容器转换为一个映射表（map）。如果该容器并不是以键/值对作为元素的，那么调用这个操作将会导致一个静态类型的错误。 拷贝（Copying）： xs copyToBuffer buf 把容器的所有元素拷贝到buf缓冲区。 xs copyToArray(arr, s, n) 拷贝最多n个元素到数组arr的坐标s处。参数s，n是可选项。 大小判断（Size info）： xs.isEmpty 测试容器是否为空。 xs.nonEmpty 测试容器是否包含元素。 xs.size 计算容器内元素的个数。 xs.hasDefiniteSize 如果xs的大小是有限的，则为true。 元素检索（Element Retrieval）： xs.head 返回容器内第一个元素（或其他元素，若当前的容器无序）。 xs.headOption xs选项值中的第一个元素，若xs为空则为None。 xs.last 返回容器的最后一个元素（或某个元素，如果当前的容器无序的话）。 xs.lastOption xs选项值中的最后一个元素，如果xs为空则为None。 xs find p 查找xs中满足p条件的元素，若存在则返回第一个元素；若不存在，则为空。 子容器（Subcollection）： xs.tail 返回由除了xs.head外的其余部分。 xs.init 返回除xs.last外的其余部分。 xs slice (from, to) 返回由xs的一个片段索引中的元素组成的容器（从from到to，但不包括to）。 xs take n 由xs的第一个到第n个元素（或当xs无序时任意的n个元素）组成的容器。 xs drop n 由除了xs take n以外的元素组成的容器。 xs takeWhile p 容器xs中最长能够满足断言p的前缀。 xs dropWhile p 容器xs中除了xs takeWhile p以外的全部元素。 xs filter p 由xs中满足条件p的元素组成的容器。 xs withFilter p 这个容器是一个不太严格的过滤器。子容器调用map，flatMap，foreach和withFilter只适用于xs中那些的满足条件p的元素。 xs filterNot p 由xs中不满足条件p的元素组成的容器。 拆分（Subdivision）： xs splitAt n 把xs从指定位置的拆分成两个容器（xs take n和xs drop n）。 xs span p 根据一个断言p将xs拆分为两个容器（xs takeWhile p, xs.dropWhile p）。 xs partition p 把xs分割为两个容器，符合断言p的元素赋给一个容器，其余的赋给另一个(xs filter p, xs.filterNot p)。 xs groupBy f 根据判别函数f把xs拆分一个到容器（collection）的map中。 条件元素（Element Conditions）： xs forall p 返回一个布尔值表示用于表示断言p是否适用xs中的所有元素。 xs exists p 返回一个布尔值判断xs中是否有部分元素满足断言p。 xs count p 返回xs中符合断言p条件的元素个数。 折叠（Fold）： (z /: xs)(op) 在xs中，对由z开始从左到右的连续元素应用二进制运算op。 (xs :\ z)(op) 在xs中，对由z开始从右到左的连续元素应用二进制运算op xs.foldLeft(z)(op) 与(z /: xs)(op)相同。 xs.foldRight(z)(op) 与 (xs :\ z)(op)相同。 xs reduceLeft op 非空容器xs中的连续元素从左至右调用二进制运算op。 xs reduceRight op 非空容器xs中的连续元素从右至左调用二进制运算op。 特殊折叠（Specific Fold）： xs.sum 返回容器xs中数字元素的和。 xs.product xs返回容器xs中数字元素的积。 xs.min 容器xs中有序元素值中的最小值。 xs.max 容器xs中有序元素值中的最大值。 字符串（String）： xs addString (b, start, sep, end) 把一个字符串加到StringBuilder对象b中，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。 xs mkString (start, sep, end) 把容器xs转换为一个字符串，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。 xs.stringPrefix 返回一个字符串，该字符串是以容器名开头的xs.toString。 视图（View）： xs.view 通过容器xs生成一个视图。 xs view (from, to) 生成一个表示在指定索引范围内的xs元素的视图。 Trait Iterable操作 WHAT IT IS WHAT IT DOES 抽象方法： xs.iterator xs 迭代器生成的每一个元素，以相同的顺序就像foreach一样遍历元素。 其他迭代器： xs grouped size 一个迭代器生成一个固定大小的容器（collection）块。 xs sliding size 一个迭代器生成一个固定大小的滑动窗口作为容器（collection）的元素。 子容器（Subcollection）： xs takeRight n 一个容器（collection）由xs的最后n个元素组成（或，若定义的元素是无序，则由任意的n个元素组成）。 xs dropRight n 一个容器（collection）由除了xs 被取走的（执行过takeRight （）方法）n个元素外的其余元素组成。 拉链方法（Zippers）： xs zip ys 把一对容器 xs和ys的包含的元素合成到一个iterabale。 xs zipAll (ys, x, y) 一对容器 xs 和ys的相应的元素合并到一个iterable ，实现方式是通过附加的元素x或y，把短的序列被延展到相对更长的一个上。 xs.zip WithIndex 把一对容器xs和它的序列，所包含的元素组成一个iterable 。 比对： xs sameElements ys 测试 xs 和 ys 是否以相同的顺序包含相同的元素。 最后更新于2018.7.26]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下使用jekyll预览博客]]></title>
    <url>%2F2018%2F07%2F08%2FJekyll-usage%2F</url>
    <content type="text"><![CDATA[环境安装 确保下面环境的齐全：123456789brew install ruby//gem install jekyll//gem install bundler//gem install jekyll-paginate//gem install jekyll-gist 如果执行命令的过程中有提示什么什么未安装，按照提示的命令来安装即可。 然后将终端切换到你博客所在的根目录，执行：jekyll serve --watch即可 终端中会告诉你博客使用了本地4000端口，在网页中输入：http://127.0.0.1:4000/即可预览博客的效果 更新本地内容保存后更新网页即可看到效果 最后更新于2018.7.14]]></content>
      <categories>
        <category>Personal Blog</category>
      </categories>
      <tags>
        <tag>๑Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习——JavaScript]]></title>
    <url>%2F2018%2F07%2F07%2FJavaScript%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 基础 建议把javascript脚本放在 &lt;body&gt;部分的底部。这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。 Js是放在head还是body解析 嵌入html的javascript写法 JavaScript代码写在&lt;script&gt;和&lt;/script&gt;标签之前。 其中&lt;script type =&quot;text/javascript&quot;&gt;表示在&lt;script&gt;&lt;/script&gt;之间的是文本类型(text),javascript是为了告诉浏览器里面的文本是属于JavaScript语言。 单独写成文件 JavaScript代码只能写在HTML文件中吗?当然不是，我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。 注意:在JS文件中，不需要&lt;script&gt;标签,直接编写JavaScript代码就可以了。 单独写成文件的javascript文件不能单独运行，比如一个叫“script.js”的文件，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中：&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 位置 我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。 放在&lt;head&gt;部分 最常用的方式是在页面中head部分放置&lt;script&gt;元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。 放在&lt;body&gt;部分 JavaScript代码在网页读取到该语句的时候就会执行。 注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。 语法 一个JavaScript语句以;结尾（虽然也可以不写） 注释：单行注释：//，多行注释/*...*/ 变量 定义变量使用关键字var 变量名 注意JS中变量无需声明类型 判断语句 语法： 1234if(条件)&#123; 条件成立时执行的代码 &#125;else&#123; 条件不成立时执行的代码 &#125; 例子： 1234567&lt;script type=&quot;text/javascript&quot;&gt; var myage = 18; if(myage&gt;=18) //myage&gt;=18是判断条件 &#123; document.write(&quot;你是成年人。&quot;);&#125; else //否则年龄小于18 &#123; document.write(&quot;未满18岁，你不是成年人。&quot;);&#125;&lt;/script&gt; 判断函数 语法： 1234function 函数名()&#123; 函数代码;&#125; 例子： 输出内容(document.write) 输出内容可以是双引号括起来的，也可以是变量，多个输出项之间以+连接 例子： 1234&lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;hello&quot;; document.write(mystr+&quot;I love JavaScript&quot;); //多项内容之间用+号连接&lt;/script&gt; javascript警告(消息对话框) 语法：alert(字符串或变量) 注意：alert弹出一个消息对话框，只有一个确定按钮，多个对话框之间按顺序弹出。 确认(confirm对话框) 语法：confirm(str); 参数说明： str：在消息对话框中要显示的文本 返回值: Boolean值 返回值：当用户点击”确定”按钮时，返回true ；当用户点击”取消”按钮时，返回false 打开新窗口(window.open) 语法：window.open([URL], [窗口名称], [参数字符串]) 参数说明： 12345678910URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。窗口名称：可选参数，被打开窗口的名称。 1.该名称由字母、数字和下划线字符组成。 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。 注意：所有的参数都要写在一个参数字符串中，中间以逗号间隔，例如 ‘height=100.width=100’ 这样。 可以将窗口对象存储在变量test中：var test = window.open(...); 关闭窗口： window.close();:关闭本窗口 &lt;窗口对象&gt;.close();:关闭指定窗口 控制权(DOM操作) 文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，三种常见的DOM节点: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=&quot;http://www.imooc.com&quot;。 例子：&lt;a href=&quot;http://www.imooc.com&quot;&gt;JavaScript DOM&lt;/a&gt; 通过ID获取元素 网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。 语法：document.getElementById(“id”) 例子： 123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-wquiv=&quot;Content-Type&quot; content=&quot;text/html; charest=gb2312&quot; /&gt;&lt;title&gt;获取元素&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var mye = document.getElementById(&quot;con&quot;); //获取元素变量存储在变量mye中 document.write(mye); //输出变量 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Hello&lt;/h3&gt; &lt;p id=&quot;con&quot;&gt;I love JavaScript&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; innerHTML属性 innerHTML 属性用于获取或替换 HTML 元素的内容。 语法：Object.innerHTML 例子： 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;innerHTML&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;con&quot;&gt;Hello World!&lt;/p&gt; &lt;script&gt; var mycon = document.getElementById(&quot;con&quot;); document.write(&quot;P标签原始内容：&quot; + mycon.innerHTML + “&lt;br&gt;”); //输入想要修改的元素内容 mycon.innerHTML = &quot;New test!&quot;; //修改P元素内容 document.write(&quot;P标签修改后的内容：&quot; + mycon.innerHTML); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变HTML样式 HTML DOM 允许 JavaScript 改变 HTML 元素的样式。 语法：Object.style.property=new style; 注意:Object是获取的元素对象，如通过document.getElementById(&quot;id&quot;)获取的元素。 基本属性表： 属性 描述 backgroundColor 设置元素背景颜色 height 设置元素高度 width 设置元素宽度 color 设置文本颜色 font 在一行设置所有的字体属性 fontFamily 设置元素的字体系列 fontSize 设置元素的字体大小 … … CSS的其他的一些样式也可以通过该方法修改 例子：改变&lt;p&gt;元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝： 1234567&lt;p id=&quot;pcon&quot;&gt;Hello World!&lt;/p&gt;&lt;script&gt; var mychar = document.getElementById(&quot;pcon&quot;); mychar.style.color=&quot;red&quot;; mychar.style.fontSize=&quot;20&quot;; mychar.style.backgroundColor =&quot;blue&quot;;&lt;/script&gt; 显示和隐藏 网页中经常会看到显示和隐藏的效果，可通过display属性来设置。 语法：Object.style.display = value 注意这里的Object也是元素对象，可通过document.getElementById(“id”)来获取 value取值： none：此元素讲不会被显示(即隐藏) block：此元素将显示为块级元素 例子： 控制类名 className 属性设置或返回元素的class 属性。 语法：object.className = classname 作用： 获取元素的class属性 为网页内某个元素指定一个CSS样式来更改该元素的外观 例子： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gb2312&quot;&gt;&lt;title&gt;className属性&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; input&#123; font-size:10px; &#125; .one&#123; width:200px; background-color:#CCC; //灰色 &#125; .two&#123; font-size:18px; color:#F00 &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;con&quot; class=&quot;one&quot;&gt;JavaScript&lt;/p&gt; &lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;点击更改&quot; onclick=&quot;modifyclass()&quot;/&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; var mychar=document.getElementById(&quot;con&quot;); document.write(&quot;p元素的Class值为：&quot; + mychar.className + &quot;&lt;br&gt;&quot;); //输出P元素的class属性 function modifyclass()&#123; mychar.className=&quot;two&quot;; //改变className,即更换用来修饰的class &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果： 进阶 循环、分支、判断等语法与C++一致 事件响应 JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。 事件 说明 onclick 鼠标单击事件 onmouseover 鼠标经过事件 onmouseout 鼠标移开事件 onchange 文本框内容改变事件 onselect 文本框内容被选中事件 onfocus 光标聚集 onblur 光标移开 onload 网页导入 onunload 关闭网页 鼠标单击事件 onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。 例如：单击按钮时出发onclick事件，调用add2()函数 123&lt;form&gt; &lt;input name=&quot;button&quot; type=&quot;button&quot; value=&quot;点击提交&quot; onclick=&quot;add2()&quot; /&gt; //注意最后的斜杠 &lt;/form&gt; 鼠标经过事件 与鼠标单击事件调用方法一致 其他的事件 除了onload与onunload的使用有一点区别，别的都一致。 对象 JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。 创建对象使用new关键字 日期对象 日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒） 定义一个时间对象：var Udate = new Date(); 这是默认定义，初始值为当前电脑时间 如果要自定义值，使用以下方法：var DATE = new Date(2018,10,4); //2018年10月4日 浏览器对象window对象 window对象是BOM的核心，window对象指当前的浏览器窗口。 window对象方法： 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框 prompt() 显示可提示用户输入的对话框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 open() 打开一个新的浏览器窗口或者查找一个已经命名的窗口 close() 关闭浏览器窗口 print() 打印当前窗口的内容 focus() 把键盘焦点给予一个窗口 blur() 把键盘焦点从顶层窗口移开 moveBy() 可相对窗口的当前坐标把它移动指定的像素 moveTo() 把窗口的左上角移动到一个指定的坐标 resizeBy() 按照 resizeTo() 把窗口的大小调整到指定的宽度和高度 scrollBy() 按照指定的像素值来滚动内容 scrollTo() 把内容滚动到指定的坐标 setInterval() 每隔指定的时间执行代码 setTimeout() 在指定的延迟时间后来执行代码 clearInterval() 取消setInterval()的设置 clearTimeout() 取消setTimeout()的设置 调用这些方法格式：window.方法名(参数名); 例子： 123456function myFunction()&#123; alert(&quot;欢迎&quot;) window.open(&apos;http://www.imooc.com&apos;,&apos;_blank&apos;,&apos;width=600 height=400&apos;) //第一个参数表示要打开的网页，&apos;_blank&apos;参数表示打开一个新网页，后面的参数设置新窗口的初始大小&#125; JavaScript计时器 在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。 计时器类型： 一次性计时器：仅在指定的延迟时间之后触发一次。(setTimeout()) 间隔性触发计时器：每隔一定的时间间隔就触发一次。(setInterval()) setInterval()方法格式：setInterval(代码，交互时间) 参数中，代码就是要执行的函数挥着代码串，交互时间就是执行的时间间隔，以毫秒为单位 setInterval的返回值可以传递给clearInterval从而取消对代码的周期性执行。 假设有一个clock()函数，则调用格式为： 123setInterval(&quot;clock()&quot;,1000)或者setInterval(clock,1000) DOM对象 getElementsByName方法 返回带有指定名称的节点对象的集合 语法：document.getElementsByName(name) 其中name参数是标签上设置的name属性，和设置id属性格式一样，但是不同的标签可以设置同一个name属性，而id属性必须唯一 与getElementById()不同的是，通过元素的name属性查询元素而不是通过id属性 注意：因为文档中的name属性可能不唯一，所有的getElementByName()方法的返回值是元素的数组，而不是一个元素 和数组类似的也有length属性，可以和访问数组一样的方法来访问，从0开始 一些报错以及解决 jQuery报错：Uncaught ReferenceError: $ is not defined 出现这个报错的原因： jQuery库文件的路径不对，检查文件路径是否正确一般就能解决该错误。 如果库文件的路径是正确的，那么可能在html中加载jQuery库文件顺序有误，如果将jQuery库文件加载放到最开始位置，即可以解决该错误 检查传值错误，或者某些值不存在。 最后更新于2018.7.18]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>๑FrontEnd</tag>
        <tag>๑JavaScrpt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习——CSS]]></title>
    <url>%2F2018%2F06%2F17%2FFrontEnd-CSS%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 在CSS代码中不要随便加空格 CSS3动画效果 CSS代码语法 基础 注意各个语句之间以分号间隔 css 样式由选择符和声明组成，而声明又由属性和值组成，例如：p{color:blue} 其中，p为 选择符，{..}为 声明，color为 属性，blue为 值。 选择符：又称选择器，指明网页中要应用样式规则的元素，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。 声明：在英文大括号｛ ｝中的的就是声明，属性和值之间用英文冒号：分隔。当有多条声明时，中间可以英文分号；分隔，如：p{font-size:12px;color:red;} 最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号 为了使用样式更加容易阅读，可以将每条代码写在一个新行内，所以上面的应该写为： 1234p&#123; font-size:12px; color:red;&#125; CSS中的注释 格式：/*注释语句*/ 三种CSS样式 从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式、嵌入式和外部式三种。 内联式css样式，直接写在现有的HTML标签中 内联式css样式表就是把css代码直接写在现有的HTML标签中，如下面代码： 1&lt;p style=&quot;color:red&quot;&gt;这里文字是红色&lt;/p&gt; 注意要写在元素的开始标签里 并且css样式代码要写在style=&quot;&quot;双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开。如下代码： 1&lt;p style=&quot;color:red;font-size:12px&quot;&gt;这里文字是红色&lt;/p&gt; 嵌入式css样式，写在当前的文件中 嵌入式css样式，就是可以把css样式代码写在&lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt;标签之间。如下面代码实现把三个&lt;span&gt;标签中的文字设置为红色： 12345&lt;style type=&quot;text/css&quot;&gt;span&#123;color:red;&#125;&lt;/style&gt; 嵌入式css样式必须写在&lt;style&gt; &lt;/style&gt;之间，并且一般情况下嵌入式css样式写在&lt;head&gt; &lt;/head&gt;之间 外部式css样式，写在单独的一个文件中 外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以.css为扩展名，在&lt;head&gt;内（不是在&lt;style&gt;标签内）使用&lt;link&gt;标签将css样式文件链接到HTML文件内，如下面代码： 1&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; css样式文件名称以有意义的英文字母命名，如 main.css。 rel=&quot;stylesheet&quot; type=&quot;text/css&quot; 是 固定写法 不可修改。 &lt;link&gt;标签位置一般写在&lt;head&gt;标签之内。 三种方法的优先级 前提：在相同的权值的情况下。 优先级：内联式 &gt; 嵌入式 &gt; 外部式 总而言之，就是就近原则（离被设置元素越近优先级别越高）。 选择器 每一条css样式声明（定义）由两部分组成，形式如下： 123选择器&#123; 样式;&#125; 在{}之前的部分就是“选择器”，“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。 例： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;选择器&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body&#123; font-size:12px; color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;XXXXXXXX&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 其中body{..}就是一个选择器（标签选择器），他作用于&lt;body&gt;部分 标签选择器 标签选择器其实就是html代码中的标签。 例：p{font-size:12px;line-height:1.6em;}这个就为p标签（&lt;p&gt;标签是段落部分）设置12px字号，行间距设置1.6em的样式。 类选择器 语法：.类选器名称{css样式代码;} 注意：以英文圆点开头。类选择器可以任意起名字。 用法： 使用合适的标签把要修饰的内容标记起来，如：&lt;span&gt;胆小如鼠&lt;/span&gt; 使用class=&quot;类选择器名称&quot;为标签设置一个类，如：&lt;span class=&quot;stress&quot;&gt;胆小如鼠&lt;/span&gt; 设置类选器css样式，如：.stress{color:red;} /*类前面要加入一个英文圆点*/ 类选择器使得我们可以灵活地自定义不同的部分的格式。 ID选择器 在很多方面，ID选择器都类似于类选择符，但也有一些重要的区别： 为标签设置id=&quot;ID名称&quot;，而不是class=&quot;类名称&quot;。 ID选择符的前面是井号（#），而不是英文圆点（.） 例如： 12345#test&#123; color:blue;&#125;...XXX&lt;span id=&quot;test&quot;&gt;...&lt;/span&gt; id选择器和类选择器的区别与联系相同点 可以应用于任何元素 不同点 ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。 这里只能使用一次是指同一个id选择器只能修饰一个地方，而类选择器可以同时修饰多个地方。当然我们可以定义多个id选择器来修饰不同的地方 可以使用类选择器词列表方法为一个元素同时设置多个样式。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。 正确示例： 123456789.stress&#123; color:red;&#125;.bigsize&#123; font-size:25px;&#125;&lt;p&gt;到了&lt;span class=&quot;stress bigsize&quot;&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...&lt;/p&gt; 以上代码在&lt;span&gt;里定义两个类来修饰，这样的语法是可以的。上面代码的作用是为“三年级”三个文字设置文本颜色为红色并且字号为25px。 错误的例子： 123456789#stressid&#123; color:red;&#125;#bigsizeid&#123; font-size:25px;&#125;&lt;p&gt;到了&lt;span id=&quot;stressid bigsizeid&quot;&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...&lt;/p&gt; 以上代码是错误的，一个地方只能用一个id选择器来修饰。以上代码不能起到修饰的作用。 子选择器 还有一个比较有用的选择器子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。 例如：(以下代码会使class名为food下的子元素 li 加入红色实线边框。) 123456789101112131415161718192021....food&gt;li&#123;border:1px solid red;&#125;...&lt;h1&gt;食物&lt;/h1&gt;&lt;ul class=&quot;food&quot;&gt; &lt;li&gt;水果 &lt;ul&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;蔬菜 &lt;ul&gt; &lt;li&gt;白菜&lt;/li&gt; &lt;li&gt;油菜&lt;/li&gt; &lt;li&gt;卷心菜&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt;... 包含(后代)选择器 包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如：.first span{color:red;} 请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。后代选择器通过空格来进行选择，而子选择器是通过&gt;进行选择。 总而言之就是，空格选择所有后代元素，&gt;只选择第一代后代。 通用选择器 通用选择器是功能最强大的选择器，它使用一个*号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色：* {color:red;} 伪类选择符 它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：a:hover{color:red;}这句代码就实现了&lt;a&gt;(超链接)鼠标划过的特效，当鼠标划过超链接时，超链接的字体颜色会变成红色。 一般:hover都是用来控制鼠标滑过的效果 其实 :hover 可以放在任意的标签上，比如说 p:hover，但是它们的兼容性也是很不好的，所以一般用在a:hover的组合。(现在也可以用在其他的地方) 分组选择符 当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码将&lt;h1&gt;、&lt;span&gt;标签同时设置字体颜色为红色：h1,span{color:red;} 以上代码相当于下面两行代码： 12h1&#123;color:red;&#125;span&#123;color:red;&#125; 继承 CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。就是对某一些标签的样式的修改会对其子代也产生影响。 ### 权值 如果对同一个标签设置了不同的样式，浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。 权值的规则：标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。 例如： 12345p&#123;color:red;&#125; /*权值为1*/p span&#123;color:green;&#125; /*权值为1+1=2*/.warning&#123;color:white;&#125; /*权值为10*/p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/ 注意：还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 使用!important来使样式获得最高权值：p{color:red!important;} 注意：!important要写在分号的前面,中间不需要空格。 层叠 如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？这时候我们就会用到层叠。 层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用。 简单来说，就是，就是后面的样式会覆盖前面的样式。 所以之前的内外优先级关系：内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 也就很好理解了。 文字排版 字体 例：为网页设置字体 body{font-family:&quot;Microsoft Yahei&quot;;} //字体为微软雅黑 注意：这里设置的字体能否显示，取决于用户本地有没有安装这个字体。 字号颜色 设置网页中文字的字号为12像素，并把字体颜色设置为#666(灰色)：body{font-size:12px;color:#666} font-size:字体大小 color：颜色(一般以#加数字来表示颜色，以增加颜色的多样化) 一些字体样式：粗体、斜体等 font-weight:字体粗细 例：span{font-weight:bold;} //粗体 font-style:字体特点 例：span{font-style:italic;} //斜体(意大利体) text-decoration:文字修饰 例：a{text-decoration:underline;} //下划线 例：.oldPrice{text-decoration:line-through;} //删除线(将文字划去) 段落排版首行缩进 设置段落缩进两个字宽：p{text-indent:2em;} 2em的意思就是文字的2倍大小。 行间距 例：p{line-height:1.5em;} 中文字间距、字母间距 如果想在网页排版中设置文字间隔或者字母间隔就可以使用letter-spacing来实现。 例：h1{letter-spacing:10px;} 注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。 如果我想设置英文单词之间的间距，可以使用 word-spacing 来实现。 例：h1{word-spacing:20px;} 对齐 为块状元素中的文本、图片设置居中样式，可以使用text-align样式代码。 例：h1{text-align:center/left/right;} //居中/左对齐/右对齐 元素分类 在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。 常用的块状元素有：&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 常用的内联元素有：&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 常用的内联块状元素有：&lt;img&gt;、&lt;input&gt; 块级元素 设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点：a{display:block;} 块级元素特点： 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素 块状元素也可以通过代码display:inline将元素设置为内联元素。 如下代码就是将块状元素div转换为内联元素，从而使 div 元素具有内联元素特点：div{display:inline;} 内联元素特点： 和其他元素都在一行上 元素的高度、宽度及顶部和底部边距不可设置 元素的宽度就是它包含的文字或图片的宽度，不可改变 内联块状元素 内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码display:inline-block就是将元素设置为内联块状元素。 inline-block 元素特点： 和其他元素都在一行上 元素的高度、宽度、行高以及顶和底边距都可设置 颜色值 英文命令颜色：p{color:red;} RGB颜色：这个与 photoshop 中的 RGB 颜色是一致的，由 R(red)、G(green)、B(blue) 三种颜色的比例来配色。 例：p{color:rgb(133,45,200);} 每一项的值可以是 0~255 之间的整数，也可以是 0%~100% 的百分数，例如：p{color:rgb(20%,33%,25%);} 十六进制颜色：这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。 例：p{color:#00ffff;} //以#开头 长度值 目前比较常用到px（像素）、em、% 百分比。(但是这三种单位都是相对值) 像素 像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。 em 就是本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：p{font-size:12px;text-indent:2em;}就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。 百分比 p{font-size:12px;line-height:130%} 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。 一些补充 元素宽度相关 calc()用法：详解 如果你的元素宽度是100%时，只要你在元素中添加了border,padding,margin任何一值，都将会把元素盒子撑破（标准模式下，除IE怪异模式）。 opacity属性 设置div元素的不透明级别 语法：opacity: value|inherit; 值： value: 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）; inherit: 应该从父元素继承 opacity 属性的值。 data-toggle属性 data-toggle一般是a元素(即链接)的属性。data-toggle指以什么事件触发。详细的介绍 -webkit-tap-highlight-color属性 -webkit-tap-highlight-color 是一个没有标准化的属性，能够设置点击链接的时候出现的高亮颜色。显示给用户的高光是他们成功点击的标识，以及暗示了他们点击的元素。 @media 用法 @media可以让你根据不同的屏幕大小而使用不同的样式，这可以使得不需要js代码就能实现响应式布局。(即根据不同大小的页面重新排版) 语法： 123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 其中mediatype就是媒体类型，可以包括好多种，最常用的就是screen，其他多数已经作废。 media feature就定义了这个media设备的一些特征，简单的说就是媒体满足什么条件，常用的就是max-width，min-width。 具体的例子 margin属性 定义和用法：margin 简写属性在一个声明中设置所有外边距属性。该属性可以有 1 到 4 个值。 块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。 注释：允许使用负值。 例子 1：margin:10px 5px 15px 20px;上外边距是 10px;右外边距是 5px;下外边距是 15px;左外边距是 20px; 例子 2: margin:10px 5px 15px;上外边距是 10px;右外边距和左外边距是 5px;下外边距是 15px; 例子 3:margin:10px 5px;上外边距和下外边距是 10px;右外边距和左外边距是 5px; 例子 4:margin:10px;所有 4 个外边距都是 10px @media用法 用法详解 最后更新与2018.7.9]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>๑FrontEnd</tag>
        <tag>๑CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习——HTML]]></title>
    <url>%2F2018%2F06%2F17%2FFrontEnd-HTML%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 HTML基础 学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。(网页三件套大礼包～) 概念解析 HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。 JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。 一个html网页的基本结构123456789101112131415&lt;html&gt;&lt;head&gt;...&lt;/head&gt;&lt;body&gt;&lt;h1&gt;...&lt;/h1&gt;&lt;p&gt;...&lt;/p&gt;&lt;img src=&quot;...&quot;&gt;...&lt;/body&gt;&lt;/html&gt; 标签语法 标签由英文尖括号&lt;和&gt;括起来，如&lt;html&gt;就是一个标签。 每组标签都是一一对应的，且后一个标签以 /(正斜杠)开头，标志着这一个部分的结束。 标签与标签之间是可以嵌套的，但先后顺序必须保持一致，如：里嵌套，那么必须放在的前面。&lt;div&gt; &lt;p&gt; ... &lt;/p&gt; &lt;/div&gt; HTML标签不区分大小写，&lt;h1&gt;和&lt;H1&gt;是一样的，但建议小写，因为大部分程序员都以小写为准 代码注释 html代码注释的语法如： &lt;!--注释文字--&gt; 标签详解 &lt;html&gt;&lt;/html&gt;称为根标签，所有的网页标签都在&lt;html&gt;&lt;/html&gt;中。 &lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有&lt;title&gt;、&lt;script&gt;、 &lt;style&gt;、&lt;link&gt;、 &lt;meta&gt;等标签 在&lt;body&gt;和&lt;/body&gt;标签之间的内容是网页的主要内容，如&lt;h1&gt;、&lt;p&gt;、&lt;a&gt;、&lt;img&gt;等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。 其中，&lt;h1&gt;就是标题标签 &lt;p&gt;就是段落标签，段落内容就写在&lt;p&gt;与&lt;\p&gt;之间 &lt;img src= &quot;..&quot;&gt;表示图片，src中填写图片保存的路径 &lt;head&gt;标签 文档的头部描述了文档的各种属性和信息，包括文档的标题等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。 下面这些标签可以用在&lt;head&gt;部分： 1234567&lt;head&gt; &lt;title&gt;...&lt;/title&gt; &lt;meta&gt; &lt;link&gt; &lt;style&gt;...&lt;/style&gt; &lt;script&gt;...&lt;/script&gt;&lt;/head&gt; &lt;title&gt;标签：在&lt;title&gt;和&lt;/title&gt;标签之间的文字内容是网页的标题信息，它会出现在浏览器的标题栏中。网页的title标签用于告诉用户和搜索引擎这个网页的主要内容是什么，搜索引擎可以通过网页标题，迅速的判断出网页的主题。每个网页的内容都是不同的，每个网页都应该有一个独一无二的title。 &lt;p&gt;标签 每一对&lt;p&gt;&lt;/p&gt;标签表示一个段落，所以网页上每一段文字都要放在一对单独的&lt;p&gt;&lt;/p&gt;中。 &lt;hx&gt;标签 上面的&lt;p&gt;标签是用来表示文章的段落的，那么文章的标题可以用&lt;hx&gt;来表示，其中x为1-6的整数，数字越小，代表越重要，字体也就越大。(这一点与markdown的用#号个数来表示几级标题是一致的) 文本修饰：&lt;strong&gt;,&lt;em&gt;和&lt;span&gt;标签 &lt;em&gt;表示强调，&lt;strong&gt;表示更强烈的强调。并且在浏览器中&lt;em&gt;默认用 斜体 表示，&lt;strong&gt; 用 粗体 表示。 &lt;span&gt;标签是没有语义的，它的作用就是为了设置单独的样式用的。 例子： 1234567891011121314151617181920&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;了不起的盖茨比&lt;/title&gt;&lt;style&gt;span&#123; color:blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 1922年的春天，一个想要成名名叫尼克•卡拉威（托比•马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的&lt;span&gt;美国梦&lt;/span&gt;，他搬入纽约附近一海湾居住。 &lt;/p&gt; &lt;p&gt; 菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。他以诗人的敏感和戏剧家的想象为&quot;爵士乐时代&quot;吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 其中第一段中的“美国梦”被&lt;span&gt;标签标记，在&lt;style&gt;标签中，我们定义了&lt;span&gt;标签修饰的文本的格式为蓝色。 &lt;q&gt;标签 &lt;q&gt;&lt;/q&gt;标签表示引用，注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。 &lt;q&gt;&lt;/q&gt;适合一句话的引用。 &lt;blockquote&gt;标签 相对于&lt;q&gt;&lt;/q&gt;，&lt;blockquote&gt;...&lt;/blockquote&gt;适合用来引用一段长文字。 换行与空格 在 html 中是忽略回车和空格的，你输入的再多回车和空格也是显示不出来的 换行标签语法： 12xhtml1.0写法： &lt;br /&gt;html4.01写法： &lt;br&gt; 现在一般用html4的写法 与以前我们学过的标签不一样，&lt;br /&gt;标签是一个 空标签 。没有HTML内容的标签就是空标签，空标签只需要写一个开始标签，这样的标签有&lt;br /&gt;、&lt;hr /&gt;和&lt;img /&gt;。 空格表示方法：&amp;nbsp;。 水平分割线 在信息展示时，有时会需要加一些用于分隔的横线，这样会使文章看起来整齐些。效果如下 语法： 12html4.01版本 &lt;hr&gt;xhtml1.0版本 &lt;hr /&gt; 现在一般用html4的写法 &lt;hr /&gt;标签和&lt;br /&gt;标签一样也是一个空标签，所以只有一个开始标签，没有结束标签。 &lt;hr /&gt;标签的在浏览器中的默认样式线条比较粗，颜色为灰色，可能有些人觉得这种样式不美观，没有关系，这些外在样式在我们以后学习了css样式表之后，都可以对其修改。 &lt;address&gt;标签：为网页加入地址信息 &lt;address&gt;&lt;/address&gt;标签默认为斜体。这个也可以通过CSS修改。 &lt;code&gt;和&lt;pre&gt;标签 在网页上&lt;code&gt;&lt;/code&gt;标签用来标注一行代码。 如果是多行代码，可以使用&lt;pre&gt;标签。语法：&lt;pre&gt;语言代码段&lt;/pre&gt; &lt;pre&gt; 标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。 注意：&lt;pre&gt; 标签不只是为显示计算机的源代码时用的，在你需要在网页中预显示格式时都可以使用它，只是&lt;pre&gt;标签的一个常见应用就是用来展示计算机的源代码。 ul-li标签 实例： 12345&lt;ul&gt; &lt;li&gt;精彩少年&lt;/li&gt; &lt;li&gt;美丽突然出现&lt;/li&gt; &lt;li&gt;触动心灵的旋律&lt;/li&gt;&lt;/ul&gt; ul-li在网页中显示的默认样式一般为：每项li前都自带一个圆点： ol-li标签 与ul-li标签类似，只是前面的圆点变成了从1开始的序号 &lt;div&gt;标签 在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个&lt;div&gt;标签中，这个&lt;div&gt;标签的作用就相当于一个容器。 逻辑部分是页面上相互关联的一组元素。如网页中的独立的栏目版块，就是一个典型的逻辑部分。 一般一个网页都要用很多个&lt;div&gt;&lt;/div&gt;来划分成不同的逻辑部分。 &lt;div&gt;标签的命名 为了使逻辑更加清晰，我们可以为这一个独立的逻辑部分设置一个名称，用id属性来为&lt;div&gt;提供唯一的名称，这个就像我们每个人都有一个身份证号，这个身份证号是唯一标识我们的身份的，也是必须唯一的。 语法：&lt;div id=&quot;版块名称&quot;&gt;...&lt;/div&gt;(只需要在开始的部分添加，结尾不变) &lt;table&gt;标签 创建表格的四个元素：table、tbody、tr、th、td 整个表格以&lt;table&gt;标记开始、&lt;/table&gt;标记结束。 如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。） &lt;tr&gt;...&lt;/tr&gt;：表格的一行，所以有几对tr 表格就有几行。 &lt;td&gt;...&lt;/td&gt;：表格的一个单元格，一行中包含几对&lt;td&gt;...&lt;/td&gt;，说明一行中就有几列。 &lt;th&gt;…&lt;/th&gt;：表格的头部的一个单元格，表格表头。 表格中列的个数，取决于一行中数据单元格的个数。 table表格在没有添加css样式之前，在浏览器中显示是没有表格线的 &lt;a&gt;标签 &lt;a&gt;标签实现了超链接。 语法：&lt;a href=&quot;http://...(网址)&quot; title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt; 设置链接在新建窗口中打开：&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;链接显示的文本&lt;/a&gt; &lt;img&gt;标签 语法：&lt;img src=&quot;图片地址&quot; [alt=&quot;下载失败时的替换文本&quot;](一般可以不写) title = &quot;提示文本&quot;&gt; src：标识图像的位置 alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本 title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本) 表单标签 表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。 语法：&lt;form method=&quot;传送方式&quot; action=&quot;服务器文件&quot;&gt; ：标签是成对出现的，以开始，以结束。 action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。 method ： 数据传送的方式（get/post）。 例： 123456&lt;form method=&quot;post&quot; action=&quot;save.php&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;label for=&quot;pass&quot;&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;&lt;/form&gt; 所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 标签之间，否则用户的数据可能提交不上。 method : post/get 的区别这一部分内容属于后端程序员考虑的问题。 文本输入框、密码输入框 文本输入框可以转化为密码输入框。 语法： 123&lt;form&gt; &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;&lt;/form&gt; type：当type=”text”时，输入框为文本输入框; 当type=”password”时, 输入框为密码输入框。 name：为文本框命名，以备后台程序ASP 、PHP使用。 value：为文本输入框设置默认值。(一般起到提示作用) 文本域 语法：&lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt; cols ：多行输入域的列数。 rows ：多行输入域的行数。 注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。 在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。 Html5新元素一览 Html5新元素 最后更新于2018.6.17]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>๑FrontEnd</tag>
        <tag>๑Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop单机伪分布式环境搭建]]></title>
    <url>%2F2018%2F05%2F30%2FHadoop-usage%2F</url>
    <content type="text"><![CDATA[Hadoop 单机伪分布式环境搭建 前言 这是对之前spark环境搭建的一点补充。 首先要了解一下Hadoop的运行模式： 单机模式（standalone）:单机模式是Hadoop的默认模式。当首次解压Hadoop的源码包时，Hadoop无法了解硬件安装环境，便保守地选择了最小配置。在这种默认模式下所有3个XML文件均为空。当配置文件为空时，Hadoop会完全运行在本地。因为不需要与其他节点交互，单机模式就不使用HDFS，也不加载任何Hadoop的守护进程。该模式主要用于开发调试MapReduce程序的应用逻辑。 伪分布模式（Pseudo-Distributed Mode）: 伪分布模式在“单节点集群”上运行Hadoop，其中所有的守护进程都运行在同一台机器上。该模式在单机模式之上增加了代码调试功能，允许你检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。 全分布模式（Fully Distributed Mode）:Hadoop守护进程运行在一个集群上。 新建用户 添加一个名为hadoop到系统用户，专门用来做Hadoop测试: 12sudo addgroup hadoopsudo adduser --ingroup hadoop hadoop 再赋予hadoop用户 sudo的权限：sudo usermod -aG sudo hadoop 这里sudo是我的电脑上有sudo权限的用户组的名称，你可以cat /etc/group看看有哪些用户组以及这些用户组下的用户。 实在不行就吧你原来用户在的组都加一个hadoop用户 创建新用户并增加管理员详解 安装ssh 注意先切换到hadoop用户 命令：sudo apt-get install openssh-server 启动服务：sudo /etc/init.d/ssh start 检查服务是否正确启动：ps -e | grep ssh 配置ssh无密码登录 这个也要在hadoop用户下完成(因为这会在你这个用户的文件夹下的.ssh文件夹生成key) 我们要设置成免密码登录，生成私钥和公钥：ssh-keygen -t rsa -P &quot;&quot; 第一次操作时会提示输入密码，按Enter直接过，这时会在～/home/{username}/.ssh下生成两个文件：id_rsa和id_rsa.pub，前者为私钥，后者为公钥，现在我们将公钥追加到到authorized_keys中（authorized_keys用于保存所有允许以当前用户身份登录到ssh客户端用户的公钥内容）： cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 多台实体机进行通信（发送或者读取数据，namenode和datanode之间）就是借助ssh，在通信过程中如果需要操作人员频繁输入密码是不切实际的，所以需要ssh的无密码登录。 现在登录就不需要密码了：ssh localhost exit命令退出登录localhost 安装hadoop 我下载的是hadoop-2.7.6版本 存放的路径是/uer/local/Apache/hadoop-2.7.6 然后修改path环境变量，路径对应自己的实际存放路径： 修改hadoop-env.sh: (这个不能用默认的，否则会报错) 12export JAVA_HOME=$&#123;JAVA_HOME&#125; #将这个改成JDK路径，如下 export JAVA_HOME=/opt/jdk1.8.0_172 确保下面的操作在hadoop用户下完成：sudo chown -R hadoop:hadoop /usr/local/Apache/hadoop-2.7.6 (自己hadoop的安装路径) 最后输入 hadoop version 确认安装 至此单机模式配置完成(在hadoop用户下的单机模式) 伪分布式环境搭建-设定*-site.xml:这里需要设定三个文件。我的三个文件的路径是/usr/local/Apache/hadoop-2.7.6/etc/hadoop/ core-site.xml: Hadoop Core的配置项，例如HDFS和MapReduce常用的I/O设置等。 hdfs-site.xml: Hadoop 守护进程的配置项，包括namenode，辅助namenode和datanode等。 mapred-site.xml： MapReduce 守护进程的配置项，包括jobtracker和tasktracker。 首先在hadoop根目录下新建几个文件夹：1234mkdir hdfsmkdir hdfs/namemkdir hdfs/datamkdir tmp 接下来编辑这三个文件： core-site.xml:12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; hdfs-site.xml:1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;!--设置副本数1，不写默认是3份--&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/hdfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/hdfs/data&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; mapred-site.xml:123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;localhost:9001&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 格式化hdfs 启动Hadoop到相关服务，格式化namenode,secondarynamenode,tasktracker的文件系统目录:12source /usr/local/Apache/hadoop-2.7.1/etc/hadoop/hadoop-env.shhadoop namenode -format 启动hadoop 首先要先连接到localhost!!(否则无法在网页上查看节点)。ssh localhost 我的start-all.sh脚本在sbin目录下，各个版本可能不太一样，如果这个文件夹没有就去别的文件夹找找。 执行start-all.sh来启动所有服务: 12cd sbin./start-all.sh 使用命令jps查看是否启动成功：如果出现NodeManager DataNode Jps SecondaryNameNode ResourceManager NameNode则表示启动成功(缺一不可) 检查运行状态:所有的设置已完成，Hadoop也启动了，现在可以通过下面的操作来查看服务是否正常，在Hadoop中用于监控集群健康状态的Web界面： http://localhost:50030/ - Hadoop 管理介面 http://localhost:50060/ - Hadoop Task Tracker 状态 http://localhost:50070/ - Hadoop DFS 状态 目前我只有50070是正常访问的，其余的还不能访问，原因有待进一步探究 停止服务：./stop-all.sh 由于之前已经将hadoop的bin和sbin两个目录添加到系统环境路径里去了，这样下次启动直接就可以是 1234ssh localhoststart-all.sh...stop-all.sh 这样就方便很多了。 参考博客——hadoop伪分布式搭建，很详细的搭建步骤(Hadoop-2.7.2版本) 最后更新于2018.5.31]]></content>
      <categories>
        <category>Hadoop CLuster</category>
      </categories>
      <tags>
        <tag>๑Hadoop</tag>
        <tag>๑BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS相关笔记]]></title>
    <url>%2F2018%2F05%2F30%2FHDFS%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 前言 马上就六一了，赶在月底结束之前再记录一些东西吧～ 以下HDFS的操作是基于Ubuntu18的 HDFS简介 Hadoop分布式文件系统(HDFS)官方中文文档 Namenode 和 Datanode HDFS采用master/slave架构。一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。 HDFS采用Java语言开发，因此任何支持Java的机器都可以部署Namenode或Datanode。 Namenode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的Datanode一般是一个节点一个，负责管理它所在节点上的存储。HDFS暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。 从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组Datanode上。Namenode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体Datanode节点的映射。Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。 Namenode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被Namenode记录下来。应用程序可以设置HDFS保存的文件的副本数目。文件副本的数目称为文件的副本系数，这个信息也是由Namenode保存的。 Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常。块状态报告包含了一个该Datanode上所有数据块的列表。 HDFS中的文件都是一次性写入的，并且 严格要求在任何时候只能有一个写入者。 HDFS文件系统 DFSShell HDFS以文件和目录的形式组织用户数据。它提供了一个命令行的接口(DFSShell)让用户与HDFS中的数据进行交互。命令的语法和用户熟悉的其他shell(例如 bash, csh)工具类似。下面是一些动作/命令的示例： 创建一个名为 /foodir 的目录: bin/hadoop dfs -mkdir /foodir 创建一个名为 /foodir 的目录: bin/hadoop dfs -mkdir /foodir 查看名为 /foodir/myfile.txt 的文件内容: bin/hadoop dfs -cat /foodir/myfile.txt 常用 注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的 分布式文件系统的文件路径完整格式为 hdfs://namenode|master:编号/root/... 例如：hdfs://master:8020/dataset/evaluation/bots_10m_10.csv hdfs dfs -ls /...显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件 hdfs dfs -rm -r file_name|directory_name 删除某个文件或者目录 通讯协议 所有的HDFS通讯协议都是建立在TCP/IP协议之上。客户端通过一个可配置的TCP端口连接到Namenode，通过ClientProtocol协议与Namenode交互。而Datanode使用DatanodeProtocol协议与Namenode交互。 一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和Datanodeprotocol协议。在设计上，Namenode不会主动发起RPC，而是响应来自客户端或 Datanode 的RPC请求。 数据块 HDFS被设计成支持大文件，适用HDFS的是那些需要处理大规模的数据集的应用。这些应用都是只写入数据一次，但却读取一次或多次，并且读取速度应能满足流式读取的需要。HDFS支持文件的“一次写入多次读取”语义。一个典型的数据块大小是64MB。因而，HDFS中的文件总是按照64M被切分成不同的块，每个块尽可能地存储于不同的Datanode中。 最后更新于2018.5.31]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>๑Hadoop</tag>
        <tag>๑BigData</tag>
        <tag>๑HDFS</tag>
        <tag>๑Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks]]></title>
    <url>%2F2018%2F05%2F28%2FShaow-socks%2F</url>
    <content type="text"><![CDATA[科学上网从我做起 重大更新 现在大多数的ssr或者ss图形界面的在ubuntu18上已经歇菜了,但是这里分享一个命令行下的ss和一个图形界面的ssr(推荐)。 命令行方式的ss 12sudo apt-get install python-pipsudo pip install shadowsocks 通过配置文件指定配置信息 12345678910111213mkdir ~/.shadowsockscd .shadowsockstouch ss.json//添加内容如下&#123; &quot;server&quot;:&quot;1.1.1.1&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your passwd&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; server填你的服务器ip，sever_port填远程端口号，local_address本地ip，local_part本地端口，password填密码，timeout是延迟时间，method是加密方式，按照实际情况填写并保存 终端运行：sslocal -c ~/.shadowsocks/ss.json 后台运行(不推荐)：sslocal -c ~/.shadowsocks/ss.json -d start 现在运行的话会有报错，修改方法： 123456789vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py//跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup//将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)//再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)//然后就可以正常运行了 详细见博客 图形界面的ssr 首先说一句，图形界面不仅美观好用，而且可以支持在线订阅，及时更新，总之，我们又可以优雅地翻墙了，美滋滋～ 这里我fork了一份相关github的代码，链接 配置方法非常简单，可以导入json文件，或者从剪贴板导入等等。 参考文档 重点 上面两种方式而选一即可，但是下面还有最关键的一步，配置浏览器代理。 首先，想要实现全局模式请按如下方法设置：系统设置 &gt;&gt; 网络 &gt;&gt; 网络代理 &gt;&gt; 方法 &gt;&gt; 手动 再将Socks主机的ip和端口填好，如图。 然后，需要在google商店下载SwitchyOmega插件，但是需要翻墙～这里可以进入如下网址,先下载一个googlehelper插件(打开chrome所有插件，把下载的插件直接拉进去即可添加完成)，用邮箱注册一个免费的体验账号，先翻了墙再说。 然后去chrome网上应用商店下载SwitchyOmega，接下来便可以配置了。 在SwitchyOmega的配置页面先新建一个情景模式，选择代理服务器，名称为gfwlist(这个随意)配置时,代理服务器和代理端口分别是ssr config中的 “local_address”:”127.0.0.1” “local_port”:1080确认后无误后应用选项 接下来点击情景模式中的自动切换，输入参数如下： 1234条件设置：raw.githubusercontent.com 规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 点击立即更新情景模式 结束,在SwitchyOmega插件(chorme浏览器右上角处)那换成自动切换,大功告成. 最后把多余的情景模式删除,看起来清爽一点。 这样就相当于在chorme中启用的是pcd模式,在能穿墙的同时,既保证了访问国内网站速度不慢,又节省了ssr的流量。 接下来就可以优雅地体验翻墙上网了～ 最后更新于2018.5.28]]></content>
      <categories>
        <category>ScientificSurfing</category>
      </categories>
      <tags>
        <tag>๑Ubuntu</tag>
        <tag>๑Linux</tag>
        <tag>๑ScientificSurfing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA Ultimate版本使用]]></title>
    <url>%2F2018%2F05%2F25%2Fjetbrains%2F</url>
    <content type="text"><![CDATA[JetBrains Toolbox 如果你决定使用jetbrains的开发环境的话，那么去官网上获取一个jetbrains toolbox会是个不错的主意～ 这个工具可以很方便地管理你的所有jetbrains的产品，避免了太多快捷方式的麻烦。 免费获取Ultimate版本 jetbrains给学生的优惠还是非常大的，我们可以用我们学校的邮箱免费获取JetBrains全家桶 这个在我上一篇文章里也提到了，这里再作一次系统的记录。 Jetbrains学生免费账号申请 申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。注册的时候一定要确定邮箱的地址填写正确，不出于意外一分钟之内就能收到确认邮件。 如果填错了也没关系，你可以一遍一遍地写邮箱然后申请，jetbrains好像对此没有什么限制。 成功激活： 初始配置 装好Ultimate版本之后我们就可以开始配置一些东西了。 首先打开intellij IDEA，不用进入某个项目，在初始界面设置(这样这些设置便是对全局生效) 在plugins里面添加一些我们需要的插件。比如 scala , nodejs, junitGenerator2.0等，这些插件比community版本要丰富很多。 在 system settings 里面把 reopen previous project勾掉，这样每次打开我们就可以手动选择要打开的项目了。 然后在global lib里面点击绿色的加号，添加我们用到的编成语言的lib，在弹出的选择框里找到我们安装的目录。比如添加scala的lib，要找到scala sdk的安装目录即可，intellij 会自己扫描目录然后添加lib，最后保存确定即可。 添加已有工程时遇到的坑 最近老师布置了个jdbc的作业，是个eclipse的工程。但是在intellij打开的话，test部分始终有问题，不能访问到src里的代码。。 然后换了一种导入工程的方式，但是无论是eclipse方式导入还是maven方式导入，都会出现没有工程可以导入的错误???(No projects are found to import 这个问题在用eclipse来导入工程的时候也可能遇到) 上网查阅之后发现，可能是缺少.classpath文件和.project文件(或者有可能是这两个文件有问题)。 解决方法就是，用eclipse重新建立一个同名的工程，然后把这个工程里面的这两个文件复制到要导入的工程里再试着导入。 或者如果代码不太多的话，直接新建一个工程，把代码复制进去就好了。 最后更新于2018.6.4]]></content>
      <categories>
        <category>Computer Software</category>
      </categories>
      <tags>
        <tag>๑JS</tag>
        <tag>๑JetBrains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊(ethereum)开发]]></title>
    <url>%2F2018%2F05%2F23%2FEthereum%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 以太坊社区 安装Truffle Node.js安装 先要进行node.js环境的安装，见上一篇博客。 命令行安装truffle 执行命令 npm install -g truffle 创建工程 执行命令 truffle init truffle init会默认创建一个构建在以太坊内的代币demo应用。我们可以使用这个工程来进行快速的学习。 init 之后目录下就会有若干文件和文件夹。结构如下： contracts目录中包含Solidity合约代码，其中Migrations.sol是必须有的，其他就是你自己写的合约代码了。 migrations目录中包含合约部署脚本，其中1_initial_migration.js就是用来部署Migrations.sol的，其他的脚本会按照顺序依次执行。 test目录保存用来测试应用和合约的测试文件 truffle.js - Truffle的配置文件 官方文档(命令行指令，前面要加truffle)： 1234567891011121314151617181920Commands: init //Initialize new and empty Ethereum project compile //Compile contract source files migrate //Run migrations to deploy contracts deploy //(alias for migrate) build //Execute build pipeline (if configuration present) test //Run JavaScript and Solidity tests debug //Interactively debug any transaction on the blockchain (experimental) opcode //Print the compiled opcodes for a given contract console //Run a console with contract abstractions and commands available develop //Open a console with a local development blockchain create //Helper to create new contracts, migrations and tests install //Install a package from the Ethereum Package Registry publish //Publish a package to the Ethereum Package Registry networks //Show addresses for deployed contracts on each network watch //Watch filesystem for changes and rebuild the project automatically serve //Serve the build directory on localhost and watch for changes exec //Execute a JS module within this Truffle environment unbox //Download a Truffle Box, a pre-built Truffle project version //Show version number and exit 终端输入truffle即可查看上述命令 安装以太坊客户端 这里我们选择了Ganache——github项目 图形版本下载地址(linux下载 XX.AppImage文件格式的) 命令行版本（ganache-cli）下载 npm install -g ganache-cli Ganache的前身是testRPC 编译和部署合约 Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。要部署到链上，需要把IP、端口、网络ID告诉truffle。 若要修改，则修改truffle.js： 123456789module.exports = &#123; networks: &#123; development: &#123; host: &apos;localhost&apos;, port: &apos;7545&apos;, network_id: &apos;*&apos; // Match any network id &#125; &#125; &#125;; 编译合约合约位置 所有你的合约应该位于./contracts目录。默认我们提供了一个合约文件，一个库文件，均以.sol结尾作为示例。尽管库文件有一定的特殊性，但为简单起见，当前均称之为合约。 truffle cmpile 仅默认编译自上次编译后被修改过的文件，来减少不必要的编译。如果你想编译全部文件，可以使用–compile-all选项。 约定 Truffle需要定义的合约名称和文件名准确匹配。例如，如果文件名为 MyContract.sol，那么合约文件须为如下两者之一(并且匹配 区分大小写)： 1234567contract MyContract &#123; ...&#125;// orlibrary MyContract &#123; ...&#125; 编译目录:编译的输出位于./build/contracts 目录。如果目录不存在会自动创建。这些编译文件对于Truffle框架能否正常工作至关重要。你不应该在正常的编译或发布以外手动修改这些文件。 移植 命令 truffle migrate 这个命令会执行所有的位于 migrations 目录内的移植脚本。如果你之前的移植是成功执行的。truffle migrate 仅会执行新创建的移植。如果没有新的移植脚本，这个命令不同执行任何操作。可以使用选项 --reset来从头执行移植脚本。 修改配置 Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。要部署到链上，需要把IP、端口、网络ID告诉truffle。修改truffle.js： 123456789module.exports = &#123; networks: &#123; development: &#123; host: &quot;127.0.0.1&quot;, port: 8545, network_id: &quot;*&quot; // Match any network id &#125; &#125;&#125;; 详见官方文档 测试合约 直接执行命令：truffle unbox metacoin,创建这个项目。 由于metacoin的示例代码里已经把测试代码写好了，按照上面的修改完truffle.js之后，我们就可以编译部署测试我们的代码了： 123truffle compiletruffle migratetruffle test 结果如下: 然后打开 ganache查看区块链的变化。 Accounts标签：第一个账户里ETH略有减少，因为交易消耗了gas；Blocks标签：Ganache是自动挖矿，生成了6个新区块，每个区块里有一个交易；Transactions标签：有6笔新交易，可以点开看交易详情；Logs标签：显示交易和挖矿日志 最后更新于2018.5.23]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>๑BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习笔记]]></title>
    <url>%2F2018%2F05%2F21%2FNodeJS%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 javascript每个语句结尾不要忘了分号 Ubuntu 下的node.js环境搭建 首先去nodejs的官网下载最新的版本，解压缩。然后移动到 /opt/目录下 (纯粹个人习惯) 然后编辑路径： 12sudo suvim /etc/profile 然后在最后插入:(具体路径以实际为准) 12export NODEJS_HOME=/opt/node-v8.11.2-linux-x64export PATH=$NODEJS_HOME/bin:$PATH 最后执行source /etc/profile 或者重启电脑即可使之生效。 终端输入：node -v查看，如果能正确现实版本号，则说明配置成功。 Hello world 在常用目录下新建一个HelloWorld.js纯文本文件，在其中写入： 12&apos;use strict&apos;;console.log(&apos;Hello, world.&apos;); 第一行总是写上 &#39;use strict&#39;; 是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。 保存退出，执行 node HellowWorld.js即可得到结果。(终端输出“Hello,world.”) 在交互模式下，单行命令一般不用加分号(有时候加分号还会报错) 交互模式 在终端输入 node 即可进入 node.js的交互环境，我们可以直接输入javascript代码并直接执行。 进入交互模式实际上是进入了node的解释器，交互模式下node会直接打印每一个语句的结果，而写在js文件里的代码想要输出结果，必须自己用console.log()打印出来。(这与python，scala的命令行解释器特性一致) 使用严格模式 如果在JavaScript文件开头写上&#39;use strict&#39;;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上&#39;use strict&#39;;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：node --use_strict XXX.js IDE开发环境 在集成开发环境intellij IDEA下使用nodejs 我们可以尝试获取免费的注册码。 上述注册码的获取地址 hosts 文件路径 在 iOS 系统中中，hosts文件的位置为：~/private/etc 在 Windows 系统中，hosts文件的位置为：C:\Windows\System32\drivers\etc 在 Ubuntu 系统中，hosts文件的位置为：/etc jetbrains学生免费账号申请 Jetbrains学生免费账号申请 申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。有效期至毕业。 成功激活： 模块 在Node环境中，一个.js文件就称之为一个模块（module）。 分模块的好处是编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 例如，我们在一个js文件(hello.js)中写一个函数： 123456&apos;use strict&apos;;var s = &apos;Hello&apos;;function greet(name) &#123; console.log(s + &apos;, &apos; + name + &apos;!&apos;);&#125;module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 其他模块对本模块的调用,此处写一个main.js： 12345&apos;use strict&apos;;// 引入hello模块:var greet = require(&apos;./hello&apos;);var s = &apos;Michael&apos;;greet(s); // Hello, Michael! 引入hello模块用Node提供的require函数,引入的模块作为变量保存在greet变量中。./hello表明hello.js和main.js是在同一个目录下，这里需要写 相对目录。 CommonJS规范 这个规范保证了各个模块之间的同名变量和函数不会冲突 一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;，一个模块要引用其他模块暴露的变量，用var ref = require(&#39;module_name&#39;);就拿到了引用模块的变量。 输出的变量可以是任意对象、函数、数组等等 引入的对象具体是什么，取决于引入模块输出的对象 javascript本身并不支持同名函数或者变量冲突的处理，而node.js实现这一功能的原理是，JavaScript是一个函数式编程语言，node.js将每个模块包装为一个函数，这样这个模块里的变量就都成为了局部变量，这样就避免了冲突。——详细教程 最后更新于2018.5.24]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>๑FrontEnd</tag>
        <tag>๑JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链一些相关概念的记录]]></title>
    <url>%2F2018%2F05%2F17%2FBlockChain-concepts%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 一些主要的平台 比特币 以太坊 (需要翻墙) fabric EOS 一些概念 智能合约：智能合约是1994年由密码学家尼克萨博（Nick Szabo）首次提出的理念，几乎与互联网同龄。智能合约是指能够自动执行合约条款的计算机程序，在比特币出现以前，因为不存在安全可靠的执行环境，智能合约一直不能够应用到现实中。区块链由于其去中心化、公开透明等特性，天生就可以为智能合约提供可信的执行环境。所以，新型的区块链框架几乎都会内置智能合约的功能。 图灵完备：图灵完备性(Turing Compeleteness)是指针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称他具有图灵完备性。——参考 简单来说，对于任何一个可以由计算解决的问题都能解决的编程语言或者是虚拟机称为是图灵完备的 共识算法 POW(proof-of-work)： 工作量证明机制。工作量证明同时也是一种代币分发机制，它通过经济激励的方式来鼓励节点参与区块的构造过程，节点在构造区块的时候需要穷举一个随机数以使得区块符合规定的难度要求，一旦区块链出现分叉，诚实的节点将选择工作量较大的链条，而抛弃工作量较小的。由于假设所有节点都是逐利的，而选择工作量较小的链条就会使自己获得的激励无效，所以最终所有的节点都会是诚实的，从而使每个节点的区块链数据都保持一致。 BFT(Byzantine Fault Tolerance): 拜占庭容错模型的共识机制。节点被分为普通节点和记账节点（Validating Peer），只有记账节点才会参与到区块的构造过程，这种角色的分离使得算法的设计者有机会将运行共识算法的节点数量限定在一个可控的规模内。 PBFT(Practical Byzantine Fault Tolerance)： 实用拜占庭容错算法。PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|=3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。 POS(Proof of Stake)： 股权证明。类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。 DPOS(Delegated Proof of Stake)： 委任权益证明。股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。 石墨烯技术： 石墨烯技术是新一代的区块链技术，基于DPOS共识算法。目前市场上流行的区块链阵营有三种，一种是第一代以比特币为主的生态体系，他们是基于POW共识，纯粹的去中心化，基于p2p的加密数字货币技术；第二种就是以以太坊构成的生态体系，主要以基于智能合约的ERC20的代币体系，他们是基于POW共识，目前以太坊正准备切换到POW+POS的多共识体系；第三种就是进化到目前最强劲的石墨烯技术生态体系，它是基于DPOS（股份授权证明共识），支持高并发，高性能等大规模工业级商业场景的基础设施，诞生了BTS（BitShare）开源商业系统，Steem去中心化社交网络平台以及EOS。特点：转账速度特别快，吞吐量tps极高，安全性很高，没有原生bug出现，功能强大，应用性极高。 其他 WebAssembly： WebAssembly(缩写Wasm)是一种基于堆栈的虚拟机的二进制指令格式。Wasm设计作为一个便携式的针对高级语言的编译器，例如C/C++/Rust，使各种客户端或服务端应用程序都能够在web中部署。 TPS(transaction per second)： 服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。 QPS(quary per second)： 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 一些参考文章：比特币、以太坊、Fabric…你知道它们的优缺点吗？、区块链3.0：拥抱EOS 最后更新于2018.5.17]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>๑BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu进阶记录 & Ubuntu-18]]></title>
    <url>%2F2018%2F05%2F10%2FUbuntu-18%2F</url>
    <content type="text"><![CDATA[Ubuntu18 使用体验 一些装机软件的安装 由于Ubuntu 18 自带了 gnome3.0桌面,所以我们只需要下载一个tweak-tool据可以自定义桌面了： 12sudo apt-get updatesudo apt-get install gnome-tweak-tool 这次Ubuntu把标题栏改到了窗口的右侧，如果要改到左侧的话，打开tweak-tool转到窗口里面更改即可。 在更改用户主题之前，我们需要添加一个拓展插件才能使用自定义的主题 1sudo apt-get install gnome-shell-extensions 或者在gnome拓展网站上搜索 shell extensions ，找到这个插件并且安装最后重启tweak-tool即可。 Albert 一款很强大的快捷交互命令行。 勾选extention后可以执行强大的命令包括文件，程序，终端，计算器等等。 安装步骤： 1234wget -nv -O Release.key \ https://build.opensuse.org/projects/home:manuelschneid3r/public_keysudo apt-key add - &lt; Release.keysudo apt-get update 123sudo sh -c &quot;echo &apos;deb http://download.opensuse.org/repositories/home:/manuelschneid3r/xUbuntu_18.04/ /&apos; &gt; /etc/apt/sources.list.d/home:manuelschneid3r.list&quot;sudo apt-get updatesudo apt-get install albert 官网 主题修改 在网上找好主题以及美化的图标之后，分别下载下来，在home下创建 .themes 和 .icons两个文件夹，把主题和图标分别放到两个文件夹下即可使用。 一个mac风格的主题 gnome extensions recommend Ubuntu强大就强大在其可自定义的系统插件,这里罗列一下我自己使用的插件. Desktop Scroller: 可以在左右上下(用户自定义)屏幕边滑动鼠标滚轮来实现工作区的切换,十分便捷 Drop Down Terminal: 从顶端展开的一个终端,可以跨工作区. Keep awake!: 手动激活按钮使电脑不会进入待机状态 NetSpeed: 显示当前网速 Place Status Indicator: 可以快速获取当前位置和切换位置 Removable Drive Menu: 显示当前是否有挂载的设备,并且可以一键解除挂载 Screenshot Tool: 屏幕截图工具 User Themes: 可以自定义用户主题的拓展,必备. Blyr：使Overview有模糊背景效果 Coverflow(Alt-Tab)：应用程序切换效果，类似Mac OS X 使用ppa源时可能遇到的问题以及解决方案 遇到 sudo apt-get update 时提示 无法安全地用该源进行更新，所以默认禁用该源,使用sudo apt -o Acquire::AllowInsecureRepositories=true update来强制更新不安全的源。 遇到没有签名的问题时，使用 sudo apt-get update --allow-unauthenticated Ubuntu18装机的坑 ubuntu对独立显卡的支持很有问题，导致我在安装时一进去就卡死，后来找到了解决方法。 在进入安装界面之前(选择体验还是安装的那个界面)时侯按 e 进入启动参数编辑 ，找到 quiet splash 这一句，把它删掉，改为 i915.modest=0 nouveau.modeset=0 nomodeset (参数之间空格间隔) 然后 ctrl+x 就可以进入安装界面了。但是此时的安装界面分辨率是900*400的，贼坑，还好我只是覆盖安装之前的Ubuntu16，所以自动安装也还凑合，如果要手动分区安装的话就悲剧了… 同样的，在安装完成之后重启进入ubuntu系统之前(在那个紫色的界面时)还要按 e 进入启动参数编辑界面，更改同上，进入系统之后，找到 系统设置&gt;软件和更新&gt;附加驱动，安装Nvidia的独显驱动然后重启即可。 按下 alt + F7 之后就可以不受限制地自由移动窗口了。 详见我知乎上的文章 终端的字体 如果要自己更改一些字体的话，在tweak-tools 里面其他的字体都可以随便改，但是等宽字体不能随便该，否则终端的字体会出现交叠错乱的情况。终端的字体由等宽字体来控制，一定要选择以 “mono” 开头或者结尾的字体才不会出现问题。 相比较 Ubuntu 16.04LTS 网易云音乐比Ubuntu16更加坑了～我内心是万马奔腾的… ss-Qt5也用不了，翻墙只能靠命令行ssr了 搜狗输入法也是各种安装失败，我也懒得搞了，但是Ubuntu 18 的内置中文输入法手感贼舒服～搜狗装不上也就算了 Ubuntu的问题查询 很多时候国内的一些论坛无法解决我们在使用Ubuntu时遇到的一些问题，这时候就需要去一些国外的论坛上找我们需要的解答。这里推荐一个网站——askUbuntu Ubuntu 18 下可以使用的 ssr 链接 配置方法与windows几乎一致 关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！） 首先sudo打开会有报错,但是会自动启动默认设置 根据报错我们可以进行对应的安装: sudo apt-get install libcanberra-gtk-module 然后修改网易云音乐的desktop文件，在exec那一行 %U 之前 加上 --no-sandbox然后保存退出，重启电脑即可愉快的使用了～～(注意修改文件之前先要切换到root用户) 另一种神奇的打开方式(不需要上面的操作):启动之后，点关机按钮，弹出来确认框，随后网易乐音乐页面也弹出来了，这时取消关机，可以正常使用云音乐~~~ 关于ibus输入法的问题 最近输入法中文一直有问题，没办法选词。 博客链接 终端打开ibus设置命令：ibus-setup 但是感觉上面这个办法并没有声什么卵用。。。。 所以我弃坑了，还是选择了搜狗输入法 Ubuntu18 的搜狗输入法的安装 首先安装fcitx的相关依赖 12sudo apt-get install fictx-binsudo apt-get install fictx-table 然后安装下载好的搜狗输入法deb包dpkg -i sougou...这里应该会提示缺少依赖，这时候可就需要执行修复依赖： 12sudo apt-get updatesudo apt-get upgrade -f 系统会自动修复缺少的依赖包 然后我们就可以安装完搜狗输入法了。这时候在系统语言设置(右上角)里更改键盘输入法系统为fictx，然后把不用的输入法去掉。 最后重启电脑，打开fictx配置下搜狗输入法，把他调到第一个即可。 搜狗输入法支持登录一键同步，还是很好用的～ 搜狗輸入法的新坑 Ubuntu18 自从安装以来一直问题不断。 最近启动电脑发现搜狗输入法的候选词栏全变成了乱码。。。坑爹啊 后来百度了解决方法： 首先遇到高级全都勾上以便显示出所有的可更改项进入fictx设置&gt;&gt;附加组件&gt;&gt;简繁转换&gt;&gt;点击配置&gt;&gt;勾上显示高级选项&gt;&gt;将sogoupinyin:false改为sogoupinyin:true 但是这个方法只管用一次…下次重启还要手动改~~垃圾 所以接下来这个方法貌似有用(亲测) 输入如下命令：(就是把你个人用户的一些配置删除掉然后重新创建) 12cd ~/.configsudo rm -rf SogouPY* sogou* 之后注销重新登录即可。 就目前个人测试的结果看来，登录个人中心是元凶，登录之后必炸…还是老老实实地用最基本的功能吧，期待早日更新吧。 10.15更新 Ubuntu18.04详细配置、美化 gnome主题网站 最后更新于2018.5.14]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>๑Ubuntu</tag>
        <tag>๑Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于国产安卓机如何安装Google Play相关套件]]></title>
    <url>%2F2018%2F05%2F03%2FGoogle-play-Android%2F</url>
    <content type="text"><![CDATA[前言 自从有了长城防火墙以来，国人的“翻墙”运动一直未曾间断 本教程无需root权限即可完成 但是！本教程需要你已经有科学上网的工具才行~ 而且是手机端的~ (因为无论是登录还是下载软件都要翻墙) 正文 作为一个经常用到各式各样软件的用户，显然国产的软件市场只是能满足一般的国人用户，像我们这样的高端玩家看来那点国内的软件显然是不够的~ 就比如要下一个手机端的steam令牌，我用的是小米手机，之前还能在商店里找到下载，但是换了新手机之后莫名发现下架了，而且在商店里搜索所有有关谷歌的关键字都被自动屏蔽了…… 作为专业人士这怎么能忍？因此需要从google play store下载更全面的软件。 谷歌服务框架： Google服务框架全称Google Mobile Service，其中包含了应用包，就是一些google应用。Android虽然是开源的，但是google的应用却不包含在其中。厂家如果要预装google应用，都要与google达成付费协议以及其他一些原因，因此许多国内厂商不会自带google套件。 要体验完整的google服务，需要几个软件的支持：google服务框架(Google Services Framework)，google账户管理程序(google login Service)，google play服务(google play services) 以及 google play 商店(google play store) 至于有个一键安装的软件叫 go谷歌安装器，自己百度即可找到。如果可以一键安装成功，那么恭喜你，你可以直接开始愉快的体验了。 如果你也像我一样，安装时提示网络连接错误，挂了VPN也一样的话，那就只能自己去网上一个一个找上面提到的几款软件 尤其要注意软件的英文名称，下载时以英文名称为准，防止下载到一些流氓软件或者是木马文件，下载最好去比较正规的网站。 注意只有google play store 是安装后显示在手机桌面上的，其他的都是系统级的服务软件，装好之后不会显示。 全部安装完成之后，你可以打开 go谷歌安装器 主界面检测这几个软件是否正常安装，如果全是绿勾，则说明安装完成，这时候重启一下手机。 最后，挂上VPN，打开google play store，登录或者注册google账号即可开始使用~ 备注：如果找不到科学上网工具的朋友可以email我，如果我看到了可以给一些推荐。 最后更新于2018.5.3]]></content>
      <categories>
        <category>ScientificSurfing</category>
      </categories>
      <tags>
        <tag>๑ScientificSurfing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记——进阶]]></title>
    <url>%2F2018%2F04%2F29%2FPython-superior%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 格式化输出方法 格式：格式字符串.format(输出1, 输出2, ...输出n) 格式说明符使用大括号括起来，一般格式如下：{[序号或键]:格式说明符} 其中可选序号对应于后面的输出项，从0开始 例如： 12&gt;&gt;&gt; &quot;&#123;0:.2f&#125;,&#123;1&#125;&quot;.format(3.145,500) .2f表示输出的是浮点数，小数部分占两位，整数部分默认(.2f或者0.2f)&gt;&gt;&gt; &quot;3.15,500&quot; 注意前面格式字符串的引号不能少，如果省略序号，则Python会按顺序匹配后面的输出项，同时 格式字符串里除了大括号里面的内容是换成后面的对应的输出项，其余的内容会原样输出，比如&quot;I\&#39;m {}，and {}&quot;.format(&quot;Jake&quot;,&quot;Hello!&quot;) 会输出 I&#39;m jake, and Hello! 一些例子 print(&quot;{0:&lt;15}&quot;).format(12345)：左对齐 print(&quot;{0:&gt;15}&quot;.format(12345))：右对齐 print(&quot;{0:*^15}&quot;.format(12345))：中间对齐，并且用 * 补齐空格 print(&quot;{0:10b}&quot;.format(65))：以二进制输出 print(&quot;{0:10o}&quot;.format(65))：以八进制输出 print(&quot;{0:10x}&quot;.format(65))：以十六进制输出 常用模块 使用方法： 123import 模块名 #引入整个模块from 模块名 import 函数名 //引入某个函数from 模块名 import * //引入所有函数 如果引入多个模块，在使用模块的函数时最好使用 模块名.函数 的格式，防止各模块同名函数之间的冲突。 math模块常用函数 e ：返回常数e(自然对数的底) pi： 返回圆周率π fabs(x)： 返回x的绝对值，返回值为浮点数 #注：abs(x)为Python内置函数，返回值与参数一致，且abs()可以用来求解复数 sqrt(x)：返回X的平方根(x &gt; 0) pow(x,y)：返回x的y次方，返回值为浮点型 log(x,[base])：返回x以base为底的对数，默认底为e ceil(x)：对x向上取整，例 ceil(4.1) 返回5 floor(x)：对x向下取整。 cmath模块 cmath模块与math模块函数类似，但是cmath提供对复数运算的支持 complex(x,y)：返回复数 x + yi random模块 seed([x])：在生成随机数之前必须调用，否则每次生成的随机数都一样。seed()为随机数的生成产生一个种子(实际上就是Python的随机数从这个随机数开始计算)，可以直接无参调用，这样Python会自动设置种子。 uniform(a,b)：随机生成一个[a,b]范围内的实数 randint(a,b)：随机生成一个[a,b]范围内的整数 一些内置模块的函数 字符相关 ord(x)：返回x的ASCII码 chr(x)：这里x是ASCII码，返回其所对应的字符 lower(x)：将字符串中所有的大写变为小写 #这里的lower()和upper()为方法，使用格式为x.lower() upper(x)：将字符串中所有小写变为大写 数值运算相关 pow(x,y[,z])：返回x的y次方，返回值保持x或y的类型。如果加上参数z，则结果再对z求余数，即x^y/z abs(x):见math模块的与fabs()的区别 类型转换 int(x)：将x转化为整型 存为一个拷贝，x本身的值没有变 float(x)：将x转化为浮点数 最后更新于2018.4.29]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记——方法]]></title>
    <url>%2F2018%2F04%2F18%2FJava-function%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 函数 Java中的函数没有默认参数，通过函数重载间接实现这个功能。 java没有在类外面定义的函数，所以一般都是方法。 工具类函数的使用 如果要自己写一些可以复用的工具函数，可以新建一个class： 123class myUtils&#123; static void func(...)&#123;...&#125;&#125; 在这个类中将要用的工具函数用static来修饰，然后将函数的参数弄好之后，就可以在不用新建对象的情况下使用这个方法了。 最后更新于2018.6.6]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记——类与继承]]></title>
    <url>%2F2018%2F04%2F18%2FJava-class%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 Java的类，继承与接口 类的定义 类的修饰符有两种：public 和 缺省。public表示共有的访问级别，即任何类都可以访问它。缺省只允许同一个包中的类来访问它。 类的类型修饰符：缺省、abstract及final三种。abstract表示这是一个抽象类，有些方法 还没有实现。final表示这是一个最终类，不能被其他的类继承。 类是对象的模板，对象是类的实例化 一个类可以包含以下类型变量 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。（同C++中的静态变量） 最终变量：即常量，用final关键字修饰。一般与static关键字连用，例如定义PI、E等。 默认构造函数：java的类与C++一样可以写默认构造参数，格式也与C++一样，没有返回值，函数名与类名相同。有参数的构造函数也一样。 源文件声明规则 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。 如果一个类定义在某个包中，那么package语句应该在源文件的首行。 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。 除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。 对象对象的引用 创建对象后，可以将对象的引用赋值给其他对象变量。 例如下面的程序 12345678910public class test&#123; public static void main(String[] args)&#123; StringBuffer s; s= new StringBuffer(&quot;AAAAA&quot;); StringBuffer s1 = s; //此句会使得s1和s指向同一个对象 s1.append(&quot;BBBB&quot;); Syetem.out.println(&quot;s = &quot; + s.toString()); Syetem.out.println(&quot;s1 = &quot; + s1.toString()); &#125;&#125; 输出结果为： 12s = AAAAABBBBs1 = AAAAABBBB 方法参数传递按值传递(一般的函数参数) 传入方法中的参数是一份拷贝，对其的修改不会影响其本身123456789101112class Printer&#123; public void printinfo(String name, int age)&#123; age ++; System.out.println(&quot;Hello! My name is&quot; + name + &quot;and I&apos;m &quot; + age); &#125; public static void main(String args[])&#123; Printer p = new Printer(); int age = 20; p.printinfo(&quot;Mike&quot;,age); System.out.println(&quot;Now the initial age = &quot; + age); &#125;&#125; 按引用传递 调用方法时，如果传递的是一个对象、接口或数组时，实际上传递的是对象的、接口或者数组的引用。因此如果方法中对参数进行了修改，那么原来的数据也会受到影响。 继承 类的继承格式：123456class 父类&#123; ...&#125;class 子类 extends 父类&#123; ...&#125; 继承的特性 子类拥有父类非private的属性，方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java的继承是单继承，但是可以多重继承，java的多继承通过接口来实现。 关键字super和this在java的类中分别可以指代父类和类本身。 多继承的实现 抽象类 抽象类的定义： 1234[访问修饰符] &lt;abstract&gt; class &lt;类名&gt;&#123; [成员变量声明] [方法定义]&#125; 抽象方法的定义：抽象方法是指只有声明而没有实现方法，用abstract修饰，一般格式如下： 1[访问修饰符] &lt;abstract&gt; 返回类型 方法名(参数列表); 注意抽象类不能定义为final类，因为抽象类不能实例化。抽象方法也不能声明为final方法，因为要在子类中实现该抽象方法。 抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。 抽象方法必须由子类来进行重写。 只要包含了抽象方法的类，该类必须要定义成抽象类，不管是否还包含有其他已经实现了的方法。 抽象类中可以包含具体的方法，当然也可以不包含抽象方法。 子类中的抽象方法不能与父类的抽象方法同名。 abstract 不能与private、static、final或native并列修饰同一个方法。 接口 接口用interface来定义 抽象类是对类抽象，而接口是对行为的抽象。 接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name 接口实质也是一个抽象类，但与抽象类不同的是接口中只能包含常量的定义和方法的声明。接口只关心功能，而不关心功能的具体实现。 接口中的常量在声明时必须对它赋初始值。 一般的继承使用extends作为关键字，只能单继承。接口使用implements作为关键字。可以接受多继承。 接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷。 接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口。 接口的使用格式：[访问修饰符][类型修饰符] class 类名 implements 接口名1,接口名2,...... 一个类如果继承了某个接口，那么它就要实现这个接口的所有方法，否则这个类要定义为抽象类。 需要注意的是，接口中的方法默认是public，所以在类中实现接口时，必须使用public来修饰方法。如果接口中某个方法返回为void，则在类中实现该方法时，方法体可以为空，即只有两个大括号。 接口使用示例： 123456789101112131415interface Computable&#123; final int x = 10; int add(); void point();&#125;class TESt implements Computable&#123; private int y; public TEST(int y)&#123; this.y = y; &#125; public int add()&#123; //实现抽象方法时添加public 和 return 语句 return x + y; &#125; public void print()&#123;&#125; //返回类型为void方法体可以留空&#125; 接口之间也可以继承，用关键字extends，但是一个接口可以同时extends多个接口，之间以逗号间隔。 如果一个接口继承了别的几个接口，那么实现这个接口的类同时也要实现被这个接口继承的几个接口的所有方法。 Java中预定义的注释 形如 @Override等等在类方法之前的修饰就是预定义注释 预定义注释不仅仅是给人看的，编译器也会读取，会有相应的约束 预定义注释一共分为三种：Override、Deprecated和SuppressWarnings 我们平常一般 只会用到第一个，后两个对于我们没有太多的用处。 Override 这个注释的作用是标识某一个方法是否覆盖了它的父类的方法。 如果加了这个标识，那么这个类方法则必须要覆盖父类的同名方法，即被Override注释的方法必须在父类中存在同样的方法程序才能编译通过。 这样做的目的是，防止在子类中覆写父类的方法时，写错方法名导致最后子类的实例对象调用的还是父类的方法，这样就可能产生bug。 Deprecated 这个对类方法的注释主要是开发者用的。 这个注释不会产生什么实际的影响，但是被这个注释过的类方法如果被使用到的话，在编译时就会留下一些warning，警告内容是：这个方法现在还能用，但是下面版本的java可能会将它删除，也就是不推荐继续使用这个方法。 出现如下警告： 注意：test.java 使用或覆盖了已过时的 API。 注意：要了解详细信息，请使用 -Xlint:deprecation 重新编译 使用-Xlint:deprecation显示更详细的警告信息： ….. SuppressWarnings 这个世界的事物总是成对出现。即然有使编译器产生警告信息的，那么就有抑制编译器产生警告信息的。 SuppressWarnings注释就是为了这样一个目的而存在的。 这个注释可以抑制编译器产生一些警告信息。 用户自定义注释 详细了解——博客 最后更新于2018.6.15]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链初涉]]></title>
    <url>%2F2018%2F04%2F15%2FBlock-Chain%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 简述 区块链在当今可以说是非常的火了，但也有人批判区块链被炒得过于浮夸了。这里我们姑且不论，毕竟这只是一门技术，关键在于我们怎么利用它。 区块链是一种特殊的 分布式数据库，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。 区块链的数据安全性问题 区块链由一个个区块(block)构成，区块很像数据库的记录，每次写入数据，就是创建一个区块。 每个区块包含两个部分：区块头(head)——记录当前区块的元信息，区块体(body)——实际信息 区块头的元信息包括：生成时间，实际数据（即区块体）的 Hash，上一个区块的 Hash等等。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。因此，每个区块的hash值一定是不同的，可以根据hash值区分不同的区块。而如果区块的内容变了，那么他的hash值也一定会变 一个区块的hash是对这个区块的区块头计算的。区块头包含了区块体的hash(注意不是整个区块的hash)和上个区块的hash(这个是整个区块的hash)，只要这个区块的内容或者上个区块的hash(内容)变了，那么一定会引起这个区块内容的改变。因此，要想修改某个区块，那么就会引起一系列连锁反应，被修改区块后面的所有的区块的内容都必须修改，否则这个被改掉的区块就脱离区块链了，而这是不可能的，因为计算hash值是非常耗费时间和资源的，除非他一个人控制了全网一半以上的计算能力。 因此，区块一旦被写入便不可能被修改了，就像发生过的历史永远刻在时间上了一样，因此区块链的数据是十分安全可靠的。 区块链的分叉 在上述区块链的添加过程中，有一个问题，就是：如果有一个节点同时有两个区块加入，他们都连向前一个区块，那么这时候就形成了 分叉。 现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为”六次确认”）。按照10分钟一个区块计算，一小时就可以确认。(区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个)。因此新的区块链的生成规则就是，拥有计算能力更强的那条链，就是正宗的区块链。 回顾 区块链作为无人管理的分布式数据库，从2009年运行至今无明显问题，体现了其设计的合理性。 但是，有利必有弊。区块链的安全可靠是建立在效率和能耗的牺牲上的。生成一个区块最少要等待十分钟，而等待所有节点同步就更久了。同时，生成一个新的区块，需要矿工做许多无意义的挖矿，极其地耗费能源。 展望 区块链虽然有许多争议，但是其在某些领域确实有其独特的作用。其最大的特点就是数据的追踪和溯源。对于管理那些流通的物品，比如虚拟货币，一些农产品，枪支等等，区块链可以十分有效地保证这些领域的物资安全可靠性。 最后更新于2018.4.28]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>๑BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些文件类型记录]]></title>
    <url>%2F2018%2F04%2F15%2FFile-types%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 一些特殊的符号收集 符号收集 符号大全 CSV文件（逗号分隔值文件格式）(XX.csv) .csv文件实际上就是一种文本文件，其以纯文本形式存储表格数据，一般以逗号或者制表符作为分隔符 规则 开头是不留空，以行为单位。（每行末尾只有换行符，没有别的分隔符） 可含或不含列名，含列名则居文件第一行。 一行数据不跨行，无空行。 以半角逗号（即,）作分隔符，列为空也要表达其存在。 不支持数字，不支持特殊字符 实际上csv文件就类似于一个没有线的表格 Markdown文件(XX.markdown / XX.md) Markdown 的目标是实现「易读易写」。可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围 markdown可以直接在Atom中编辑和预览(ctrl + shift + m) markdown可以转换为pdf文件。你可以选择下载一些markdown编辑器来完成这个转化，但是，我在这里要推荐一个大佬的web应用(完美支持UTF-8中文编码，不会像其他的一些外国的网站转化时中文全部变成乱码的问题)，知乎上看到的。在线markdown转化为PDF Appimage文件(XX.AppImage) AppImage是一种在Linux系统中用于分发便携式软件而不需要超级用户权限来安装它们的格式。[1] 它还试图让允许Linux的上游开发者来分发他们的程序而不用考虑不同Linux发行版间的区别。 特性 AppImage不把Linux应用程序安装在文件系统相应的目录中。相反,它没有进行实际的安装。AppImage文件只是个压缩文件，在它运行时候挂载。 用AppImage打包的程序，一个程序就是一个文件。每一个文件都包含了该程序在其所要运行的目标平台上所需的运行库。AppImage文件是基于ISO 9660并经过zisofs压缩的包含有一个最小化的AppDir目录和一个极小的运行环境的文件。只要把这个文件添加到live CD中，这个程序便可被轻而易举地添加进live CD中。 用AppImage文件比安装一个应用程序更加简单。它不需要解压也不需要为系统环境做调整。使用主流Linux发行版的用户可以下载它，使其可执行，并且运行即可。 运行方法 添加可执行权限 chmod a+x *.AppImage 执行 ./*.AppImage 或者 右键 &gt; 属性(properties) &gt; 权限(Permissions) &gt; 勾选Allow executing file as program 之后直接运行即可 DLL文件 DLL是Dynamic Link Library的缩写，意为动态链接库。 A DLL file, short for Dynamic Link Library, is a type of file that contains instructions that other programs can call upon to do certain things. This way, multiple programs can share the abilities programmed into a single file, and even do so simultaneously. Unlike executable programs, like those with the EXE file extension, DLL files can’t be run directly but instead must be called upon by other code that is already running. However, DLLs are in the same format as EXEs and some may even use the .EXE file extension. While most Dynamic Link Libraries end in the file extension .DLL, others may use .OCX, .CPL, or .DRV. DLL文件存储了别的应用程序可以调用的做某项特定的事情的一系列操作，这样，多个程序就可以并发地执行一些操作，仅仅通过将这些操作写入一个文件。 操作系统有时候会因为中了流氓软件或者病毒而导致杀毒软件删除被感染的捆绑时清除dll文件，但是不到万不得已不要去第三方网页上下载缺失的dll文件——Important Reasons NOT to Download DLL Files。这篇文章详细地描述了直接下载缺失的DLL文件的可能的潜在危害。 如果电脑的DLL文件缺失导致某个软件不能运行之类的错误，尽量尝试重新安装这个软件而不是直接下载DLL文件来解决问题。 参考文档——What Is a DLL File]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>๑FileTypes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 与 github 随笔]]></title>
    <url>%2F2018%2F04%2F11%2FGit-and-Github%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的随笔~ 本地初始化仓库并添加远程仓库 示例：12345git init //初始化本地仓库git add . //将本地所有文件加到仓库里git commit -m &quot;...&quot; //设置提交信息git remote add origin git@github.com: ... //添加远程仓库git push -u origin master 关于 多用fetch，merge少用pull 有一篇文章提到了pull的一些弊端，主要是数据会被直接覆盖掉，这样回溯会比较麻烦。 关于windows和Ubuntu下的可视化git管理工具 windows windows下有一个非常好用的git管理工具，与github有很好的连接——github desktop。界面美观，方便好用。 同时要搭配Windows下的git来使用。 登录你的github账号之后，便可以非常轻松地clone，add，commit，push等操作。 左上角点开选择clone到本地的repo，右键选择open in explorer 即可进入存放本地文件的位置。对文件进行过修改之后，按照下面的同步步骤即可。 推荐使用命令行来实现同步。左上角点开后选择要修改的repo，右键选择 open in command 即可进入命令行。 一些简单的命令操作： 123git add . //把本地的所有修改addgit commit -m &quot;...&quot; //commit本地的修改，“...”中写本次修改的备注（这个备注必须有）git push //将本地的修改同步到github上 这样修改同步就完成了，一共只需要三步即可。 Ubuntu Ubuntu下找到一个甚至比Windows下的 github desktop更加好用的软件——GitKraken 在上面不仅可以进行查看同步等操作，甚至可以看到之前在这个repo当中所有的人做出的任何修改，并且可以查看修改了哪些内容！但是唯一美中不足的是有些更加NB的功能要开vip… 比Windows更加便捷的是，这里想要进入对一个repo进行同步的命令行（终端）时，只需要在界面按下Alt+T的组合键就可以打开相应的终端了。 atom 讲道理第一次使用atom时我还是很震惊的，居然有这么好用的软件。atom是一款编辑器，Linux和Windows平台都有，但是这个小小的编辑器整合了许多功能于一身，诸如代码编辑，github仓库文件的编辑以及直接add-commit-push一条线操作等等，还有许许多多的插件等待你去发现。 Atom自带支持markdown文件的编辑和预览，组合键 ctrl + shift + m 弹出预览。 atom的下载地址 最后更新于2018.4.19]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>๑Git</tag>
        <tag>๑Ubuntu</tag>
        <tag>๑Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark学习笔记——进阶]]></title>
    <url>%2F2018%2F04%2F11%2FSpark-superior%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 有问题经常去stackoverflow.com上找找或者直接去看官方的API原版或者翻译版:官方文档的中文版 DataSet 与 DataFrame Dataset是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个Dataset都有一个称为DataFrame的非类型化的视图，这个视图是行的数据集。 DataSet和RDD主要的区别是：DataSet是特定域的对象集合；然而RDD是任何对象的集合。DataSet的API总是强类型的；而且可以利用这些模式进行优化，然而RDD却不行。 Dataset的定义中还提到了DataFrame，DataFrame是特殊的Dataset，它在编译时不会对模式进行检测。在未来版本的Spark，Dataset将会替代RDD成为我们开发编程使用的API。 创建DataFrame12345678import org.apache.spark.sql.SparkSession...val sparkses = SparkSession .builder() .getOrCreate() //这两个为必须有的val df = sparkses.read.csv(&quot;...filename.csv&quot;)//这里read后面的方法名称与具体要读的文件类型有关df.show() //打印内容 创建DataSet 方法一：创建case class （对于复杂的数据没有成功） 例如 12345678val sparkses = SparkSession .builder() .getOrCreate()case class KeyValue(key: Int, value: String)import sparkses.implicit._ //引入隐式转换库val df = Seq((1,&quot;asdf&quot;),(2,&quot;34234&quot;)).toDF(&quot;key&quot;, &quot;value&quot;)val ds = df.as[KeyValue]// org.apache.spark.sql.Dataset[KeyValue] = [key: int, value: string] case class的参数上限为22 方法二：以元组隐式转化 例：12val tupDs = df.as[(Int,String)]// org.apache.spark.sql.Dataset[(Int, String)] = [_1: int, _2: string] 最后更新于2018.4.21]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑BigData</tag>
        <tag>๑Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark学习笔记——基础]]></title>
    <url>%2F2018%2F04%2F11%2FSpark-learning%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 有问题经常去 stackoverflow.com 上找找 环境搭建 首先确保电脑安装了JAVA Development Kit JDK(使用java -version查看版本) 安装hadoop（比如我在安装了hadoop-2.7.5），后面下载spark的版本时也要选择与hadoop版本一致的spark版本。然后添加hadoop路径到PATH（修改/etc/profile文件） hadoop单机伪分布式环境搭建详细见我的另一篇博客——hadoop单机伪分布式搭建 下载spark，解压，设置路径。 ———详细设置 调整日志级别控制输出的信息量：在spark安装文件目录的conf目录下将log4j.properties.template 复制为 log4j.properties, 然后找到 log4j.rootCategory = INFO, console。将其中的INFO改为WARN即可。 我的spark的安装目录是/usr/local/Apache/，可以使用命令echo $SPARK_HOME来查看spark的安装路径。 将spark的安装路径加到系统PATH当中(修改/etc/profile文件)，然后重启生效之后可在终端通过spark-shell命令进入scala的解释器环境，如图： sbt安装网址 编程环境 spark支持多种语言的编写，包括Python，Java，scala以及R语言，本篇中均采用scala作为编程语言。 使用的编译器为intellij IDEA，工程为maven项目 编译器的一些使用技巧 ctrl + Q 在intellij中可以快速地查看变量的类型 Maven 项目使用maven自带的打jar包的即可，不推荐在build当中打jar包 新建的Maven项目很可能缺失很多spark的库，需要修改pom文件来使得编译器引入这些库 以maven项目创建scala工程 详见 spark开发环境搭建 其中包括修改pom配置文件。 spark下的 wordcount 摘自官方文档 完整版： 12345text_file = sc.textFile(&quot;hdfs://...&quot;) //文件需要放在hdfs上counts = text_file.flatMap(lambda line: line.split(&quot; &quot;)) \ .map(lambda word: (word, 1)) \ .reduceByKey(lambda a, b: a + b)counts.saveAsTextFile(&quot;hdfs://...&quot;) 精简版(在spark-shell中执行就这一条语句即可)： (足见scala的优美与强大) 1val counts = sc.textFile(&quot;hdfs://...(文件路径，单机或者hdfs文件都可以)&quot;).flatMap(_.split(&quot; &quot;)).map(x =&gt; (x,1)).reduceByKey(_ + _).collect().foreach(println) //打印结果 注意：上面的.collect()不能少，因为这是一个action操作，一个语句如果没有action操作则spark什么也不会做。同时，读取文件的路径一定要用引号括起来！ 关于jar包以及提交集群运行 spark-submit命令 spark-submit脚本用于在集群上启动应用程序,它位于Spark的bin目录中。 命令行提交 命令行下切换到spark的安装目录，执行 12345678./bin/spark-submit \ --class &lt;main-class&gt; \ --master &lt;master-url&gt; \ --deploy-mode &lt;deploy-mode&gt; \ --conf &lt;key&gt;=&lt;value&gt; \ ... # other options &lt;application-jar&gt; \ [application-arguments] 脚本方式：(创建并编辑.sh脚本文件，赋予执行权限即可)12345678910111213141516171819input=/data/output=/AR_res/ hdfs dfs -rm -r $output hdfs dfs -rm -r /user_res spark-submit \ -v \ --name &quot;ARsMiner&quot; \ --class &quot;com.hazzacheng.AR.Main&quot; \ --executor-cores 4 \ --executor-memory 10G \ --driver-memory 20G \ AR.jar \ $input \ $output \ 2&gt;&amp;1 | tee log/AR_log rm -rf AR_res/ hdfs dfs -get $output cat /root$output/part* &gt; /root/res #sort /root$output/part* &gt; /root/res 常用的参数讲解 –class：应用程序的入口点,main函数所在的类（例如org.apache.spark.examples.SparkPi） –master：群集的主网址（例如spark：//23.195.26.187：7077） –deploy-mode：是否将驱动程序部署在工作节点（cluster）上，或作为外部客户机（client）本地部署（默认值：client） –conf：Key = value格式的任意Spark配置属性。对于包含空格的值，用引号括起“key = value”（参见示例）。 application-jar：包含应用程序和所有依赖关系的捆绑jar的路径。该URL必须在集群内全局可见，例如hdfs：//路径或所有节点上存在的file：//路径。 application-arguments：参数传递给主类的main方法（如果有的话） 常见的部署策略是从与您的工作机器物理上位于的网关机器提交应用程序（例如，独立的EC2集群中的主节点）。在此设置中，client模式是适当的。在client模式下，驱动程序直接在spark-submit过程中启动，该过程充当集群的客户端。应用程序的输入和输出连接到控制台。因此，该模式特别适用于涉及REPL（例如Spark shell）的应用。 或者，如果您的应用程序从远离工作机器（例如本地在笔记本电脑上）的机器提交，通常使用cluster模式来最大限度地减少驱动程序和执行程序之间的网络延迟。 其他的一些示例123456# Run application locally on 8 cores./bin/spark-submit \ --class org.apache.spark.examples.SparkPi \ --master local[8] \ /path/to/examples.jar \ 100 12345678# Run on a Spark standalone cluster in client deploy mode./bin/spark-submit \ --class org.apache.spark.examples.SparkPi \ --master spark://207.184.161.138:7077 \ --executor-memory 20G \ --total-executor-cores 100 \ /path/to/examples.jar \ 1000 12345678910# Run on a Spark standalone cluster in cluster deploy mode with supervise./bin/spark-submit \ --class org.apache.spark.examples.SparkPi \ --master spark://207.184.161.138:7077 \ --deploy-mode cluster \ --supervise \ --executor-memory 20G \ --total-executor-cores 100 \ /path/to/examples.jar \ 1000 12345678910# Run on a YARN clusterexport HADOOP_CONF_DIR=XXX./bin/spark-submit \ --class org.apache.spark.examples.SparkPi \ --master yarn \ --deploy-mode cluster \ # can be client for client mode --executor-memory 20G \ --num-executors 50 \ /path/to/examples.jar \ 1000 12345# Run a Python application on a Spark standalone cluster./bin/spark-submit \ --master spark://207.184.161.138:7077 \ examples/src/main/python/pi.py \ 1000 12345678910# Run on a Mesos cluster in cluster deploy mode with supervise./bin/spark-submit \ --class org.apache.spark.examples.SparkPi \ --master mesos://207.184.161.138:7077 \ --deploy-mode cluster \ --supervise \ --executor-memory 20G \ --total-executor-cores 100 \ http://path/to/examples.jar \ 1000 spark程序入口 Spark SQL中所有功能的入口点是 SparkSession 类. 要创建一个 SparkSession, 仅使用 SparkSession.builder()就可以了：123456789import org.apache.spark.sql.SparkSessionval sparkses = SparkSession .builder() //必须有 [.appName(&quot;Spark SQL basic example&quot;) ] [.config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;)] [.master(&quot;local&quot;)] .getOrCreate() //必须有// For implicit conversions like converting RDDs to DataFrames //即需要用到类型转换时，要引入这个以你的变量名字开头的隐式转换包import sparkses.implicits._ 未来Dataset可能会取代RDD作为主要使用的API，而RDD会成为最底层的供用户使用的API spark一般的入口是 sparkcontext类：1234import org.apache.spark.&#123;SparkConf, SparkContext&#125;... val conf = new SparkConf()[.set(...)...] val sc = new SparkContext(conf) 一些问题以及解决方法 如要学习spark请看官方文档以及源码 有问题经常去 stackoverflow.com 上找找 这里推荐一个官方文档的中文版供英语薄弱的朋友阅读。 试验了FP-Growth算法，打包到集群运行时报错:1Items in a transaction must be unique but got WrappedArrayMaven 出现此问题的主要原因是fpg算法要求输入的数据是RDD(Array[String])类型，但是Array类型中是不允许出现重复的内容的，所以才会出现这个错误，只需要对输入的数据做个distinct即可 spark-shell进不去，提示Insufficient space for shared memory file 出现这个问题的原因可能是某个文件分区的空间满了，一般可能是日志文件太多。 使用df命令查看文件系统：可以看到挂载点 / 的使用率已经是100%了，所以spark-shell会打不开，删掉一些文件即可。 一些小细节 spark中出现一长细条的信息才是报错 List 的 distinct 方法会对列表去重 item::list 将新生成一个列表，item会成为新列表的有元素 Array 不能被flatMap,必须为list.(?) scala中的.sortBy()方法如果在括号里最前面加上一个减号表示按逆序排序。 最后更新于2018.5.27]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑BigData</tag>
        <tag>๑Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库SQL语句]]></title>
    <url>%2F2018%2F04%2F07%2FSQL-quary%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 数据库的命令语句均不区分大小写 创建语句 基本创建 创建数据库 ：create database XXX 带详细参数的数据库创建： 123456create database School on( name = &apos;School_data&apos;, filename = &apos;c:\data\School_data.mdf&apos;, size = 5mb, filegrowth = 1mb --每次增长的大小) 创建表： create table XXX 带属性的创建： 1234567create table student( Sno char(6) primary key, Sname varchar(8), Ssex char(2), Sage smallint, Sdept varchar(15)) 更加复杂的创建： 1234567891011121314151617181920create table student( Sno char(6) primary key, --主键 Sname varchar(8) not null constraint ck_1 unique, --创建时加入约束条件 Ssex char(2) not null constraint ck_2 check(Ssex in(&apos;男&apos;,&apos;女&apos;)), Sage smallint constraint ck_3 check(sage&gt;16), Sdept varchar(15) default &apos;JSJ&apos; --默认值)create table course( Cno char(6) primary key, Cname varchar(20), Cpno char(4), Ccredit tinyint)create table SC( Sno char(6) not null, --要在表外添加主键的约束，则这个属性不能为空 Cno char(6) not null, Grade decimal(12,1) constraint ck_6 check(Grade &lt;= 100 and Grade &gt;=0) constraint fk_1 foreign key (Sno) references student(sno))alter table SC add constraint PK_SC primary key(Sno,Cno) check语句是一种约束条件写法，与constraint功能类似 在创建时设置foreign key：12345678create table sc( Sno char(6), Cno char(4), Grade decimal(12,2), primary key(Sno,Cno), foreign key(Sno) references student(Sno), foreign key(Cno) references course(Cno)) 创建索引123456create index Ix_student_sname on student(Sname)create index Ix_student_sdept on student(Sdept)create index Ix_sc_cno on SC(Cno)create index Ix_course_cname on Course(Cname)sp_help student --查看索引等信息drop index student.ix_student_sname --删除索引 插入数据： 数据顺序和类型要与创建时的定义一致 123insert into student values(&apos;5001&apos;,&apos;赵强&apos;,&apos;男&apos;,&apos;20&apos;,&apos;SX&apos;)insert into student values(&apos;5002&apos;,&apos;李丽华&apos;,&apos;女&apos;,&apos;21&apos;,&apos;JSJ&apos;)insert into student values(&apos;5001&apos;,&apos;李静&apos;,&apos;女&apos;,&apos;20&apos;,&apos;SX&apos;) 将数据从一个表插入另一个表123--批量插入数据(从student 到 sc_name)insert into sc_name (Sno,Sname,Ssex)select Sno,Sname,Ssex from student where Sdept = &apos;SX&apos; 在表外的更改操作 在表外更改表结构1234567891011create table student( Sno char(6), Sname varchar(8), Ssex char(2), Sage smallint, Sdept varchar(15))alter table student add address varchar(60) --添加列alter table student add inDate datetime --添加列，数据类型为datetimealter table student alter column adress varchar(50)alter table student drop column inDate 用户自定义完整性约束1234alter table student add constraint cs_1 check(Ssex in (&apos;男&apos;,&apos;女&apos;))alter table student add constraint cs_2 check(Sage &gt;16)alter table Course add constraint cs_3 check(Ccredit in (0,1,2,3,4,5))alter table Course add constraint cs_4 check(Cno != Cpno) 删除约束： alter table student drop constraint cs_1 更新表数据 使用update和查找条件： update student set Sno = 4018 where Sno = 4003 获取详细信息 sp_help 表名 sp_helpdb 数据库名 查询语句 基本查询操作 select [列名（逗号间隔）或者*] from 表名 进阶(单表)123select Sno,Sname,Sage from studentwhere Sage &gt;= 19 and Sage &lt;= 21 and Ssex = &apos;女&apos; order by Sage desc-- desc表示降序，asc表示升序 12select Sno,Ssex from student where Sname like &apos;_明%&apos; --&apos;_&apos;表示一个字符，%表示任意多个字符,这里筛选出名字第二个字为‘明’的人 12select Sno,Cno from SC where Grade is null-- 如果用&apos;= null&apos;则查询结果为空 12select Sno,Cno,cast((Grade/10) as int)from SC-- cast(a as int)转换数据类型 12select distinct Sdept from student-- distinct写在最前面 进阶（统计）123select count(*) as number from studentwhere Sname like &apos;%明%&apos;-- 统计名字有‘明’的人数 1234select Cno,sum(Grade) as total_grade,avg(Grade) as avg_grade,max(Grade) as max_grade,min(Grade) as min_grade from SC group by Cnoorder by avg_grade desc-- sum()求和 12345select Cno from SCwhere Grade &gt;= 85group by Cnohaving count(Sno)&gt;10-- where 筛选必须在group 之前，group之后可以用having筛选，两者可以并用 1234select Sno from SCwhere Grade &lt;60 group by Snohaving count(Cno) &gt; 2 进阶（连接）123select distinct Cno from student,SCwhere student.Sno = SC.Sno and Sdept = &apos;JSJ&apos;-- 连接要写出连接条件 123456789101112-- 三种写法select Sname from student,SCwhere student.Sno = SC.Sno and Cno = 1002XXXXXXselect Sname from studentjoin SC on student.Sno = Sc.Snowhere Cno = 1002 -- JOIN..ON..语句XXXXXXselect Sname from studentwhere Sno in( --嵌套执行 select Sno from SC where Cno = 1002) 123select student.Sno, Grade from student,course,SCwhere student.Sno = SC.Sno and course.Cno = SC.Cno and Cname = &apos;数据库原理&apos; and Grade &lt;60--用表名.列名来获取具有相同列名的几个表中某个表的某一列 12345678910-- 两种写法select student.Sname from student,SCwhere student.Sno = SC.Sno and Grade &gt;= 80 and Cno = 1004XXXXXXselect Sname from studentwhere Sno in( --嵌套写法 select Sno from SC where Grade &gt; 80 and Cno in( select Cno from course where Cname = &apos;数据库原理&apos; )) ### 进阶（嵌套）12345678-- 找出平均成绩最大的一个（两种写法）select top 1 Sno,avg(Grade) as avg_grade from SCgroup by Snoorder by avg(Grade) descXXXXXXselect Sno,avg(Grade) as avg_grade from SCgroup by Snohaving avg(Grade) &gt;= all(select avg(Grade) from SC group by Sno) 删除 删除表： drop table XXX 删除表中的内容： delete from XXX 删除数据库： drop database XXX 删除依赖： drop constraint XXX 补充 循环生成数据12345678910111213--生成大量数据create procedure usp_makedata asdeclare @nCnt int, @sNo char(6), @sname varchar(8)set @nCnt = 12000 --counterwhile @nCnt &lt;999999begin set @nCnt = @nCnt +1 set @sNo = convert(varchar(6),@nCnt) set @sName = &apos;张&apos; +@sno insert into student (sno,sname,ssex,sage) values (@sno,@sname,&apos;男&apos;,20)endreturnexec usp_makedata --执行生成过程 测试生成的数据1234567891011--生成测试create procedure usp_test asdeclare @nCount int ,@data intset @nCount=0while @nCount &lt;100begin select @data = count(*) from student where sname &lt;&apos;张3800&apos; or sname &gt;&apos;张8800&apos; set @nCount =@nCount + 1endexec usp_test --执行测试 善后12drop procedure usp_makedatadrop procedure usp_test E-R图的画法 实体型(Entity)：用矩形表示，矩形框内写明实体名 属性(Attribute)：用椭圆形表示，并用无向边将其与相应的实体连接起来 联系(Relationship)：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型(1 : 1，1 : n或m : n)。 (一对一，一对多还是多对多) 图例： 示例：画图时先画实体型和联系，最后添加属性即可。对于那些有公共属性的两个实体型，属性应当连到联系上(菱形上的属性) 从 E-R图转为关系模式： 首先是看有几个实体，每个实体单独存放为一个关系，即表。每个表的字段包含了这个实体所有的属性，即括号内的内容 然后分析实体间的联系。实体间联系有的要单独存一个表，有的不要。 如果实体和实体间是多对一或者一对一的关系则不需要单独创建一个表，而是通过在参与联系的多方实体中，增加一个参与联系的1方的实体的主键作为一列来表示联系。例如，车队和车辆是一对多的关系，这里 多 是车辆这个实体，1是车队这个实体。车队的实体的主键是车队号，所以，我们在多方(车辆)这个表中，增加1方(车队)的主键(车队号)作为一列来表示联系，即将 车队号 加到 车辆 这个实体的属性列表中。这里的 车队号 显然是 外键。 如果两个实体之间的联系是多对多的，联系要单独存放为一个表。这个表的主键，是参与联系的两个实体的主键的组合，而联系的属性作为其他列。例如：车辆和司机之间是多对多的关系，使用 联系名(车牌号，司机编码，使用日期，公里数) 这里的车牌号是 车辆 这一实体的主键，司机编码是 司机 这一实体的主键，而后面两个是联系的属性。外键是： 车牌号，司机编码。 每个关系的主键都要标出来，外键写在关系的最后，属性括号的外面。 简明教学 详细教学 最后更新于2018.5.3]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu终端常用命令]]></title>
    <url>%2F2018%2F04%2F06%2FUbuntu-order%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的备忘笔记 命令 常用基本命令 ls -l 的简略写法就是 ll，但是这个与ls -a又不同，后者用来显示隐藏文件和文件夹。 使用 vim修改文件时，如果想要不保存退出，使用:q!命令。 ubuntu改文件名用 mv name1 name2即可 cp filename filepath //拷贝文件 cp -r 源目录 指定目录 //拷贝一个文件夹到另一个目录 从hdfs上取文件到本地需要链接集群，然后 hdfs dfs -get /.../filename storepath 查看路径：例如用which python查看python安装的路径 sudo apt-get remove + 软件名 用于删除apt方式安装的软件 chmod [-可选参数][&lt;权限范围&gt;+/-/=&lt;权限设置&gt;] 文件/目录 //改变文件权限 chown [-R] username filename/directoryname //更改文件或者文件夹所属用户 touch 文件名命令用来创建一个空的文件 查看系统的所有PATH环境变量： echo $PATH rm -rf 强制 递归地删除某个文件或者文件夹的所有文件 dpkg -i filename.deb //安装 .deb 文件 grep语句 Linux grep命令用于查找文件里符合条件的字符串。 简单命令格式： grep [option] pattern file 完整格式： grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...] 例（最常用）：cat AR_log | grep &quot;====&quot;此句就是打印日志AR_log当中所有包含了”====”的行 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： 1grep test *file apt常用命令 apt-cache search package 搜索包 apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package 安装包 sudo apt-get install package - - reinstall 重新安装包 sudo apt-get -f install 修复安装 “-f = ——fix-missing” sudo apt autoremove 卸载某个软件并且删除与之相关的多余依赖 sudo apt-get update 更新源 sudo apt-get upgrade 更新已安装的包 apt-cache depends package 了解使用依赖 apt-cache rdepends package 是查看该包被哪些包依赖 sudo apt-get build-dep package 安装相关的编译环境 sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 scp语句 语法： scp [可选参数] file_source file_target 例:scp /home/fleshier/My_Programes/Programes/AssociationRuleDiscovery/target/AR.jar root@192.168.1.201:/root此句就是吧一个本地的文件拷贝到远端的服务器上，用户是root，服务器地址是192.168.1.201，存放目录是 /root 如果指定了用户名（如上例），则需要输入密码，如果没有指定用户名，则回车后需要输入用户名和密码。 使用参数-r来实现递归拷贝 例：scp root@192.168.1.201:/root/runAR.sh /home/fleschier/cloud\ computing/从远程服务器拷贝到本地 远程服务器的格式为 用户名@IP地址:文件路径 额外说明：如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下： 12#scp 命令使用端口号 4588scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator curl命令 curl命令是个功能强大的网络工具，支持通过http、ftp等方式下载文件、上传文件。还可以用来抓取网页、网络监控等方面的开发，解决开发过程中遇到的问题。 curl安装：sudo apt-get install curl get请求：curl http://www.baidu.com 回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。 更多详细参数——curl命令详解 gem命令 安装命令 gem install appname Gem 是一个管理 Ruby 库和程序的标准包 所有的 gem 包，会被安装到 /[Ruby root]/lib/ruby/gems/[ver]/ 目录下，这其中包括了 Cache、doc、gems、specifications 4个目录，cache 下放置下载的原生 gem 包，gems 下则放置的是解压过的 gem 包。 当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的 gem 包，然后重新运行 gem install [gemname] 命令即可。 参考资料：linux命令大全-菜鸟教程以及各大博客网站大佬们的博文。 df命令 df命令用来查看磁盘上的空间，默认以KB为单位 一般使用df-h命令来以KB以上的单位显示，可读性高 详解 find命令 语法：find path -option [ -print ] [-exec -ok command ] {} \; 详解 du命令 一般使用du -h [--max-depth = k] /路径来查看这个目录下的各个文件占用的空间 --max-depth用来调节深度，一般k取1 详细教程 压缩命令使用tar指令 Tar压缩文件: tar [-zxcvfpP] filename tar -N &#39;yyyy/mm/dd&#39; /path -zcvf target.tar.gz source 参数说明： 12345678910-z ：是否同时具有 gzip 的属性？ -x ：解开一个压缩档案的参数指令！ -t ：查看 tarfile 里面的档案！-c ：建立一个压缩档案的参数指令 -v ：压缩的过程中显示档案！ -f ：使用档名，请留意，在 f 之后要立即接档名,不要再加参数-p ：使用原档案的原来属性（属性不会依据使用者而变） -P ：可以使用绝对路径 -N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的档案中！--exclude FILE：在压缩的过程中，不要将 FILE 打包！ 例子 tar -cvf directory.tar directory//只将目录整合打包成一个档案 tar -zcvf directory.tar.gz directory//除了将目录打包外，同时以 gzip 压缩 tar -zcvf filename.tar.gz /home/test/*//将/home/test/ 这个目录下的档案全部打包并压缩成为一个 filename.tar.gz 的档案 tar -jcvf /tmp/etc.tar.bz2 /etc //打包后，以 bzip2 压缩 tar -xvf directory.tar//解 tar 的封包，请注意，由于没有 gzip (.tar 而非 .tar.gz) 的作用，所以只要使用–xvf 即可！不需要加上 z ，否则会显示有问题 tar -zxvf directory.tar.gz//解压 tar –ztvf directory.tar.gz//查看 tar 里面的档案信息 tar -zcvPf home.tar.gz /home//则建立起来的压缩档内档案为绝对路径//请注意，使用这个 P 的参数时，不要将 P 加在 f 后面，因为 f 之后要立即接档名才行！ HDFS相关命令 基本所有与HDFS相关的命令都以hdfs dfs开头 -mkdir /dirname 创建hdfs目录 -ls /dirname[/...] 列出某个目录下的所有文件 -rm -r /dirname 删除某个目录及其所有子文件 -get /hdfs路径 /本地路径 从hdfs拿文件到本地(例如hdfs dfs -get /data/test.txt /home/xxx/) -put /本地文件路径 /hdfs路径与拿文件相反,将本地一个文件传到hdfs上]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>๑Ubuntu</tag>
        <tag>๑Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记——基础]]></title>
    <url>%2F2018%2F04%2F06%2FJava-learning%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 Java编译环境 编译环境首选JetBrian的Intellij IDEA，虽然几乎所有的教材都清一色的使用eclipse，但是jetBrian的社区版Intellij IDEA已经满足了我们的需求，其无与伦比的代码补全功能，清爽的界面会让人眼前一亮。专业版只有公司里才可能会用到其中的一些功能，所以我们也不用担心。 Ultimate版本免费获取详见——Intellij IDEA Ultimate版本使用 使用intellij IDEA 之前需要配置一系列设置。 在打开项目之前的那个主界面，在设置里，systemsettings里把reopen previous project勾掉 在project structure里把lib里的东西添加一下(添加需要用到的编程语言的library)，以及设置默认的sdk/jdk。(在打开的项目里设置的仅仅对本项目有效) ctrl + alt + s 快速打开设置界面。 基本语法 java与C++一样，需要用分号来分割句子 第一个JAVA程序：Helloworld 示例12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); // 打印 Hello World &#125;&#125; 编写Java程序时注意点： 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java 程序由public static void main(String[] args)方法开始执行。 java的通配符与C++一样，都是* Java与C++不同的地方是：Java中的整数，浮点数不能与布尔值相互转换，当然也不能用0或非0的的整数代替true或者false。 Java数据默认值 八大基本数据类型的默认值： 数据类型 默认值 boolean false char ‘/uoooo’(null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d Java修饰符 像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符： 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, strictfp Java枚举 枚举限制变量只能是预先设定好的值,使用枚举可以减少代码中的bug12345678910class ENUM_class&#123; enum Test&#123;Small, Medium, Large&#125; Test size;&#125;public class ENUM_class_Test&#123; public static void main(String[] args)&#123; ENUM_class tst = new ENUM_class(); tst.size = ENUM_class.Test.Small; &#125;&#125; Java的三目运算符 格式：逻辑表达式 ? 值1 : 值2 执行过程：若逻辑值表达式为true，就取值1，否则取值2 例： 12int x =1,y =2;x&lt;y ? System.out.println(&quot;x&lt;y&quot;):System.out.println(&quot;x&gt;y&quot;); 注意，此三目运算符不是一个完整的式子，一般是用作赋值。 Java注释 Java注释与C++一致 Java的输入 Java的输入比起C++和Python要麻烦很多 方法一：1234567891011import java.io.* //引入java.io包的类......InputStreamReader in = new InputStreamReader(System.in);BufferedReader br = new BufferedReader(in);System.out.print(&quot;Please enter a num:&quot;);String s = br.readLine(); //从键盘读取一行字符到s中float num;num = Float.parseFloat(s); //将字符型转换成float型System.out.println();... 方法二：通过Scannner类 例子： 1234567import java.util.*...float score;Scanner sn = new Scanner(System.in);System.out.println(&quot;Please enter a num:&quot;);score = sn.nextFloat();System.out.println(); scan在读取多行数据时会遇到的问题： 1234Scanner scan = new Scanner(System.in)int num = scan.nextInt(); //这句会正确执行Double d = scan.nextDouble(); //这句也会正确执行，即使输入在不同的行上String s = scan.nextline(); //这句这样写便会读到一个空串××××××× 原因分析：首先，Scanner是一个扫描器，它扫描数据都是去内存中一块缓冲区中进行扫描并读入数据的，而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。这个扫描器在扫描过程中判断停止的依据就是“空白符”，空格啊，回车啊什么的都算做是空白符。 nextInt()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符“\r”在缓冲区中，但是，nextLine()方法在扫描的时候会将扫描到的空白符一同清理掉。 了解了这两个方法特性和区别，就知道了上边的代码究竟是怎么回事，以及知道了解决的方法。像是上边的代码nextInt()方法之后在缓冲区中留下了“\r”，然后nextLine()方法再去缓冲区找数据的时候首先看到了“\r”，然后就把这个“\r”扫描接收进来，并在缓冲区内清除掉。其实，nextLine()方法是执行过的，并没有不执行。 解决方案：在调用nextline()之前先调用一次nextline()将那个换行符读取掉 在读取Int的时候就调用nextline()方法，再用parseInt()转化为Int 方法三 这里需要import java.io.IOException; //否则会报错 读取下一个字符：123456import java.io.IOExceptionclass test&#123; public static void main(String[] args) throws IOException&#123; char c = (char) System.in.read(); &#125;&#125; 注意这里需要类型转换，默认为int类型，即读到的是字符的ASCII码。 将一串字符读入byte数组12345678import java.io.IOException;class test &#123; public static void main(String[] args) throws IOException&#123; byte[] input = new byte[5]; //创建一个byte数组来读取一串输入 System.in.read(input); //将输入存入byte数组中 System.out.println(input[1]); //这里输出的仍然是int类型，即ASCII码 &#125; &#125; 图形界面输入方式1234567import javax.swing.* //导入javax,swing包中的类...String str;float score;str = JOptionPane.showInputDialog(&quot;please enter a num:&quot;);score = Float.parseFloat(str);... 输出 标准输出：System.out.println(); 格式化输出：System.out.printf(); //格式化输出允许对输出进行规改 123456789101112131415//&quot;%&quot;表示进行格式化输出，&quot;%&quot;之后的内容为格式的定义。System.out.printf(&quot;%f&quot;,d);//&quot;f&quot;表示格式化输出浮点数。System.out.printf(&quot;%9.2f&quot;,d);//&quot;9.2&quot;中的9表示输出的长度，2表示小数点后的位数。System.out.printf(&quot;%+9.2f&quot;,d);//&quot;+&quot;表示输出的数带正负号。System.out.printf(&quot;%-9.4f&quot;,d);//&quot;-&quot;表示输出的数左对齐（默认为右对齐）。System.out.printf(&quot;%+-9.3f&quot;,d);//&quot;+-&quot;表示输出的数带正负号且左对齐。System.out.printf(&quot;%d&quot;,i);//&quot;d&quot;表示输出十进制整数。System.out.printf(&quot;%o&quot;,i);//&quot;o&quot;表示输出八进制整数。System.out.printf(&quot;%x&quot;,i);//&quot;d&quot;表示输出十六进制整数。System.out.printf(&quot;%#x&quot;,i);//&quot;d&quot;表示输出带有十六进制标志的整数。System.out.printf(&quot;%s&quot;,s);//&quot;d&quot;表示输出字符串。System.out.printf(&quot;输出一个浮点数：%f，一个整数：%d，一个字符串：%s&quot;,d,i,s);//可以输出多个变量，注意顺序。System.out.printf(&quot;字符串：%2$s，%1$d的十六进制数：%1$#x&quot;,i,s);//&quot;X$&quot;表示第几个变量。 图形界面输出1JOptionPane.showMessageDialog(....) //具体参数见类库 一些注意点 数组 数组的声明格式： 数据类型[] 数组名 或者 数据类型 数组名[] Java的数组声明只是指明了一个对象引用，并没有为数组元素分配内存空间。因此声明不能指定数组元素个数。例如：int a[10];是错误的。如果要声明并创建数组应该采用如下格式 ： 数据类型 数组名[] = new 数据类型[数组长度]。 数组的初始化与C++相同。例：int a[] = {1,6,8}; 这句相当于int a = new int[3]; a[0]=1,a[1]=6,a[2]=8; 只进行了声明的数组，它的元素是不能被访问的，只有经过初始化后，才能访问数组的元素。 数组的长度的获取：a.length 就表示数组a的长度（即a的元素个数）注意这里的.length是数组的属性（相当于类的尘成员变量）而不是方法，所以a.length()的写法是错误的，他把length当做一个类的方法来调用了 随机数Math.random() int num =(int)(Math.random() * 11); 生成一个范围在[0,1)的随机数。 java.util.Random 例：12345import Java.util.Random;Random rand = new Random([数值]);int randomNum = rand.nextInt() //Random支持的随机值类型包括：boolean, byte, int, long, float, doubleint randomNUM2 = rand.nextInt(100); //表示获取[0,100)范围的随机数... String类 String是常量，对一个String的任何修改都会使java创建一个新的String，而原来的会被当做垃圾回收掉 例如：12String a = &quot;avc&quot;;a = &quot;bfd&quot;; //则会创建一个新的string，然后将a链向这个string，原先的string会被抛弃掉 最后更新于2018.4.9]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记——基础]]></title>
    <url>%2F2018%2F04%2F06%2FPython-learning%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 Python语句不需要分号分割，但是Python各语句严格按照缩进对其方式运行 与C++一样，可以将一些非空，非零的值作为bool值的真，其余的为假 Python中以 #作为注释的开始，多行注释可以用三引号对。 环境 Python推荐使用jetbrain公司的pycharm Python可以直接使用自带的IDE逐句执行，方便测试 基础 Python中不需要声明变量类型，编译器会根据赋值自动判别，但是作为程序的编写者，我们需要清楚某个变量究竟是什么类型的 Python中单独的下划线是特殊的变量，表示上一次运算的结果。 输出 标准输出格式： print([输出1，输出2,....,输出n][,sep = 分隔符][,end = 结束符]) 默认以空格分割，换行符结尾 各个输出之间以逗号间隔 print()函数不写参数即默认输出一个空行。在一批数据输出结束后，好的编程习惯是在末尾加上一个print()，使得输出美观。 Python的输出可以有运算在里面，例如：print(5 * &#39;*&#39;) 则会打印出 ***** 在输出字符串时，可以在字符串的引号前加一个 r 使得转义字符 \ 失效。 输入 相比较于java，Python的输入可以说是非常灵活而且简便了 1a = input() #若调用此函数，就算输入的是数字，a的数据类型仍然为str，Python默认将命令行读入的数据作为str类型，因为str是万能的~ 但是，对于如下的情况： 12a =eval(input()) #eval() 函数用来执行一个字符串表达式，并返回表达式的值.例如 eval(&apos;2 * 3&apos;)返回 6#此时只能输入数字，且a是整型还是浮点型由输入数据的特征决定 如果想要同时为多个变量赋值，则只能使用eval()函数了 1x,y = eval(input()) #输入时以逗号间隔 对于eval()函数的使用，一定要确保参数去掉引号之后的值是有意义的 一些数据类型综述一些注意点 序列的概念：序列是一个排序的项目 容器，按 非负整数索引。Python提供的内置序列包包括字符串，元组和列表。(序列就是可以通过索引或者切片访问的容器) 所有的序列都是可以迭代的，即可以作为循环的迭代器。 内置函数len()可以将任意一个容器作为参数，并返回该容器中元素的数量 内置函数min()和max()以一个可以比较的非空容器作为参数，返回其最小最大值。(如果给的参数不止一个，则返回最大或最小的 参数) 对于字典使用min()和max()则会返回字典最大或最小的 键。 关键字 in 可以检查某个元素是否在一个容器中。例如k in D(D是一个字典)则检查k是不是D当中的一个关键字。 reversed(seq)函数： seq代表一个可迭代对象，比如列表 12345&gt;&gt;&gt; a = [1,2,3,4,5]&gt;&gt;&gt; b = reversed(a) #此时b为一个迭代器&gt;&gt;&gt; b1 = list(b) #将这个迭代器转化为列表&gt;&gt;&gt; b1&gt;&gt;&gt; [5,4,3,2,1] sum()函数： 12sum(seq, start = m) #sum()有两个参数，第二个为可选参数# 返回可迭代对象中的所有项目的和再加上start的值 一些基础数据类型的注意点 输入一个数，获取其各个位的数值的方法：注意Python的整除符号与别的编程语言不同 1234假设 x = 123个位 = x % 10十位 = x // 10 % 10 (注意，Python与其他编程语言的整除符号不同，比如C++就是 &apos;/&apos; 即表示整除，而Python为 &apos;//&apos;)百位 = x //100 % 10 复数： 12345a = complex(2,3)b = 1 + 2jc = 3 - 5j#a,b,c都是复数#要获取复数的实部和虚部，可使用例如：a.real(a的实部), a.imag(a的虚部)，结果都是浮点型 45e15表示45*10^15，这是科学计数法的写法 要判断两个浮点数是否相等，如果不确定精度的情况下，最好不要使用==来判断。因为可能存在看起来一样的数实际上因为精度不同而被判定为不等。解决的方法是abs(x - y) &lt; 1.0e-15，即是用两数之差的绝对值小于一个很小的数，即可判断两数近似相等。 关于Python中的bool类型，与C++类似，非零数或非空容器为真，0，None和空容器为假 List Python中list里的元素允许是不同的数据类型，这一点完全打破了C和C++体系的传统，所以平常编写程序不推荐这样做。list中也允许某个元素是list或者元组什么的。 例： classmates = [&quot;Mike&quot;,&quot;Davaid&quot;] len()函数可以获得list中的元素个数 与其他编程语言不同的是，Python的list下标允许负数的index，例如： classmates[-1]就表示这个list的最后一个元素，以此类推。 append()方法：在list末尾末尾添加元素：classmates.append(&quot;Alex&quot;) 把元素插入到指定的位置，比如索引号为1的位置：classmates.insert(1, &#39;Jack&#39;) 这样Jack的位置索引即为1，原来索引为1的元素及后面的元素依次后移。 删除list末尾的元素，使用.pop()方法，要删除指定位置的元素，使用.pop(i)的方法，i为元素的索引。 tuple 元组与；list非常类似，但是tuple一经初始化其内容便不允许修改，不允许插入和删除等操作。 元组一般用来保存那些不允许修改的数据以保障安全。 但是如果tuple中某个元素是list时，这个list中的元素还是可以修改的。 disk disk（字典）是一种键-值对类型的数据结构，在其他语言中会被称为map。dict的key必须为不可变的量 注意，Python中的dick类型是以hash方式存储的，读取速度非常快。 将数据添加进dick的方式，除了初始化时设定之外，还可以直接给一个键赋值的方式添加，例如： 12d = &#123;&apos;A&apos;: 95, &apos;B&apos;: 75, &apos;C&apos;: 85&#125; #初始化添加元素d[&apos;E&apos;] = 100 #直接赋值添加元素 判断一个key是否存在的方法： &quot;Thomas&quot; in d #若不存在会返回false d.get(&quot;Thomas&quot;) #若不存在返回null d.get(&quot;Thomas&quot;,-1) #自己指定返回的值 set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 通过.add(key)的方法添加元素。 通过.remove(key)的方法删除元素。 符号 &amp; 和 | 分别表示集合的交和并 list的简单的去重： 1234567&gt;&gt;&gt; a = [1,2,2,3,4,5,5,6,1]&gt;&gt;&gt; b= set(a)&gt;&gt;&gt; b&gt;&gt;&gt;&#123;1,2,3,4,5,6&#125;&gt;&gt;&gt;a =list(b)&gt;&gt;&gt;a&gt;&gt;&gt;[1,2,3,4,5,6] 条件判断 Python的if判断语句的判断条件部分不需要用括号括起来，这与其他的大多数语言均不同 格式： 12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 例： 1234567age = 20if age &gt;= 6 and age &lt;= 30: #多条件判断用 and 链接 print(&apos;teenager&apos;)elif not (age &gt;= 18): #not相当于 非，后面的内容用括号括起来 print(&apos;adult&apos;)else: print(&apos;kid&apos;) 与input结合（涉及数据类型转换）： 1234567s = input(&apos;birth: &apos;)birth = int(s) #如果没有这句转换会报错，因为input进来的是str，不能直接和int比较，因此要先转换为int再比较。#但是如果此处的输入不是一个数值类型，int函数无法强制转化便会报错。if birth &lt; 2000: print(&apos;00前&apos;)else: print(&apos;00后&apos;) 利用运算符优先级： z = x if x &gt; y else y 循环 例（求和）： 123for x in [1,2,3,4,5,6]: sum = sum + xprint(sum) range()函数： 生成从0 - 输入数值-1 的一个迭代器，可用作循环条件。例list(range(5))的结果为 [0,1,2,3,4] 例求 1- 100 的和： 1234sum = 0for x in range(101): sum = sum + xprint(sum) while循环示例：(素数的判断) 123456789101112import mathm = int(input(&quot;Please enter a num: &quot;)) #待判断的数 mi,j = 2, int(math.sqrt(m)) #只需要计算 2 到 根号m 范围内是否有m的因数即可，后面的计算均为重复计算flag = 1 #素数标志while i &lt; j and flag == 1: if m % 1 == 0 flag = 0 #不是素数的标志 i += 1if flag and m &gt; 1: #素数必须大于1 print(m, &quot;是素数&quot;)else: print(m, &quot;不是素数&quot;) while和for语句使用拖尾的else子句： 1234for ... : ... ...else ... #注意这个else是与for对齐的 这种写法的else子句块会在循环 正常终止时执行。意思就是，如果循环中的break语句生效而导致的循环终止，是不会触发这个else子句的执行的。因此这种写法可以 优雅地判断一个循环是正常结束还是break掉了。 在循环中使用print()输出时，注意Print之后是否正确地结束循环或者进入下一个输出，否则可能出现重复输出大量重复数据的可能。 求两个数的最大公约数(辗转相除法): 12345678a,b = eval(input(&quot;请输入两个整数: &quot;))if a &gt; b : a,b = b,a #Python中可以简便地交换两个变量的值r = a % bwhile r != 0 a,b = b,r r = a % bprint(&quot;最大公约数是：&quot;,b)print() 输出[100,1000]以内的所有素数 1234567891011121314import mathn = 0for m in range(101,1000,2) #直接去掉100和1000，这两个肯定不是素数 i,j = 2, int(math.sqrt(m)) while i &lt;= j: if not(m % j): #如果 m % j == 0 就是找到因数了，直接退出这一次循环，进入下一个循环 break else: i = i + 1 else: print(m, end = &quot; &quot;) n += 1 if n % 10 == 0: print(&quot;\n&quot;) #每输出10个数就换行print() 函数 函数定义的格式123def 函数名([参数1,参数2,参数3...]): #参数没有参数类型，如果要设置参数的默认值则要满足从右向左的原则 [函数体] [return [返回值]] #没有写return或者直接写return都是返回None Python中可以让函数返回一个有多个元素的tuple来实现返回多个值的要求。 一些注意点 abs() 函数的返回值与参数一致，而fabs() 的返回值均为浮点型 Python支持连续的不等式，例如a &gt; b &gt; c 等价于 a &gt; b &amp;&amp; b &gt; c 最后更新于2018.4.28]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记——类]]></title>
    <url>%2F2018%2F04%2F06%2FC%2B%2Blearning-class%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 类 模板类 示例： 12345678910111213141516template &lt;class T&gt; //声明一个模板，虚拟类型名为T。注意：这里没有分号。 class T_Class //类模板名为Compare &#123; public : Compare(T a,T b)&#123; x=a;y=b; &#125; T max( )&#123; return (x&gt;y)?x:y; &#125; T min( )&#123; return (x&lt;y)?x:y; &#125; private : T x,y; &#125;; 模板类所有的函数，如果在类外面实现的话，需要写成如下形式： 1234template &lt;class T&gt;T_Class&lt;T&gt;::max( )&#123; return (x &gt; y)? x : y; &#125; 模板类不能将类的声明写在头文件而定义写在源文件中，这样会出现无法辨析的编译错误。 最后更新于2018.4.6]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala学习笔记——基础]]></title>
    <url>%2F2018%2F04%2F06%2FScala-learning%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 编译环境 scala在终端中就可以调用解释器，与python类似，可以逐语句执行。使用命令scala即可进入终端解释器，使用命令:q或者:quit退出解释器。 编译首选jetbrain的intellij IDEA，下载一个Scala plugin，然后选择创建maven工程，main函数应当写在object文件中，object通过创建Scala class文件选项创建。 如果要写分布式处理程序的话，需要自己重写配置文件 Scala注释与C++类似 让intellij默认不打开上个项目的方法 settings&gt;Apperance&amp;Behavior&gt;System Settings 将Reopen last project on startup 勾去掉即可. 在intellij IDEA下创建scala项目的步骤 首先，要确保已经安装了scala的插件(这个有很大概率会安装失败，如果失败次数太多可以选择离线安装，或者跳过scala sdk的选择，在进入一个scala项目之后选择补全) 然后，在欢迎页面的右下角点击Configure，然后在Project Defaults的下拉菜单中选择Project Structure，在打开的页面左侧选择Global Libraries，然后在中间一栏中有一个绿色的加号标志 +，点击后在下拉菜单中选择 Scala SDK 然后在打开的对话框中选择系统本身所安装的Scala（即System对应的版本），点击OK确定，这时候会在中间一栏位置处出现Scala的SDK，在其上右键点击后选择Copy to Project Libraries…，这个操作是为了将Scala SDK添加到项目的默认Library中去。 在欢迎界面点击Create New Project，在打开的页面左侧边栏中，选择Maven，然后在右侧的Project SDK一项中，查看是否是正确的JDK配置项正常来说这一栏会自动填充的，因为我们之前在1.3中已经配置过了全局的Project JDK了，如果这里没有正常显示JDK的话，可以点击右侧的New…按钮，然后指定JDK安装路径的根目录即可）。注意不要选择create from archetype 然后点击Next，来到Maven项目最重要三个参数的设置页面，这三个参数分别为：GroupId, ArtifactId和Version. 创建Hello world 为了让体验Scala更清爽一些，将一些暂时无关的文件和文件夹都删除掉，主要有 main/java, main/resources 和 test 这三个文件夹 将Scala的框架添加到这个项目中，方法是在左侧栏中的 项目名称 上右键菜单中点击 Add Framework Support…，然后在打开的对话框左侧边栏中，勾选Scala前面的复选框，然后点击确定即可（前提是上文中所述步骤都已正确走通，否则你很有可能看不到Scala这个选项的）； 在main文件夹中建立一个名为 scala 的文件夹，并右键点击 scala 文件夹，选择 Make Directory as，然后选择Sources Root ，这里主要意思是将 scala 文件夹标记为一个源文件的根目录，然后在其内的所有代码中的 package ，其路径就从这个根目录下开始算起。 在已经标记好为源文件根目录的 scala 文件夹 上，右键选择 New，然后选择 Scala Class，随后设置好程序的名称，并且记得将其设置为一个 Object(类似于Java中含有静态成员的静态类)，正常的话，将会打开这个 Object 代码界面，并且可以看到IntelliJ IDEA自动添加了一些最基本的信息； 示例程序12345object HelloWorld &#123; def main(args: Array[String]) &#123; println(&quot;Hello, world!&quot;) // 输出 Hello World &#125;&#125; 执行scala程序 脚本执行：我们可以将 Scala 表达式写在一个文件里，比如 Hello.scala。在命令行中直接输入 scala Hello.scala 作为应用程序执行：作为应用程序执行时，我们需要在一个单例对象中定义入口函数 main，经过编译后就可以执行该应用程序了。 基础 scala的语句分号规则与C++相类似(一般都不用加，加了一般也不会错) scala中的通配符为_，而C++中为*` scala与spark很契合，所以写spark程序推荐使用scala语言 变量 Scala中变量分为可变变量和不可变变量。可变变量用关键字var修饰，不可变变量用val修饰。 注意scala中变量定义时必须赋初始值 scala大多数数据结构中的变量默认为val类型 特例：若用占位符_作为值进行初始化，则String类会被初始化为null,Float,Int,Double等被初始化为0,Char类型会被初始化为”?”. 如果用lazy关键字修饰变量，则他只有在真正被使用时才会被赋值。 注意lazy关键字只能修饰val类型变量，不能修饰var类型 输入输出输出：print(&quot;...&quot;) 或者 println(&quot;...&quot;)输入： 注意，控制台的输入均为string类型，需要在后面加上.toInt .toFloat等转换操作 控制台输入： 1234val scan = scala.io.StdIn //设置scanval n = scan.readLine.trim.toInt //输入一个intval arr = scan.readLine.split(&quot; &quot;).map(_.trim.toInt) //输入一串数字，之间以空格间隔// .trim方法是去掉输入字符串两旁的空格 scala还有一系列专门的用来读下 一个 输入并且可以自动转换的方法，例如： 123456val scan = scala.io.StdInval myint = scan.readInt()val myfloat = scan.readFloat()val myboolean = scan.readBoolean()...//这些方法均可以读取下一个输入并且自动转换类型 排序 例如：1234567val a = new Array[Int](3)a(0) =1a(1) = 2a(2) = 0a.foreach(print) //结果: 120val sorted_a = a.sortWith((x,y) =&gt; x &gt; y) //从大到小排序（sortWith的参数为一个lambda函数，返回一个布尔值用于比较）a.foreach(print) //结果： 210 一些注意点 scala中没有 ++ 操作，可以用 += 1 代替 ++（x += y ，y可以是一个数字，也可以是一个数字变量，但不能是数组或是其他一些类似结构的某个元素） Scala所有数据类型首字母都要大写，因为Scala中所有值类型都是对象，其中布尔类型应写为“Boolean” Scala中有 &lt;= 和 &gt;= 以及逻辑与 &amp;&amp; 和逻辑或 || 运算符，与C++相同。 Scala中String类型就是Java中的String.lang.String类型，因此可以调用Java中String的所有方法（例：str.reverse表示字符逆序） Scala中有一类特殊的运算符 “::”(list构造)，”:::”(list拼接)，他们是右操作。例如：a::b::Nill执行顺序为(a::(b::Nill)) 一些数据类型整型和浮点型 整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。 如果浮点数后面有f或者F后缀时，表示这是一个Float类型，否则就是一个Double类型的。 符号字面量 也就是符号类型 符号字面量被写成： ‘&lt;标识符&gt; ，这里 &lt;标识符&gt; 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。 string类 一个Array[String]类型的数据使用 .toString方法后得到的是一个java.lang.string类型的数据，这个数据直接print是这个Array的地址（一堆符号） string类的substring方法，有两个参数，第一个参数为起始位置，第二个参数为结束位置，可以不写，默认为末尾 通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。 Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于： 1getClass().getName() + &apos;@&apos; + Integer.toHexString(hashCode()) 将java.lang.string以可读的形式打印出来的方法： 元组类型（类似于Python中的元组） 如果想要访问元组的内容，可以通过 变量名._N的方式进行。其中N表示元组中元素的索引号。 例：tuple._1 表示tuple中的第一个元素。 注意：元组的访问元素的索引是从1开始，而且是不可改变的。 元组用 == 进行比较时，是进行内容的比较，这与String类型一致。 数组 数组的索引是从0开始的 声明格式： 12val a: Array[String] = new Array[String](3)或者： val a = new Array[String](3) 赋值： a(0) = &quot;abc&quot; //注意即使是声明为val变量，数组a的元素的值也是可以改变的。 同时，使用索引时数组名后面跟的是圆括号而不是方括号，这点与C++不同，切记 可以使用foreach()方法实现遍历。 List 创建List:12val a = List.apply(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)val a: List[String] = List(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;) 流程控制结构 判断语句 if语句格式： 123456if(条件判断)&#123; [...] //条件判断为真时执行&#125;else&#123; [...] //条件判断为假时执行&#125; //也可以写成 if()&#123;...&#125; else if()&#123;...&#125; 同C++ 与Java，C++不同的是，Scala中if语句可以作为表达式使用。例： 12scala&gt; val x = if(&quot;hello&quot; == &quot;hell&quot;) 1 else 0x: Int = 0 从这个例子可以看出，if是个表达式，其返回值可以给变量赋值。Scala会将if语句的最后一条执行语句作为返回值 循环语句 while循环,do..while循环同C++ for循环格式： 123for(i &lt;- 表达式)&#123; [...]&#125; 示例： 123for(i &lt;- 1 to 3)&#123; println(&quot;i = &quot; + i);&#125; 结果： i = 1 i = 2 i = 3 (1 to 3 的集合是包含3的) 其中 ‘&lt;-‘被称为生成器（generator），for循环实际上是通过集合的遍历来达到循环的目的的。 如果希望集合是右开的，可以使用1 until 5来实现，范围是[1,5) 还可以设置for 循环的步长。例： 123for(i &lt;- 1 until (10，2)) println(&quot;i = &quot; + i);结果： i =1 i = 3 .... i = 9 不过，由于Scala是函数式编程，应当尽量使用迭代来代替循环 例如：使用 标识符.foreach()方法来实现对元素的遍历 最后更新于2018.5.27]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu随笔]]></title>
    <url>%2F2018%2F04%2F06%2FUbuntu-operation%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的备忘笔记 Ubuntu目录结构 /:这就是根目录，一台电脑有且只有一个根目录，所有的文件都是从这里开始的。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。 /root:系统管理员（root user）的目录。至于系统管理员的权限有多大我这里就不在废话了。因此，请小心使用root帐号。 /boot: 系统启动文件，所有与系统启动有关的文件都保存在这里 。 /bin: 这里是存放系统的程序。 /etc:主要存放了系统配置方面的文件。 /dev:这里主要存放与设备（包括外设）有关的文件（unix和linux系统均把设备当成文件）。想连线打印机吗？系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、USB驱动等都放在这个目录。 /home:这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。 /tmp:这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。因此，千万不要把重要的数据放在这里哦。 /usr:在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序；/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等；/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器会自动帮你管理好/usr目录的。 /opt:这里主要存放一些可选的程序。如你想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就 可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 usr/local:这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts）放到/usr/local目录下面。 /media:这个目录是用来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。 一些推荐的软件 一旦出现某个软件没有安装，Linux系统大多数情况下都会提示你怎样安装这个软件，最常用的就是 sudo apt-get install XXX 命令 fish! fish! fish!： fish大法好啊，功能强大，自动补全，Ubuntu最好用的软件之一。 vim和gedit：这个不用我多说大家都知道，Linux非常好用的编辑软件 atom //集成许多功能于一体的编辑器 SpaceVim模块化Vim-IDE。使用手册 gnome 桌面： 装了gnome桌面和它的一系列插件之后我才真正感受到了Ubuntu的魅力！（教程以及主题百度很多） docky: 一款mac风格的dock,删除图标直接拉出去(sudo apt-get install docky) tweak-tool: 与gnome桌面对应的是tweak-tool(sudo apt install unity-tweak-tool) yakuake : 可以从上方一键滑出和滑入的终端（滑出时强制窗口在最前端）（gnome中也有类似功能的插件，两个选一个即可） Moeditor: Ubuntu下界面简洁美观，功能强大的markdown格式文件编辑器，已经在github上开源 processon： 一个网页上的设计工具，可以很简单地完成诸如流程图的设计和生成图片文件。 一些注意点 F11键可以进入全屏模式 触摸板双击之后再移动就相当于长按鼠标左键的效果了 在Ubuntu终端窗口中，复制粘贴的快捷键需要加上 shift，即粘贴是 ctrl+shift+v。 ssh cyx@192.168.1.201 cyx 高性能服务器 WIFI:sklcc_slave 192.168.1.201:18080 192.168.1.201:18088 进程 192.168.1.201:50070 hdfs 关于添加Ubuntu的本地ssh-key与github相关联 首先检测本地有没有安装ssh 终端输入ssh 然后终端执行ssh-kengen -t rsa，连续三次默认回车就行。接着 ~/.ssh目录下就会多出来两个文件：id_rsa和id_rsa.pub 接着只要在github上添加id_rsa.pub这个key就行了。在github的setting中，找到sshkey一栏，选择new key，将id_rsa.pub的文件内容复制到里面，随便起个title即可。 关于挂载本地的卷到Ubuntu 使用mount /dev/卷名 /挂载点 //将某个卷挂载到某个文件目录下，该卷就可以在这个文件目录下访问了。 Ubuntu中，所有的硬件设备都是作为文件存储的，这一点与Windows不同。 关于桌面快捷方式的创建 方法一：进入 /usr/share/applications/ 目录，里面会有绝大多数你安装的软件的 .desktop文件，只需要把你需要的软件的 .desktop文件复制到home目录下的 桌面文件夹里即可。 方法二： 有点蠢但是很简单的一个方法。对于那些没有安装直接可以使用的软件，我们在上个方法中提到的文件夹里是找不到 .desktop文件的。怎么办呢？我们只需要进入我们那个软件的目录，找到启动文件，创建一个它的链接文件（右键还是终端随意），然后将这个链接文件复制到桌面，改下名字即可。虽然和简单，但是缺点是没有图标….身为一个外观党还是有点难以接受的… 方法三：就是自己写一个.desktop文件，这里举例我写的Moeditor的桌面文件： 12345678910111213141516171819//首先终端切到桌面vim Moeditor.desktop//然后输入如下内容[Desktop Entry]Version=1.0Type=ApplicationName=MoeditorGenericName=MoeditorComment=editor for markdownExec=/home/fleshier/Programe\ Files/Moeditor-linux-x64/Moeditor %F //文件启动器的路径Terminal=falseIcon=/home/fleshier/Programe\ Files/Images/icons/g10.png //图标的路径StartupNotify=trueActions=Window;//空行[Desktop Action Window]Name=New WindowExec=/home/fleshier/Programe\ Files/Moeditor-linux-x64/Moeditor -nOnlyShowIn=Unity; 保存之后执行 chmod a+x filename 改变执行权限即可运行 实际写的时候要把注释删除掉，不然会出错。 关于shell脚本的创建 首先可以touch一个文件再进行内容的修改。或者直接vim filename新建一个文件并进行内容的编辑 所有shell脚本本质上都是文本文件，命名格式为filename.sh,内容必须以#!/bin/bash为第一行，当中没有空格。 事实上，这个#!字符序列是一种特殊的结构叫做 shebang。 这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字。每个 shell 脚本都应该把这一文本行作为它的第一行。 示例写法： 123#!/bin/bash#This is a test script! #本句是一个注释，&apos;#&apos;号之后的字符都会被忽略echo &apos;Hello World!&apos; #本句会在终端中打印 &quot;Hello World!&quot; 然后在终端中执行： chmod +x filename.sh 为这个脚本文件添加可执行权限 或者使用另外一个更改权限的写法： 12345[me@linuxbox ~]$ ll hello_world-rw-r--r-- 1 me me 63 2009-03-07 10:10 hello_world[me@linuxbox ~]$ chmod 755 hello_world[me@linuxbox ~]$ ll hello_world-rwxr-xr-x 1 me me 63 2009-03-07 10:10 hello_world 对于脚本文件，有两个常见的权限设置：权限为755的脚本，则每个人都能执行，权限为700的 脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。 最后是运行脚本，终端进入脚本所在文件夹，输入： ./filename.sh Linux中添加环境变量的方法 $PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。 为什么要添加环境变量呢？如果你在Linux下载了一个免安装的软件，你要启动它的话，要么创建一个桌面快捷方式（方法见上文），要么就是每次进入它的目录点开。这时候如果我们把它添加进了PATH环境变量，那么我们只需要在终端中输入这个软件的名字，回车，就可以启动它了。 方法一：修改profile文件（注意：一定要切换到root用户，一定要切换到root用户，一定要切换到root用户(sudo su)! ! ! ! 否则最后保存文件会一直被拒绝又退不出去只能强退终端…可能还会有其他一些麻烦事…总之有的爽呢…） //对所有用户永久生效 123456(root模式下执行) vim /etc/profile在文档最后加入一行:export PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**&quot;(一般都是 /.../bin目录)退出修改后在root模式下执行： source /etc/profile或者重启 spark-shell的路径写法例子： 12export SPARK_HOME=/usr/lib/spark/spark-2.2.0-bin-hadoop2.7export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH 使用source命令时要关闭fish，否则会报错 方法二：修改.bashrc文件（注意点同上）//仅对当前用户永久生效 1234(root模式下执行)vi /root/.bashrc在文档最后加入一行：export PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**&quot;退出修改后在root模式下执行： source /root/.bashrc 这两种方法最后的source语句就是让系统重新读取文件使之生效，没有写最后一句source的话，会在下次启动系统后生效 分布式文件系统(HDFS) 注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的 分布式文件系统的文件路径完整格式为 hdfs://namenode|master:编号/root/... 例如：hdfs://master:8020/dataset/evaluation/bots_10m_10.csv hdfs dfs -ls /...显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件 hdfs dfs -rm -r file|directory 删除某个文件 附vim教程 最后更新于2018.4.19]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>๑Ubuntu</tag>
        <tag>๑Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala学习笔记——进阶]]></title>
    <url>%2F2018%2F04%2F06%2FScala-superior%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的学习笔记 case class与模式匹配 case class一般被翻译为样例类，它是一种特殊的类，能够被优化以用于模式匹配。 - scala性能测试 测试程序的运行时间的函数：System.currentTimeMillis() 用法： 12345[...] val time = System.currentTimeMillis() [要测试运行时间的代码段] println(&quot; 耗时: &quot; + (System.currentTimeMillis() - time)) //以时间差来看运行时间[...] 函数式循环 函数式编程的循环都是用迭代来实现的 例1：对于一个Int数组a,对里面每个元素执行 +1的操作 1234a.map&#123;x =&gt; val y = x + 1 //因为Int是不可变类型，所以必须要新建一个值来存储改变后的值 y //返回值是y&#125; 例2：对于一个Int数组，每找出一个大于5的数count就加1 12345var count:Int = 0a.foreach&#123;x =&gt; //与map遍历方式不同，foreach不会对里面的内容修改，所以匿名函数也不需要返回值 if(x &gt; 5) count += 1&#125; 一些数据结构的使用 ListBuffer: 首先需要引入包 import scala.collection.mutable.ListBuffer 在使用之前，先声明一个ListBuffer变量，通过以下代码：val buf = new ListBuffer[Int]() //类型自定义，这里采用的是Int 在末尾进行追加，使用append()方法：buf.append(x) 将ListBuffer转化为List:val lst = buf.toList Scala类的实例 -12345678910class Point(xc: Int, yc: Int) &#123; var x: Int = xc var y: Int = yc def move(dx: Int, dy: Int) &#123; x = x + dx y = y + dy println (&quot;x 的坐标点: &quot; + x); println (&quot;y 的坐标点: &quot; + y); &#125;&#125; Scala中的类不声明为public，一个Scala源文件中可以有多个类。以上实例的类定义了两个变量 x 和 y ，一个方法：move，方法没有返回值。Scala 的类定义可以有参数，称为类参数，如上面的 xc, yc，类参数在整个类中都可以访问。 类的字段要初始化，不然会报错(错误：类必须申明为抽象类才行) scala的一些笔记综合 this关键字与构造函数主构造函数 Scala提供了一个类的主构造函数的概念。如果代码只有一个构造函数，则可以不需要定义明确的构造函数。它有助于优化代码，可以创建具有零个或多个参数的主构造函数。 scala主构造函数示例：(即在类中以参数的形式体现) 1234567891011class Student(id:Int, name:String)&#123; def showDetails()&#123; println(id+&quot; &quot;+name); &#125; &#125; object Demo&#123; def main(args:Array[String])&#123; var s = new Student(1010,&quot;Maxsu&quot;); s.showDetails() &#125; &#125; 次要(辅助)构造器 可以在类中创建任意数量的辅助构造函数，必须要从辅助构造函数内部调用主构造函数。this关键字用于从其他构造函数调用构造函数。当调用其他构造函数时，确保要将其放在构造函数中的第一行。 Scala二次构造函数示例： 12345678910111213141516class Student(id:Int, name:String)&#123; var age:Int = 0 def showDetails()&#123; println(id+&quot; &quot;+name+&quot; &quot;+age) &#125; def this(id:Int, name:String,age:Int)&#123; this(id,name) // Calling primary constructor, and it is first line this.age = age &#125; &#125; object Demo&#123; def main(args:Array[String])&#123; var s = new Student(1010,&quot;Maxsu&quot;, 25); s.showDetails() &#125; &#125; 并且在this二次构造函数的第一个语句，调用主构造函数this()的参数与主构造函数一致(如上例中的id和name两个参数)。 最后更新于2018.5.27]]></content>
      <categories>
        <category>Computer Programs</category>
      </categories>
      <tags>
        <tag>๑Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UEFI双系统的那些坑]]></title>
    <url>%2F2018%2F04%2F06%2Fubuntu-and-windows%2F</url>
    <content type="text"><![CDATA[不适合人类阅读的自我备忘笔记 关于ubuntu 和 windows 双系统 在长时间使用Windows时候，难免会想要尝试新系统，而专业又是如此，于是我选择了linux中图形界面最为友好的ubuntu系统作为自己双系统的入门系统。 虽然网上的双系统教程多说的很是简单，但是大多数已经是几年前的文章了，其中所讲的一些计算机的硬件系统已经落伍了，就比如说，网上绝大多数的双系统引导模式是建立在bios支持legacy（传统模式）模式下的，然而我自己的bios只能在UEFI模式下引导系统启动…..作为一名计算机系的学生当然不服气啊，当然各种百度什么的，期间踩过的坑实在难为外人道也。 如果你的电脑支持legacy模式的话，自行百度一些教程就行了。装好ubuntu系统之后，进入bios将启动顺序整下，将Ubuntu启动器放在Windows boot manager前面就可以了。因为Ubuntu启动器可以调用Windows boot manager 而Windows不能启动Ubuntu。 但是，UEFI作为最新的计算机启动模式，肯定要比原来的更加快速，或者如果你也像我一样，电脑不支持legacy启动，那么下面将要介绍一个非常好用的第三方启动引导程序。 第三方启动引导程序——refind refind是一款功能非常强大的开机启动引导程序，它能够自定义开机界面。你可以吧系统图标，背景什么的换成你自己喜欢的风格。这里附上一张我采用的主题开机界面如果你也喜欢这一风格，这里是链接地址。 refind是一款免费的软件(官方下载地址)，如果你高兴也可以给作者赞助。 如果使用UEFI引导方式启动系统的话，在安装Ubuntu时要预留一个efi分区用来存放开机引导文件，预留大概200MB-500MB即可。 Ubuntu下安装 推荐在ubuntu下安装refind，简单到让人不敢相信。你只需要把软件下载下来，在终端运行里面的.shell文件，就会自动安装，无需任何额外的操作，重启系统，进入bios在启动顺序里将rEFInd调为第一个即可。 Windows下安装 如果你非要不信邪，在Windows下尝试安装的话，我也不反对。首先你需要一个能够进入系统隐藏分区的软件——DiskGenius。推荐去官网下载正版而不要用盗版（然后去百度激活码…咳咳），毕竟牵涉到系统文件万一崩了别怪我没提醒。 第一步，找到你系统的esp分区 第二步，将下载的refind文件夹及其里面所有的东西全部复制进去。（注意：虽然DiskGenius支持同时复制多个文件，但是文件夹没法复制，只能自己先手动创建） 同时必须要自己创建一个refind.conf文件，可以什么都不写但是不能没有。 然后原来的refind.conf-sample文件就可以删除了。 第三步，将一些不需要的文件删除，如果你在网上下载了一些主题的话，也一并把文件复制进去。 第四步，下载bootice，打开DIskGenius给你放refind文件的那个分区取个卷标（随便什么都可以，下面有用）。打开bootice——UEFI——修改启动序列(也可以顺手吧下面那个下次启动直接进入bios勾上，省的下次进bios要手动)。点击添加，找到你之前分配盘符的那个盘（也就是esp分区），找到里面的refind文件夹，选择对应你系统的.efi文件，点击确定。重启系统，进入bios，将rEFInd启动项调整为第一个即可。（没有对比就没有伤害，Windows下简直烦死，还不一定成功…） 最后希望各位都能成功在UEFI模式下完成双系统的安装和引导。 双系统时间差的问题解决 这个问题出现在切换系统时，每次时间都会错误到0时区。 解决方法：Ubuntu下关闭UTC(世界协调时间): sudo vim /etc/default/rcS 找到UTC=yes，改为UTC=no即可 详细原因 但是注意：在 Ubuntu 16.04 版本以前，关闭UTC的方法是编辑/etc/default/rcS，将UTC=yes改成UTC=no， 但在Ubuntu 16.04使用systemd启动之后，时间改成了由timedatectl来管理，所以更改方法是: 1timedatectl set-local-rtc 1 --adjust-system-clock 之后重启应该就不会出现问题了。 最后更新于2018.10.15]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>๑Ubuntu</tag>
        <tag>๑Linux</tag>
        <tag>๑DualSystem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to Fleschier Blog]]></title>
    <url>%2F2018%2F04%2F05%2Fhello-2018%2F</url>
    <content type="text"><![CDATA[“It’s just a begining.” 前言 渐寒 的 博客终于开通了。 几经辗转，在github上发现了自定义的博客这一功能，终于可以自己写一些东西了。然而对于我这样一个对前端没啥了解的人来说，只能借用别人造好的轮子来自定义博客的风格。这一点等以后啥时候有兴趣学前端了再自己DIY吧。 正文 第一次自己写博客还是很有新鲜感的。 搭建自己在github上的博客需要创建一个名为yourusername.github.io的repository，然后你需要选择一款Jekyll主题来使你的博客更加个性化。（当然像我一样的小白就先借用别人写好的框架来吧）。在创建好repository之后最好先clone到本地，这样便于后面的更改直接在本地进行然后通过git来提交就好了。在github上选择一个别人写好的，你比较中意的主题，然后clone下来，将其中你需要的文件加到你自己的库当中。（其中可能会包含别人写的文章啊，一些图片什么的，这些都可以删掉或者替换掉）。这里附上一个相对比较详细的教程——如何快速搭建自己的github.io博客。当然这里不可能把所有的细节都写清楚，有很多有趣的东西会在你尝试的过程中不断涌现出来，大胆的去尝试吧。 博文都是需要通过markdown编辑器来编写的。当然这也很简单，推荐使用的软件是MarkdownPad2。如果需要激活秘钥什么的直接百度吧（滑稽）。这里需要补充一下的是，MarkdownPad2 这款软件使用时会产生bug，官方的说法是从 Win 8 开始就有这个问题了(我用的是win10)，解决办法就是安装 Awesomium 1.6.6 SDK。如果还是不行就再安装 Microsoft’s DirectX End-User Runtimes (June 2010)。下面是官方的原文： LivePreview is not working - it displays an error message stating This view has crashed! This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane. To fix this issue, please try installing the Awesomium 1.6.6 SDK. If you continue to experience issues, please install Microsoft’s DirectX End-User Runtimes (June 2010). 对于提交的 XXX.markdown格式的文章，必须要放在_posts文件夹下，命名的格式必须为YEAR-MONTH-DAY-title.markdown并且title也必须用-来连接而不要用下划线，不要用下划线，不要用下划线… 最后附上markdown的简单教程，很简单，一个小时之内上手完全没问题。献给写作者的 Markdown 新手指南。 关于多个标签 如果一篇博客归属于多个标签，则在tags一栏以 空格 分割各个标签。 使用jekyll本地预览网页 参考我的另一个博客——Ubuntu下使用jekyll本地预览博客效果 更详细的一个博客 关于表格对齐的问题 在表格的第二行：|---|---|...|这样的格式里，如果某个单元格写成|---|，则表示居中。如果写成|:---|则表示左对齐。 最后更新于2018.7.12]]></content>
      <categories>
        <category>Personal Blog</category>
      </categories>
      <tags>
        <tag>๑Blog</tag>
      </tags>
  </entry>
</search>
